<!-- build time:Thu Jun 30 2022 22:28:34 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="baidu-site-verification" content="code-NAUyjdjtWe"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="熵白之痕" href="https://entropywhite.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="熵白之痕" href="https://entropywhite.com/atom.xml"><link rel="alternate" type="application/json" title="熵白之痕" href="https://entropywhite.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/css/app.css?v=0.2.5"><link rel="canonical" href="https://entropywhite.com/computer-science/web/%E4%BA%92%E8%81%94%E7%BD%91/QUIC%E5%8D%8F%E8%AE%AE/"><title>| Entropy White = 熵白之痕 = 以前进为目标吧</title><meta name="generator" content="Hexo 5.4.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"></h1><div class="meta"><span class="item" title="创建时间：2022-03-02 08:50:23"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-02T08:50:23+08:00">2022-03-02</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.3k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Entropy White</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipey0a334j20zk0m8qpt.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipevarprfj20zk0m8npd.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclffsa1cj20zk0m811l.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicis3attqj20zk0m8k7l.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giph4baakhj20zk0m8h5q.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://entropywhite.com/computer-science/web/%E4%BA%92%E8%81%94%E7%BD%91/QUIC%E5%8D%8F%E8%AE%AE/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/images/cat.jpg"><meta itemprop="name" content="EntropyWhite"><meta itemprop="description" content="以前进为目标吧, 欢迎来到熵白的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="熵白之痕"></span><div class="body md" itemprop="articleBody"><h1 id="诞生背景"><a class="anchor" href="#诞生背景">#</a> 诞生背景</h1><ul><li><p>HTTP/1：每次请求都建立一个 TCP 连接</p></li><li><p>HTTP/1.1：支持长连接，同一个 IP 对应一个 TCP 连接</p></li><li><p>HTTP/2：TCP 多路复用，同一个 TCP<strong> 并发</strong> <strong>多个 HTTP 请求</strong></p></li><li><ul><li>并发数量在浏览器实现上有限制，以 Chrome 为例为 6，普遍为 6～8（可能为滑动窗口大小限制，或者因为更多的并发数量若发生头部拥塞使得总体传输速率下降）</li><li><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C37.png" alt></li></ul></li></ul><p>使用 HTTP/2 所提供的多路复用功能在链路出现丢包时，TCP 的按序确认机制使得丢失的数据包需要等待重新发送和确认，滑动窗口停滞，其后的所有数据包都被阻塞，这样一来 HTTP/2 在这种情形下的表现反而不如 HTTP/1。</p><p>此外，HTTP/2 在建立 TCP 连接的时，需要和服务器进行三次握手来确认连接成功，会消耗 1.5 个 RTT，如果使用 HTTPS 的话，还需要使用 TLS 协议进行加密，而 TLS 也根据版本需要 1～2 个 RTT（TLS1.2 需要 1RTT），也就是说，使用 HTTP/2 在信息得到传输前就需要消耗 3～4 个 RTT（至少 2.5RTT）的时间。</p><h2 id="tcp的短板问题"><a class="anchor" href="#tcp的短板问题">#</a> TCP 的短板问题</h2><ol><li><p><strong>TCP</strong> <strong>+TSL 握手占用时间</strong>（至少 2.5RTT）</p></li><li><p>TCP 巨大的头部浪费带宽（20～60 字节）</p></li><li><ol><li><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C38.png" alt></li></ol></li><li><p><strong>TCP</strong> <strong>头部拥塞</strong></p></li></ol><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C39.png" alt="图片"></p><p>TCP 的按序确认除了导致头部拥塞外，还导致了另一个重传包数量问题：TCP 接收方可以将未按序到达的数据包 37、38、40 先行缓存（并且引入快速重传机制，回送缺失数据包 34 的 ack 不断提醒发送方，如果发送方连续收到 3 次相同的 ack，就会重传，防止超时引发窗口缩小），但是由于 ack 序列号只能确认连续的数据包，所以无法通知发送方 37、38、40 已经先行到达，只能发送数据包 34 的 ack，而发送方在接收到重传请求后不确定从 35～41 这些已经发送的数据包要不要同样重传，因为后续的包可能被接收，也可能丢失。如果全部重传，那么会浪费带宽，如果不重传，那么如果这些包丢失，就会浪费时间。（后续又引入了 SACK 机制：<span class="exturl" data-url="aHR0cHM6Ly9jYW96aXllLnRvcC8yMDE5LzEwL1RDUC1PcHRpb25zLyVFRiVCQyU4QyVFNCVCRCU4NiVFNiU5OCVBRlNBQ0slRTUlOEYlODglRTclQkIlQTclRTclQkIlQUQlRTUlQTIlOUUlRTUlQTQlQTclRTQlQkElODZUQ1AlRTclOUElODQlRTUlQTQlQjQlRTklODMlQTglRUYlQkMlODk=">https://caoziye.top/2019/10/TCP-Options/，但是 SACK 又继续增大了 TCP 的头部）</span></p><ol><li>TCP 连接无法迁移（源 IP + 源 Port + 目标 IP + 目标 Port + 传输层协议）</li></ol><p>除了传输层协议是 TCP 不变以外，剩下的四元组其中任一发生变化，TCP 连接就会断开，需要重新和新的 ip:port 重新握手建立连接。比如移动设备 wifi 和 5g 网络的切换，或者是行车过程中导致的移动网络节点的切换都会让 TCP 的连接断开。</p><p><strong>传输层协议带来的问题无法在应用层协议上得到解决</strong>，并且 TCP 因为已经存在了 40 多年，基于 TCP 协议的更新非常难以推进（因为被大量内置于操作系统内核、中间件固件以及硬件实现中），因此 Google 基于 UDP 协议推出了 QUIC 协议。</p><p>UDP 协议相较于 TCP，拥有更小的头部，简单而高效，但是不保证可靠交付，因此使用 UDP 协议同时为了确保数据传输的可靠性，需要自己维护丢包检测、数据确认、拥塞控制、重传等等一系列基础设施。</p><h1 id="quic主要特性"><a class="anchor" href="#quic主要特性">#</a> QUIC 主要特性</h1><h2 id="多路复用"><a class="anchor" href="#多路复用">#</a> 多路复用</h2><p>HTTP/2.0 使得一个 TCP 连接能够顺序传输多个文件，再通过 SPDY 协议实现请求的并发以及优先级控制，但是终归会受到头部拥塞的限制。</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C40.png" alt="图片"></p><p><img data-src="https://mmbiz.qpic.cn/mmbiz_png/ndgH50E7pIqRCfibc6I6rX39uELDemJcFwI9W0aIAMbcjIFlVWcqfz6prHhFvlKibjFoHBevOzBaR0oxBg2kGlcg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>而 QUIC 是基于 UDP 的，在传输层层面并没有固定的连接，可以根据需要开辟任意逻辑链路。QUIC 一次建立一个 Connection，一个 Connection 下包含多个 Stream 流（每个 stream 独自维护一个逻辑连接，因为 UDP 层面上是无连接的），每个流对应一个文件传输，并将不同的 Stream 中的数据交付给不同的上层应用。QUIC 的一个 Connection 对应多个 Stream，Stream 之间相互独立，因此任意一条链路断开都不会导致其他数据阻塞。</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C41.png" alt="图片"></p><h2 id="协议头部"><a class="anchor" href="#协议头部">#</a> 协议头部</h2><p>QUIC 是基于 UDP 的，所以最外层是 UDP 头部（单位为 Bit）</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C42.png" alt="图片"></p><p>内部是 QUIC Connection 头部和每个 Stream 的 Frame 头部（单位为 Bit）</p><p>具体每个头部字段含义和标志位过于机械和繁杂，有兴趣可以直接查看原文 https://datatracker.ietf.org/doc/html/rfc9000#section-12</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C43.png" alt="图片"></p><ul><li><p>Flags: 用于表示 Connection ID 长度、Packet Number 长度等信息；</p></li><li><p>Connection ID：客户端选择的无符号 64 位统计随机数，该数字是连接的标识符。由于 QUIC 的连接被设计为，即使客户端漫游，连接依然保持建立状态，因而 IP 4 元组（源 IP，源端口，目标 IP，目标端口）可能不足以标识连接。对每个传输方向，当 4 元组足以标识连接时，连接 ID 可以省略。</p></li><li><p>QUIC Version：QUIC 协议的版本号，32 位的可选字段。</p></li><li><p>Diversification nonce：这是服务端用于生成会话密钥的字段，仅存于服务端 -&gt; 客户端的请求中。一旦前向保密连接得到建立，后续就不会再包含这个字段了，简单理解就是只在服务端 -&gt; 客户端的握手请求中才会使用。（因此 QUIC 工作组也推进 TLS 的后续标准将这个字段整合进 TLS1.3 的头部中，而不存在于 QUIC 中）</p></li><li><p>Packet Number：长度取决于 Public Flag 中 Bit4 及 Bit5 两位的值，最大长度 6 字节。发送端在每个普通报文中设置 Packet Number。发送端发送的第一个包的序列号是 1，随后的数据包中的序列号的都大于前一个包中的序列号；</p></li><li><p>Stream ID：用于标识当前数据流属于哪个资源请求；</p></li><li><p>Offset：标识当前数据包在当前 Stream ID 中的偏移量。</p></li></ul><h2 id="数据流控制"><a class="anchor" href="#数据流控制">#</a> 数据流控制</h2><p>QUIC 提供了两种层面上的数据流控制方案：</p><ul><li><p>Stream 流量控制，通过限制在任何 stream 上可以发送的最大绝对字节偏移量，防止单个 stream 消耗连接（connection）的全部接收缓冲。</p></li><li><p>Connection 流量控制，通过限制所有 <code>STREAM</code> 帧的数据总字节数，防止发送方超过接收方的连接缓冲容量。</p></li></ul><h3 id="stream控制"><a class="anchor" href="#stream控制">#</a> Stream 控制</h3><ul><li><p>QUIC 的 Stream 流基于 Stream ID+Offset 进行包确认，流量控制需要保证所发送的所有包 offset 小于<strong>最大绝对字节偏移量</strong> <strong>（</strong> <strong>maximum absolute byte offset</strong> <strong>）</strong> <strong>，</strong> 该值是基于当前已经<strong>提交的字节偏移量（offset of data consumed）</strong> 而进行确定的，QUIC 会把连续的已确认的 offset 数据向上层应用提交。QUIC 支持乱序确认，但本身也是按序（offset 顺序）发送数据包。</p></li><li><p>QUIC 利用 ack frame 来进行数据包的确认，来保证可靠传输。一个 ack frame 只<strong>包含多个确认信息</strong>，没有正文。</p></li><li><p>如果数据包 N 超时，发送端将超时数据包 N 重新设置编号 M（即下一个顺序的数据包编号） 后发送给接收端。</p></li><li><p>在一个数据包发生超时后，其余的已经发送的数据包依旧可以基于 Offset 得到确认，避免了 TCP 利用 SACK 才能解决的重传问题。</p></li></ul><blockquote><p>💡 其实 QUIC 的乱序确认设计思想并不新鲜，大量网络视频流就是通过类似的基于 UDP 的 RUDP、RTP、UDT 等协议来实现快速可靠传输的。他们同样支持乱序确认，所以就会导致这样的观看体验：明明进度条显示还有一段缓存，但是画面就是卡着不动了，如果跳过的话视频又能够播放了。</p></blockquote><ol><li>如图所示，当前缓冲区大小为 8，QUIC 按序（offset 顺序）发送 29-36 的数据包：</li></ol><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C44.png" alt="图片"></p><ol><li>31、32、34 数据包先到达，基于 offset 被优先乱序确认，但 30 数据包没有确认，所以当前已提交的字节偏移量不变，缓存区不变。</li></ol><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C45.png" alt="图片"></p><ol><li>30 到达并确认，缓存区收缩到阈值，接收方发送 MAX_STREAM_DATA frame（协商缓存大小的特定帧）给发送方，请求增长最大绝对字节偏移量。</li></ol><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C46.png" alt="图片"></p><ol><li>协商完毕后最大绝对字节偏移量右移，缓存区变大，同时发送方发现数据包 33 超时</li></ol><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C47.png" alt="图片"></p><ol><li>发送方将超时数据包重新编号为 42 继续发送</li></ol><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C48.png" alt="图片"></p><p>以上就是最基本的数据包发送 - 接收过程，控制数据发送的唯一限制就是最大绝对字节偏移量，该值是接收方基于当前已经提交的偏移量（连续已确认并向上层应用提交的数据包 offset）和发送方协商得出。</p><h3 id="connection控制"><a class="anchor" href="#connection控制">#</a> Connection 控制</h3><p>除了 Stream 层面的数据流控制之外，QUIC 还提供了 Connection 层面的总体缓存大小控制，Connection 具有总体的缓冲区大小限制，并且可以为其中的各个 stream 动态分配缓冲区大小，在总体缓冲区大小不变的情况下优先向速度更快的 stream 倾斜（并不是平均分配）。</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C49.png" alt="图片"></p><p>如图所示，Connection 具有传输字节上限，即 Stream1、2、3 的 Maximum Offset 之和不得超过该上限，QUIC 会根据网络情况为各个 Stream 分配不同的偏移量，并且随着传输的进行，接收方会发送 MAX_DATA frame 通知发送方提高 Connection 总体传输字节分配上限，并在 Stream 连接中通过 MAX_STREAM_DATA frame 为各个 Stream 分配更多的缓存。</p><h2 id="快速握手与加密传输"><a class="anchor" href="#快速握手与加密传输">#</a> 快速握手与加密传输</h2><p>QUIC 在握手过程中使用 Diffie-Hellman 算法协商初始密钥，初始情况下服务器存储的配置参数如下：</p><ol><li><p>Server Config：一个服务器配置文件，包括服务器端的 Diffie-Hellman 算法的<strong>长期公钥 A 以及两个固定质数 g 和 p</strong></p></li><li><p>Certificate Chain：用来对服务器进行认证的信任链证书</p></li><li><p>Signature of the Server Config：Server Config 的签名并用信任链的叶子证书的私钥加密</p></li><li><p>Source-Address Token：一个经过身份验证的加密块，包含客户端可见的 IP 地址和服务器的时间戳。</p></li></ol><p>这些参数会周期性的更新。</p><h3 id="diffie-hellman-算法的基本原理"><a class="anchor" href="#diffie-hellman-算法的基本原理">#</a> Diffie-Hellman 算法的基本原理</h3><blockquote><p>Diffie-Hellman 并不是加密算法，而是密钥的一种交换技术，可以通过该算法在双方互不知情的情况下建立加密通讯</p></blockquote><p>假设 Alice 为服务器，Bob 为客户端</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C50.png" alt="图片"></p><ul><li><p>Alice 和 Bob 都知道两个素数（g、p）的存在</p></li><li><p>Alice 随机选择 a 作为 private key，Bob 随机选择 b 作为 private key</p></li></ul><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C51.png" alt="图片"></p><p>于是，双方都有了一个共享密钥 （初始密钥）K。简单理解，a、b 就相当于密钥，A、B 就相当于公钥。</p><p>随后再利用这个初始密钥商定会话密钥，之后就一直用会话密钥沟通了。</p><h3 id="密钥交换过程"><a class="anchor" href="#密钥交换过程">#</a> 密钥交换过程</h3><p><strong>QUIC</strong> <strong>首次连接需要 1RTT，具体过程如下：</strong></p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C52.png" alt="图片"></p><p><strong>step1：</strong> 客户端发送 Inchoate Client Hello 消息（CHLO）请求建立连接。</p><p><strong>step2：</strong> 服务器根据一组质数 p 以及其原根 g 和 a（长期私钥）算出 A（长期公钥），将 Apg（通过 CA 证书私钥加密后）放在 serverConfig 里面，发到 Rejection 消息（REJ）到客户端；</p><blockquote><p>服务器一开始不直接使用随机生成的短期密钥的原因就是因为客户端可以缓存下服务端的长期公钥，这样在下一次连接的时候客户端就可以直接使用这个长期公钥实现 0-RTT 握手并直接发送加密数据</p></blockquote><p><strong>setp3&amp;4：</strong> 客户端在接收到 REJ 消息后，会随机选择一个数 b（短期密钥），并用 CA 证书获取的公钥解密出 serverConfig 里面的 p、A 和 b 就可以算出初始密钥 K，并将 B（Complete client hello 消息）和用初始密钥 K 加密的 Data 数据发到服务器。</p><p><strong>step5：</strong> 服务器收到客户端发来的公开数 B，再利用 p、g 计算得到同样的初始秘钥 K，来解密客户端发来的数据。这时会利用其他加密算法<strong>随机生成此次会话密钥 K'</strong> ，再通过初始密钥 K 加密 K' 发送给客户端 (SHLO)（每次会话都是用随机密钥，并且服务器会定期更新 a 和 A，实际上这就是为了保证前向安全性）</p><blockquote><p>在密码学中，前向保密（Forward Secrecy）是密码学中通讯协议的安全属性，指的是当前使用的主密钥泄漏不会导致过去的会话密钥泄漏。</p></blockquote><p><strong>step6：</strong> 客户端收到 SHLO 后利用初始密钥 K 解出会话密钥 K'，二者后续的会话都使用 K' 加密。</p><h2 id="连接迁移"><a class="anchor" href="#连接迁移">#</a> 连接迁移</h2><p>TCP 的连接标识是通过 “源 IP + 源 Port + 目标 IP + 目标 Port + 传输层协议（TCP）” 组成的唯一五元组，一旦其中一个参数发生变化，则需要重新创建新的 TCP 连接。</p><ul><li><p>比如 wifi 和 5g 网络切换</p></li><li><p>服务数据节点切换</p></li></ul><p>都会造成 TCP 断线，需要客户端上层应用重新发送请求建立连接（又一次进行握手）</p><p>QUIC 连接不再以 IP 及端口四元组标识，而是以一个服务端产生的 <strong>64 位的随机数作为 ID</strong> 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。（当然如果 UDP 和 IP 协议所包含的源 IP + 源 Port + 目标 IP + 目标 Port 四元组已经能够标识链接的唯一性的话，connection 头部是可忽略的）</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C53.png" alt="图片"></p><p><strong>连接迁移的简化流程（实际情况更为复杂）：</strong></p><ol><li><p>连接迁移之前，客户端的 IP 1，使用非探测包（Non-probing Packet）和服务端进行通信。</p></li><li><p>客户端的 IP 变成 2，它继续发送非探测包维持通信，将连接迁移到新的地址。</p></li><li><p>服务端收到包后在新路径启动<strong>路径验证</strong> [1]，验证新路径的可达性，以及客户端对其新 IP 地址的所有权。</p></li><li><ol><li>服务端发送包含 <code>PATH_CHALLENGE</code> 帧的探测包（Probing Packet）， <code>PATH_CHALLENGE</code> 帧里面包含一个不可预测的随机值。</li><li>客户端在 <code>PATH_RESPONSE</code> 帧里面包含前一步 <code>PATH_CHALLENGE</code> 接收到的随机值，响应探测包（Probing Packet）。</li><li>服务端接收到客户端发送的的 <code>PATH_RESPONSE</code> ，验证 payload 里面的值是否正确。</li></ol></li><li><p>随后客户端也会对服务端进行路径验证保证双向通信。</p></li></ol><h2 id="丢包检测"><a class="anchor" href="#丢包检测">#</a> 丢包检测</h2><p>TCP 传输的数据只包括校验码，并没有增加纠错码等冗余数据，如果出现部分数据丢失或损坏，只能重新发送该数据包。</p><p>QUIC 引入了前向冗余纠错码（FEC: Fowrard Error Correcting），如果接收端出现少量（不超过 FEC 的纠错能力）的丢包或错包，可以借助冗余纠错码恢复丢失或损坏的数据包，这就不需要再重传该数据包了，降低了丢包重传概率，自然就减少了拥塞控制机制的触发次数，可以维持较高的网络利用效率。因此需要根据当前网络状况设置一定比率的冗余数据，就可以带来网络利用率的提升。</p><p>此外由于 QUIC 采用单向递增的 Packet Number 来标识数据包，所以不像 TCP 会因为超时重传的同样序列的数据包而和原数据包重叠，造成 RTT 测量的不准确，进而导致<strong> RTO</strong> (Retransmission Time Out：重传超时时间）的不准确。</p><h3 id="tcp的rtt计算"><a class="anchor" href="#tcp的rtt计算">#</a> TCP 的 RTT 计算</h3><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C54.png" alt="图片"></p><p>TCP 对于此问题也是非常头疼，于是也不断进行改进，比如</p><ul><li><p><strong>忽略重传，不把重传的</strong> <strong>RTT</strong> <strong>做采样，</strong> 但是当网络波动产生大延时，所有的包都需要重传而此时 RTO 又不会被更新，导致数据包超时时间估算不准确。</p></li><li><p>通过各种参数修正的计算方法：</p><h3 id="quic的rtt计算"><a class="anchor" href="#quic的rtt计算">#</a> QUIC 的 RTT 计算</h3></li><li><ul><li>首先计算平滑平滑 RTT（Smooth RTT）</li><li><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C55.png" alt="图片"></li><li>计算平滑 RTT 和真实的差距（加权移动平均）</li><li><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C56.png" alt="图片"></li><li>再经过各种修正最终得出 RTO：</li><li><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C57.png" alt="图片"></li><li>在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4 —— nobody knows why, it just works…</li></ul></li></ul><p>QUIC 的包号不会重复，重传的包采用了新的 Packet Number，因此不会产生 RTT 歧义问题</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C58.png" alt="图片"></p><p>因此 QUIC 对于 RTT 的计算更为准确，预估的超时时间能够有效防止更多的重传请求被错误地发送回发送端。同时也给予了 QUIC 网络更为快速的反应时间，及时通知发送方重传数据包。</p><h2 id="自定义拥塞控制"><a class="anchor" href="#自定义拥塞控制">#</a> 自定义拥塞控制</h2><p>QUIC 的传输控制不再依赖内核的拥塞控制算法，而是实现在应用层上，这意味着我们根据不同的业务场景，实现和配置不同的拥塞控制算法以及参数。比如 BRR 或者 Cubic，如果有兴趣可以自行查阅相关算法资料。</p><h2 id="在http3上的应用"><a class="anchor" href="#在http3上的应用">#</a> 在 HTTP/3 上的应用</h2><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C59.png" alt="图片"></p><ol><li><p>wifi 和移动网络无缝切换</p></li><li><p>更强的网络安全性（前向安全 + 全载荷加密）</p></li><li><p>在慢网情况下更高的传输速率</p></li></ol><h3 id="quic离我们并不遥远"><a class="anchor" href="#quic离我们并不遥远">#</a> QUIC 离我们并不遥远</h3><p>QUIC 早在 2012 年就已经开始试验性部署，关于其详细草案在 2015 年向 IETF 提出，终于在 2021 年五月被接受并于 RFC9000 中标准化。</p><p><code>chrome://flags/#enable-quic</code> 在 chrome 浏览器中可以选择是否开启 QUIC 实验性功能，如果服务端支持 QUIC 协议，就会启用该协议（大部分都是 Google 的服务器）。</p><p>推荐一个插件可以查看当前网页支持的连接类型：HTTP/2 and SPDY indicator：</p><p><span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvaHR0cDItYW5kLXNwZHktaW5kaWNhdG9yL21wYnBvYmZmbG5wY2dhZ2ppamhtZ25jaGdnY2pibGlu">https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin</span></p><h2 id="性能参考数据来源腾讯pcg研发部"><a class="anchor" href="#性能参考数据来源腾讯pcg研发部">#</a> 性能参考（数据来源：腾讯 PCG 研发部）</h2><p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvREh2dnA2RVVSNXREZmZKcXpWaXIwQQ==">https://mp.weixin.qq.com/s/DHvvp6EUR5tDffJqzVir0A</span></p><p>60kb 主页面资源加载速度（单位：毫秒）</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C60.png" alt="图片"></p><h3 id="弱网环境下的表现"><a class="anchor" href="#弱网环境下的表现">#</a> 弱网环境下的表现</h3><p>不同丢包率下的下载耗时</p><p><img data-src="W:%5C%E7%AC%94%E8%AE%B0%5C%E4%BA%92%E8%81%94%E7%BD%91%5C%E5%9B%BE%5C61.png" alt="图片"></p><p>从总体上来看，QUIC 在网络环境良好的情况下对于当前 HTTP2 的提升有限，尤其是首次 1-RTT 握手的总体时间消耗提升只有 15% 左右，但是在后续有缓存的情况下建立连接的速度就会快很多，首次响应时间将会大大缩小。</p><p>此外在弱网环境下，尤其是丢包率高的情况下 QUIC 对于性能提升十分惊人，良好的 RTO 估算机制使得超时重发的估算变得更为精确。同时多个逻辑连接使得文件与文件之间的传输互不干扰阻塞，加上更加轻量的头部和简单高效的握手方式，因此能够在弱网环境下取得更为强大的表现。</p><h1 id="总结"><a class="anchor" href="#总结">#</a> 总结</h1><p>随着网络基础设施的提升，UDP 的传输准确率也得到了很大的提升，而 TCP 却因为 20～60 字节的头部以及可能的头部拥塞导致一定的效率降低，但是 TCP 协议已经被大量内置于操作系统内核中，因此只能利用 UDP 进行定制化。虽然 QUIC 可能会在小页面的性能不如 TCP，但随着前端日益复杂化，资源量不断增大的情况下，使用 QUIC 替换 TCP 将能够显著提升传输速率。</p><p>放弃 TCP 而使用基于 UDP 的 QUIC，有点类似早期 x86cpu 内置的 tss 硬件切换不好用，linux 系统内核直接使用软件控制进程上下文切换。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-05-05 10:33:54" itemprop="dateModified" datetime="2022-05-05T10:33:54+08:00">2022-05-05</time> </span><span id="computer-science/web/互联网/QUIC协议/" class="item leancloud_visitors" data-flag-title="" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>EntropyWhite <i class="ic i-at"><em>@</em></i>熵白之痕</li><li class="link"><strong>本文链接：</strong> <a href="https://entropywhite.com/computer-science/web/%E4%BA%92%E8%81%94%E7%BD%91/QUIC%E5%8D%8F%E8%AE%AE/">https://entropywhite.com/computer-science/web/互联网/QUIC协议/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/web/%E4%BA%92%E8%81%94%E7%BD%91/SSL%E3%80%81TLS/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph4lm9i7j20zk0m84qp.jpg" title="未命名"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div><div class="item right"><a href="/computer-science/web/%E4%BA%92%E8%81%94%E7%BD%91/http%E7%8A%B6%E6%80%81%E7%A0%81/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipeu7txpzj20zk0m81kx.jpg" title="未命名"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%9E%E7%94%9F%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">诞生背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E7%9A%84%E7%9F%AD%E6%9D%BF%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.</span> <span class="toc-text">TCP 的短板问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#quic%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">QUIC 主要特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E5%A4%B4%E9%83%A8"><span class="toc-number">2.2.</span> <span class="toc-text">协议头部</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">数据流控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#stream%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.1.</span> <span class="toc-text">Stream 控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connection%E6%8E%A7%E5%88%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">Connection 控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93"><span class="toc-number">2.4.</span> <span class="toc-text">快速握手与加密传输</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diffie-hellman-%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">2.4.1.</span> <span class="toc-text">Diffie-Hellman 算法的基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.2.</span> <span class="toc-text">密钥交换过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%BF%81%E7%A7%BB"><span class="toc-number">2.5.</span> <span class="toc-text">连接迁移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A2%E5%8C%85%E6%A3%80%E6%B5%8B"><span class="toc-number">2.6.</span> <span class="toc-text">丢包检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E7%9A%84rtt%E8%AE%A1%E7%AE%97"><span class="toc-number">2.6.1.</span> <span class="toc-text">TCP 的 RTT 计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quic%E7%9A%84rtt%E8%AE%A1%E7%AE%97"><span class="toc-number">2.6.2.</span> <span class="toc-text">QUIC 的 RTT 计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">2.7.</span> <span class="toc-text">自定义拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8http3%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.8.</span> <span class="toc-text">在 HTTP&#x2F;3 上的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#quic%E7%A6%BB%E6%88%91%E4%BB%AC%E5%B9%B6%E4%B8%8D%E9%81%A5%E8%BF%9C"><span class="toc-number">2.8.1.</span> <span class="toc-text">QUIC 离我们并不遥远</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%8F%82%E8%80%83%E6%95%B0%E6%8D%AE%E6%9D%A5%E6%BA%90%E8%85%BE%E8%AE%AFpcg%E7%A0%94%E5%8F%91%E9%83%A8"><span class="toc-number">2.9.</span> <span class="toc-text">性能参考（数据来源：腾讯 PCG 研发部）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%B1%E7%BD%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E8%A1%A8%E7%8E%B0"><span class="toc-number">2.9.1.</span> <span class="toc-text">弱网环境下的表现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="EntropyWhite" data-src="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/images/cat.jpg"><p class="name" itemprop="name">EntropyWhite</p><div class="description" itemprop="description">欢迎来到熵白的博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">128</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0plcnlzdXJw" title="https:&#x2F;&#x2F;github.com&#x2F;Jerysurp"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNTEzMTAwNDY/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;51310046?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/web/%E4%BA%92%E8%81%94%E7%BD%91/SSL%E3%80%81TLS/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/web/%E4%BA%92%E8%81%94%E7%BD%91/http%E7%8A%B6%E6%80%81%E7%A0%81/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/computer-science/web/JavaScript/AJAX/XHR-readyState/" title="onreadystatechange事件">onreadystatechange事件</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/%E4%BA%92%E8%81%94%E7%BD%91/DNS%E5%8E%9F%E7%90%86/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/blog/" title="分类于 hexo博客">hexo博客</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/blog/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/computer-science/blog/Create%20Blog/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/" title="安装hexo和部署到github">安装hexo和部署到github</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/html/" title="分类于 html">html</a></div><span><a href="/computer-science/web/html/%E8%A1%A8%E5%8D%95%E5%92%8C%E9%AA%8C%E8%AF%81/" title="表单和验证">表单和验证</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/css/" title="分类于 css">css</a></div><span><a href="/computer-science/web/css/CSS%E8%A7%84%E8%8C%83/CSS%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/" title="CSSmei">CSSmei</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/W3C/W3C-XQuery%E6%B4%BB%E5%8A%A8/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/SVN/SVN%E7%AE%80%E4%BB%8B/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/html/SEO%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/W3C/W3C-XSL%E6%B4%BB%E5%8A%A8/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/blog/" title="分类于 hexo博客">hexo博客</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/blog/Theme-Shoka-Documentation/" title="分类于 Theme Shoka Documentation">Theme Shoka Documentation</a></div><span><a href="/computer-science/blog/theme-shoka-doc/%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/" title="Step.2 基本配置">Step.2 基本配置</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">EntropyWhite @ Entropy White</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">304k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:36</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/web/互联网/QUIC协议/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->