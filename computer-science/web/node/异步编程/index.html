<!-- build time:Mon Jul 11 2022 20:36:33 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="baidu-site-verification" content="code-NAUyjdjtWe"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="熵白之痕" href="https://entropywhite.com/rss.xml"><link rel="alternate" type="application/atom+xml" title="熵白之痕" href="https://entropywhite.com/atom.xml"><link rel="alternate" type="application/json" title="熵白之痕" href="https://entropywhite.com/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/css/app.css?v=0.2.5"><link rel="canonical" href="https://entropywhite.com/computer-science/web/node/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><title>| Entropy White = 熵白之痕 = 以前进为目标吧</title><meta name="generator" content="Hexo 5.4.1"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline"></h1><div class="meta"><span class="item" title="创建时间：2022-03-22 23:20:28"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2022-03-22T23:20:28+08:00">2022-03-22</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>7.4k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>7 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Entropy White</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicli3sbvtj20zk0m8x6p.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclgrvbd6j20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipeybxm1pj20zk0m8niv.jpg"></li><li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipetlbztpj20zk0m84qp.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://entropywhite.com/computer-science/web/node/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/images/cat.jpg"><meta itemprop="name" content="EntropyWhite"><meta itemprop="description" content="以前进为目标吧, 欢迎来到熵白的博客"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="熵白之痕"></span><div class="body md" itemprop="articleBody"><h3 id="回调"><a class="anchor" href="#回调">#</a> 回调</h3><p>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。我们首先可以看看以下代码。</p><pre><code>function heavyCompute(n, callback) &#123;
    var count = 0,
        i, j;

    for (i = n; i &gt; 0; --i) &#123;
        for (j = n; j &gt; 0; --j) &#123;
            count += 1;
        &#125;
    &#125;

    callback(count);
&#125;

heavyCompute(10000, function (count) &#123;
    console.log(count);
&#125;);

console.log('hello');

-- Console ------------------------------
100000000
hello
</code></pre><p>可以看到，以上代码中的回调函数仍然先于后续代码执行。JS 本身是单线程运行的，不可能在一段代码还未结束运行时去运行别的代码，因此也就不存在异步执行的概念。</p><p>但是，如果某个函数做的事情是创建一个别的线程或进程，并与 JS 主线程并行地做一些事情，并在事情做完后通知 JS 主线程，那情况又不一样了。我们接着看看以下代码。</p><pre><code>setTimeout(function () &#123;
    console.log('world');
&#125;, 1000);

console.log('hello');

-- Console ------------------------------
hello
world
</code></pre><p>这次可以看到，回调函数后于后续代码执行了。如同上边所说，JS 本身是单线程的，无法异步执行，因此我们可以认为 <code>setTimeout</code> 这类 JS 规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让 JS 主进程可以接着执行后续代码，并在收到平行进程的通知后再执行回调函数。除了 <code>setTimeout</code> 、 <code>setInterval</code> 这些常见的，这类函数还包括 NodeJS 提供的诸如 <code>fs.readFile</code> 之类的异步 API。</p><p>另外，我们仍然回到 JS 是单线程运行的这个事实上，这决定了 JS 在执行完一段代码之前无法执行包括回调函数在内的别的代码。也就是说，即使平行线程完成工作了，通知 JS 主线程执行回调函数了，回调函数也要等到 JS 主线程空闲时才能开始执行。以下就是这么一个例子。</p><pre><code>function heavyCompute(n) &#123;
    var count = 0,
        i, j;

    for (i = n; i &gt; 0; --i) &#123;
        for (j = n; j &gt; 0; --j) &#123;
            count += 1;
        &#125;
    &#125;
&#125;

var t = new Date();

setTimeout(function () &#123;
    console.log(new Date() - t);
&#125;, 1000);

heavyCompute(50000);

-- Console ------------------------------
8520
</code></pre><p>可以看到，本来应该在 1 秒后被调用的回调函数因为 JS 主线程忙于运行其它代码，实际执行时间被大幅延迟。</p><h3 id="代码设计模式"><a class="anchor" href="#代码设计模式">#</a> 代码设计模式</h3><p>异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下分别介绍一些常见的模式。</p><h4 id="函数返回值"><a class="anchor" href="#函数返回值">#</a> 函数返回值</h4><p>使用一个函数的输出作为另一个函数的输入是很常见的需求，在同步方式下一般按以下方式编写代码：</p><pre><code>var output = fn1(fn2('input'));
// Do something.
</code></pre><p>而在异步方式下，由于函数执行结果不是通过返回值，而是通过回调函数传递，因此一般按以下方式编写代码：</p><pre><code>fn2('input', function (output2) &#123;
    fn1(output2, function (output1) &#123;
        // Do something.
    &#125;);
&#125;);
</code></pre><p>可以看到，这种方式就是一个回调函数套一个回调函多，套得太多了很容易写出 <code>&gt;</code> 形状的代码。</p><h4 id="遍历数组"><a class="anchor" href="#遍历数组">#</a> 遍历数组</h4><p>在遍历数组时，使用某个函数依次对数据成员做一些处理也是常见的需求。如果函数是同步执行的，一般就会写出以下代码：</p><pre><code>var len = arr.length,
    i = 0;

for (; i &lt; len; ++i) &#123;
    arr[i] = sync(arr[i]);
&#125;

// All array items have processed.
</code></pre><p>如果函数是异步执行的，以上代码就无法保证循环结束后所有数组成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：</p><pre><code>(function next(i, len, callback) &#123;
    if (i &lt; len) &#123;
        async(arr[i], function (value) &#123;
            arr[i] = value;
            next(i + 1, len, callback);
        &#125;);
    &#125; else &#123;
        callback();
    &#125;
&#125;(0, arr.length, function () &#123;
    // All array items have processed.
&#125;));
</code></pre><p>可以看到，以上代码在异步函数执行一次并返回执行结果后才传入下一个数组成员并开始下一轮执行，直到所有数组成员处理完毕后，通过回调的方式触发后续代码的执行。</p><p>如果数组成员可以并行处理，但后续代码仍然需要所有数组成员处理完毕后才能执行的话，则异步代码会调整成以下形式：</p><pre><code>(function (i, len, count, callback) &#123;
    for (; i &lt; len; ++i) &#123;
        (function (i) &#123;
            async(arr[i], function (value) &#123;
                arr[i] = value;
                if (++count === len) &#123;
                    callback();
                &#125;
            &#125;);
        &#125;(i));
    &#125;
&#125;(0, arr.length, 0, function () &#123;
    // All array items have processed.
&#125;));
</code></pre><p>可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员，并通过计数器变量来判断什么时候所有数组成员都处理完毕了。</p><h4 id="异常处理"><a class="anchor" href="#异常处理">#</a> 异常处理</h4><p>JS 自身提供的异常捕获和处理机制 —— <code>try..catch..</code> ，只能用于同步执行的代码。以下是一个例子。</p><pre><code>function sync(fn) &#123;
    return fn();
&#125;

try &#123;
    sync(null);
    // Do something.
&#125; catch (err) &#123;
    console.log('Error: %s', err.message);
&#125;

-- Console ------------------------------
Error: object is not a function
</code></pre><p>可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个 <code>try</code> 语句时被捕获住。但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到 <code>try</code> 语句，就作为一个全局异常抛出。以下是一个例子。</p><pre><code>function async(fn, callback) &#123;
    // Code execution path breaks here.
    setTimeout(function ()　&#123;
        callback(fn());
    &#125;, 0);
&#125;

try &#123;
    async(null, function (data) &#123;
        // Do something.
    &#125;);
&#125; catch (err) &#123;
    console.log('Error: %s', err.message);
&#125;

-- Console ------------------------------
/home/user/test.js:4
        callback(fn());
                 ^
TypeError: object is not a function
    at null._onTimeout (/home/user/test.js:4:13)
    at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)
</code></pre><p>因为代码执行路径被打断了，我们就需要在异常冒泡到断点之前用 <code>try</code> 语句把异常捕获住，并通过回调函数传递被捕获的异常。于是我们可以像下边这样改造上边的例子。</p><pre><code>function async(fn, callback) &#123;
    // Code execution path breaks here.
    setTimeout(function ()　&#123;
        try &#123;
            callback(null, fn());
        &#125; catch (err) &#123;
            callback(err);
        &#125;
    &#125;, 0);
&#125;

async(null, function (err, data) &#123;
    if (err) &#123;
        console.log('Error: %s', err.message);
    &#125; else &#123;
        // Do something.
    &#125;
&#125;);

-- Console ------------------------------
Error: object is not a function
</code></pre><p>可以看到，异常再次被捕获住了。在 NodeJS 中，几乎所有异步 API 都按照以上方式设计，回调函数中第一个参数都是 <code>err</code> 。因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与 NodeJS 的设计风格保持一致。</p><p>有了异常处理方式后，我们接着可以想一想一般我们是怎么写代码的。基本上，我们的代码都是做一些事情，然后调用一个函数，然后再做一些事情，然后再调用一个函数，如此循环。如果我们写的是同步代码，只需要在代码入口点写一个 <code>try</code> 语句就能捕获所有冒泡上来的异常，示例如下。</p><pre><code>function main() &#123;
    // Do something.
    syncA();
    // Do something.
    syncB();
    // Do something.
    syncC();
&#125;

try &#123;
    main();
&#125; catch (err) &#123;
    // Deal with exception.
&#125;
</code></pre><p>但是，如果我们写的是异步代码，就只有呵呵了。由于每次异步函数调用都会打断代码执行路径，只能通过回调函数来传递异常，于是我们就需要在每个回调函数里判断是否有异常发生，于是只用三次异步函数调用，就会产生下边这种代码。</p><pre><code>function main(callback) &#123;
    // Do something.
    asyncA(function (err, data) &#123;
        if (err) &#123;
            callback(err);
        &#125; else &#123;
            // Do something
            asyncB(function (err, data) &#123;
                if (err) &#123;
                    callback(err);
                &#125; else &#123;
                    // Do something
                    asyncC(function (err, data) &#123;
                        if (err) &#123;
                            callback(err);
                        &#125; else &#123;
                            // Do something
                            callback(null);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
        &#125;
    &#125;);
&#125;

main(function (err) &#123;
    if (err) &#123;
        // Deal with exception.
    &#125;
&#125;);
</code></pre><p>可以看到，回调函数已经让代码变得复杂了，而异步方式下对异常的处理更加剧了代码的复杂度。如果 NodeJS 的最大卖点最后变成这个样子，那就没人愿意用 NodeJS 了，因此接下来会介绍 NodeJS 提供的一些解决方案。</p><h3 id="域domain"><a class="anchor" href="#域domain">#</a> 域（Domain）</h3><blockquote><p><strong>官方文档：</strong> <span class="exturl" data-url="aHR0cDovL25vZGVqcy5vcmcvYXBpL2RvbWFpbi5odG1s">http://nodejs.org/api/domain.html</span></p></blockquote><p>NodeJS 提供了 <code>domain</code> 模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解 “域” 的概念。简单的讲，一个域就是一个 JS 运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS 通过 <code>process</code> 对象提供了捕获全局异常的方法，示例代码如下</p><pre><code>process.on('uncaughtException', function (err) &#123;
    console.log('Error: %s', err.message);
&#125;);

setTimeout(function (fn) &#123;
    fn();
&#125;);

-- Console ------------------------------
Error: undefined is not a function
</code></pre><p>虽然全局异常有个地方可以捕获了，但是对于大多数异常，我们希望尽早捕获，并根据结果决定代码的执行路径。我们用以下 HTTP 服务器代码作为例子：</p><pre><code>function async(request, callback) &#123;
    // Do something.
    asyncA(request, function (err, data) &#123;
        if (err) &#123;
            callback(err);
        &#125; else &#123;
            // Do something
            asyncB(request, function (err, data) &#123;
                if (err) &#123;
                    callback(err);
                &#125; else &#123;
                    // Do something
                    asyncC(request, function (err, data) &#123;
                        if (err) &#123;
                            callback(err);
                        &#125; else &#123;
                            // Do something
                            callback(null, data);
                        &#125;
                    &#125;);
                &#125;
            &#125;);
        &#125;
    &#125;);
&#125;

http.createServer(function (request, response) &#123;
    async(request, function (err, data) &#123;
        if (err) &#123;
            response.writeHead(500);
            response.end();
        &#125; else &#123;
            response.writeHead(200);
            response.end(data);
        &#125;
    &#125;);
&#125;);
</code></pre><p>以上代码将请求对象交给异步函数处理后，再根据处理结果返回响应。这里采用了使用回调函数传递异常的方案，因此 <code>async</code> 函数内部如果再多几个异步函数调用的话，代码就变成上边这副鬼样子了。为了让代码好看点，我们可以在每处理一个请求时，使用 <code>domain</code> 模块创建一个子域（JS 子运行环境）。在子域内运行的代码可以随意抛出异常，而这些异常可以通过子域对象的 <code>error</code> 事件统一捕获。于是以上代码可以做如下改造：</p><pre><code>function async(request, callback) &#123;
    // Do something.
    asyncA(request, function (data) &#123;
        // Do something
        asyncB(request, function (data) &#123;
            // Do something
            asyncC(request, function (data) &#123;
                // Do something
                callback(data);
            &#125;);
        &#125;);
    &#125;);
&#125;

http.createServer(function (request, response) &#123;
    var d = domain.create();

    d.on('error', function () &#123;
        response.writeHead(500);
        response.end();
    &#125;);

    d.run(function () &#123;
        async(request, function (data) &#123;
            response.writeHead(200);
            response.end(data);
        &#125;);
    &#125;);
&#125;);
</code></pre><p>可以看到，我们使用 <code>.create</code> 方法创建了一个子域对象，并通过 <code>.run</code> 方法进入需要在子域中运行的代码的入口点。而位于子域中的异步函数回调函数由于不再需要捕获异常，代码一下子瘦身很多。</p><h4 id="陷阱"><a class="anchor" href="#陷阱">#</a> 陷阱</h4><p>无论是通过 <code>process</code> 对象的 <code>uncaughtException</code> 事件捕获到全局异常，还是通过子域对象的 <code>error</code> 事件捕获到了子域异常，在 NodeJS 官方文档里都强烈建议处理完异常后立即重启程序，而不是让程序继续运行。按照官方文档的说法，发生异常后的程序处于一个不确定的运行状态，如果不立即退出的话，程序可能会发生严重内存泄漏，也可能表现得很奇怪。</p><p>但这里需要澄清一些事实。JS 本身的 <code>throw..try..catch</code> 异常处理机制并不会导致内存泄漏，也不会让程序的执行结果出乎意料，但 NodeJS 并不是存粹的 JS。NodeJS 里大量的 API 内部是用 C/C<ins> 实现的，因此 NodeJS 程序的运行过程中，代码执行路径穿梭于 JS 引擎内部和外部，而 JS 的异常抛出机制可能会打断正常的代码执行流程，导致 C/C</ins> 部分的代码表现异常，进而导致内存泄漏等问题。</p><p>因此，使用 <code>uncaughtException</code> 或 <code>domain</code> 捕获异常，代码执行路径里涉及到了 C/C++ 部分的代码时，如果不能确定是否会导致内存泄漏等问题，最好在处理完异常后重启程序比较妥当。而使用 <code>try</code> 语句捕获异常时一般捕获到的都是 JS 本身的异常，不用担心上诉问题。</p><h3 id="小结"><a class="anchor" href="#小结">#</a> 小结</h3><p>本章介绍了 JS 异步编程相关的知识，总结起来有以下几点：</p><ul><li>不掌握异步编程就不算学会 NodeJS。</li><li>异步编程依托于回调来实现，而使用回调不一定就是异步编程。</li><li>异步编程下的函数间数据传递、数组遍历和异常处理与同步编程有很大差别。</li><li>使用 <code>domain</code> 模块简化异步代码的异常处理，并小心陷阱。</li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-03-22 23:28:35" itemprop="dateModified" datetime="2022-03-22T23:28:35+08:00">2022-03-22</time> </span><span id="computer-science/web/node/异步编程/" class="item leancloud_visitors" data-flag-title="" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>EntropyWhite <i class="ic i-at"><em>@</em></i>熵白之痕</li><li class="link"><strong>本文链接：</strong> <a href="https://entropywhite.com/computer-science/web/node/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/">https://entropywhite.com/computer-science/web/node/异步编程/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/computer-science/web/node/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevarprfj20zk0m8npd.jpg" title="未命名"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div><div class="item right"><a href="/computer-science/web/node/Untitled/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclx6phq6j20zk0m8e36.jpg" title="未命名"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>未命名</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83"><span class="toc-number">1.</span> <span class="toc-text">回调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">代码设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">2.1.</span> <span class="toc-text">函数返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">遍历数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%9Fdomain"><span class="toc-number">3.</span> <span class="toc-text">域（Domain）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%B7%E9%98%B1"><span class="toc-number">3.1.</span> <span class="toc-text">陷阱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">小结</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="EntropyWhite" data-src="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/images/cat.jpg"><p class="name" itemprop="name">EntropyWhite</p><div class="description" itemprop="description">欢迎来到熵白的博客</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">129</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">10</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL0plcnlzdXJw" title="https:&#x2F;&#x2F;github.com&#x2F;Jerysurp"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span> <span class="exturl item bilibili" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vNTEzMTAwNDY/c3BtX2lkX2Zyb209MzMzLjEwMDcuMC4w" title="https:&#x2F;&#x2F;space.bilibili.com&#x2F;51310046?spm_id_from&#x3D;333.1007.0.0"><i class="ic i-bilibili"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li><li class="item"><a href="/links/" rel="section"><i class="ic i-magic"></i>链接</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/computer-science/web/node/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/computer-science/web/node/Untitled/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E5%8A%9F%E8%83%BD/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/css/css%E9%A2%84%E5%A4%84%E7%90%86/scss-master/docs/README/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/SVN/SVN%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/%E5%89%8D%E7%AB%AF%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/HTMLCSS%E6%96%87%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/computer-science/web/JavaScript/ES6/JS-Promise%E5%AF%B9%E8%B1%A1/" title="JS-Promise对象">JS-Promise对象</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/html/" title="分类于 html">html</a></div><span><a href="/computer-science/web/html/HTML%20WebApp%20Meta/" title="WebApp Meta">WebApp Meta</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/JavaScript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/computer-science/web/JavaScript/ES6/async%E5%87%BD%E6%95%B0/" title="async函数">async函数</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/html/" title="分类于 html">html</a></div><span><a href="/computer-science/web/html/HTML%E6%B3%A8%E9%87%8A%E8%A7%84%E8%8C%83/" title="html注释规范">html注释规范</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/computer-science/web/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/OWASP%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9%E7%9F%A5%E8%AF%86/" title="未命名">未命名</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/" title="分类于 web">web</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/web/css/" title="分类于 css">css</a></div><span><a href="/computer-science/web/css/CSS%E8%A7%84%E8%8C%83/CSS%E9%87%8D%E7%BD%AE%E6%A0%B7%E5%BC%8F/" title="CSS重置样式">CSS重置样式</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">EntropyWhite @ Entropy White</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">304k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">4:37</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"computer-science/web/node/异步编程/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="//cdn.jsdelivr.net/gh/Jerysurp/Jerysurp.github.io@latest/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->