{
    "version": "https://jsonfeed.org/version/1",
    "title": "熵白之痕",
    "subtitle": "以前进为目标吧",
    "icon": "https://entropywhite.com/images/favicon.ico",
    "description": "欢迎来到熵白的博客",
    "home_page_url": "https://entropywhite.com",
    "items": [
        {
            "id": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%BD%95%E7%99%BE%E5%BA%A6%E7%AB%99%E7%82%B9/",
            "url": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%BD%95%E7%99%BE%E5%BA%A6%E7%AB%99%E7%82%B9/",
            "title": "博客文件解析",
            "date_published": "2022-06-26T14:42:18.461Z",
            "content_html": "<h1 id=\"博客收录百度站点\"><a class=\"anchor\" href=\"#博客收录百度站点\">#</a> 博客收录百度站点</h1>\n<p>首先点击这个链接</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tLw==\">百度搜索资源平台_共创共享鲜活搜索 (baidu.com)</span></p>\n<p>进入后注册或登录（有号的话）百度账号</p>\n<p>登录成功后鼠标移到<strong>用户中心</strong>，点击出现的<strong>站点管理</strong></p>\n<p><img data-src=\"%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/40.png\" alt></p>\n<p>进入页面后，点击<strong>添加网站</strong></p>\n<p>一、输入网站，选择 http 或 https（看你博客有没有套 SSL 证书），输入博客域名地址，点击下一步</p>\n<p>二、设置站点领域为<strong>信息技术</strong>（也可以按自己所需选择），点击下一步</p>\n<p>三、验证网站（重点），有三种验证方式</p>\n<p>1. 文件验证（没成功）</p>\n<p>下方会提示下载一个验证文件，下载完后放到博客的根目录下，所谓的根目录其实是你博客的根目录下的 Source 文件夹里，放进去后重新使用 git bash 输入 hexo g -d 部署到网上，完成后点击最下方的完成验证</p>\n<p><img data-src=\"%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/41.png\" alt></p>\n<p>这个我试过是没成功的，我看网上的是这样做的</p>\n<p>2.HTML 标签验证（没成功）</p>\n<p>下方会提示将一段代码放到网站的首页的 head 标签里头，据我所找的网上说是放在 themes/shoka/layout/_partials 文件夹内的某个文件里头</p>\n<p>至于是哪个我就不清楚了，因为我找到不是和我们一个主题的，如果有成功的小伙伴请放上截图评论</p>\n<p>3.CNAME 验证（成功）</p>\n<p><img data-src=\"%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/42.png\" alt></p>\n<p>首先，登录你购买域名的服务商，进入 dns 解析页面</p>\n<p>点进你的域名，点击添加记录，主机记录输入它给你的一串记录（如上方的 code-……，点后面的是你需要绑定的域名，不要放进主机记录），记录类型选择 CNAME，记录值就输入它让你解析的地址，完成后点确认</p>\n<p>回到百度验证页面，点完成验证即可成功验证</p>\n<p><img data-src=\"%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/39.png\" alt></p>\n",
            "tags": [
                "计算机科学",
                "hexo博客",
                "Theme Shoka Documentation",
                "Hexo",
                "教程"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/html/Canvas%E5%92%8CSVG/",
            "url": "https://entropywhite.com/computer-science/web/html/Canvas%E5%92%8CSVG/",
            "title": "",
            "date_published": "2022-06-21T11:58:16.552Z",
            "content_html": "<h1 id=\"html5-canvas\"><a class=\"anchor\" href=\"#html5-canvas\">#</a> HTML5 Canvas</h1>\n<hr>\n<p>canvas 标签定义图形，比如图表和其他图像，必须使用脚本来绘制图形</p>\n<h2 id=\"创建一个画布canvas\"><a class=\"anchor\" href=\"#创建一个画布canvas\">#</a> 创建一个画布（Canvas）</h2>\n<p>一个画布在网页中是一个矩形框，通过 &lt;canvas&gt; 元素来绘制</p>\n<p>默认情况下 &lt;canvas&gt; 元素没有边框和内容。</p>\n<p>&lt;canvas&gt; 简单实例如下:</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\">&lt;/canvas></pre></td></tr></table></figure><p>标签通常需要指定一个 id 属性 (脚本中经常引用), width 和 height 属性定义的画布的大小</p>\n<h2 id=\"使用-javascript-来绘制图像\"><a class=\"anchor\" href=\"#使用-javascript-来绘制图像\">#</a> 使用 JavaScript 来绘制图像</h2>\n<p>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\" style=\"border:1px solid #c3c3c3;\"></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>您的浏览器不支持 HTML5 canvas 标签</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>&lt;/canvas></pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>&lt;script></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>var c=document.getElementById(\"myCanvas\"); //找到元素</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>var ctx=c.getContext(\"2d\"); //创建对象 getContext(\"2d\") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>ctx.fillStyle=\"#FF0000\"; //绘制边框</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>ctx.fillRect(0,0,150,75); //fillRect(x,y,width,height) 方法定义了矩形当前的填充方式</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>&lt;/script></pre></td></tr></table></figure><h2 id=\"canvas-坐标\"><a class=\"anchor\" href=\"#canvas-坐标\">#</a> Canvas 坐标</h2>\n<p>canvas 是一个二维网格</p>\n<p>canvas 的左上角坐标为 (0,0)</p>\n<p>上面的 fillRect 方法拥有参数 (0,0,150,75)</p>\n<p>意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)</p>\n<h2 id=\"canvas-路径\"><a class=\"anchor\" href=\"#canvas-路径\">#</a> Canvas - 路径</h2>\n<p>在 Canvas 上画线，我们将使用以下两种方法：</p>\n<ul>\n<li>moveTo(<em>x,y</em>) 定义线条开始坐标</li>\n<li>lineTo(<em>x,y</em>) 定义线条结束坐标</li>\n</ul>\n<p>绘制线条我们必须使用到 &quot;ink&quot; 的方法，就像 stroke ()</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>&lt;canvas id=\"myCanvas\" width=\"200\" height=\"100\" style=\"border:1px solid #d3d3d3;\"></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>您的浏览器不支持 HTML5 canvas 标签&lt;/canvas></pre></td></tr><tr><td data-num=\"3\"></td><td><pre></pre></td></tr><tr><td data-num=\"4\"></td><td><pre>&lt;script></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>var c=document.getElementById(\"myCanvas\");</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>var ctx=c.getContext(\"2d\");</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>ctx.moveTo(0,0);</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>ctx.lineTo(200,100);</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>ctx.stroke();</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>&lt;/script></pre></td></tr></table></figure><p>在 canvas 中绘制圆形，我们将使用以下方法:</p>\n<pre><code>arc(x,y,r,start,stop)\n</code></pre>\n<p>实际上我们在绘制圆形时使用了 &quot;ink&quot; 的方法，比如 stroke () 或者 fill ()</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>var c=document.getElementById(\"myCanvas\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>var ctx=c.getContext(\"2d\");</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>ctx.beginPath();</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>ctx.arc(95,50,40,0,2*Math.PI);</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>ctx.stroke();</pre></td></tr></table></figure><h2 id=\"canvas-文本\"><a class=\"anchor\" href=\"#canvas-文本\">#</a> Canvas - 文本</h2>\n<p>使用 canvas 绘制文本，重要的属性和方法如下：</p>\n<ul>\n<li>font - 定义字体</li>\n<li>fillText(<em>text,x,y</em>) - 在 canvas 上绘制实心的文本</li>\n</ul>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>var c=document.getElementById(\"myCanvas\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>var ctx=c.getContext(\"2d\");</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>ctx.font=\"30px Arial\";</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>ctx.fillText(\"Hello World\",10,50);</pre></td></tr></table></figure><ul>\n<li>strokeText(<em>text,x,y</em>) - 在 canvas 上绘制空心的文本</li>\n</ul>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>var c=document.getElementById(\"myCanvas\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>var ctx=c.getContext(\"2d\");</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>ctx.font=\"30px Arial\";</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>ctx.strokeText(\"Hello World\",10,50);</pre></td></tr></table></figure><h2 id=\"canvas-渐变\"><a class=\"anchor\" href=\"#canvas-渐变\">#</a> Canvas - 渐变</h2>\n<p>渐变可以填充在矩形，圆形，线条，文本等等，各种形状可以自己定义不同的颜色</p>\n<p>以下有两种不同的方式来设置 Canvas 渐变：</p>\n<ul>\n<li>createLinearGradient(<em>x,y,x1,y1</em>) - 创建线条渐变</li>\n</ul>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>var c=document.getElementById(\"myCanvas\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>var ctx=c.getContext(\"2d\");</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>// 创建渐变</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>var grd=ctx.createLinearGradient(0,0,200,0);</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>grd.addColorStop(0,\"red\");</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>grd.addColorStop(1,\"white\");</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>// 填充渐变</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>ctx.fillStyle=grd;</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>ctx.fillRect(10,10,150,80);</pre></td></tr></table></figure><ul>\n<li>createRadialGradient(<em>x,y,r,x1,y1,r1</em>) - 创建一个径向 / 圆渐变</li>\n</ul>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>var c=document.getElementById(\"myCanvas\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>var ctx=c.getContext(\"2d\");</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>// 创建渐变</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>var grd=ctx.createRadialGradient(75,50,5,90,60,100);</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>grd.addColorStop(0,\"red\");</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>grd.addColorStop(1,\"white\");</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>// 填充渐变</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>ctx.fillStyle=grd;</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>ctx.fillRect(10,10,150,80);</pre></td></tr></table></figure><p>当我们使用渐变对象，必须使用两种或两种以上的停止颜色</p>\n<p>addColorStop () 方法指定颜色停止，参数使用坐标来描述，可以是 0 至 1</p>\n<p>使用渐变，设置 fillStyle 或 strokeStyle 的值为 渐变，然后绘制形状，如矩形，文本，或一条线</p>\n<h2 id=\"canvas-图像\"><a class=\"anchor\" href=\"#canvas-图像\">#</a> Canvas - 图像</h2>\n<p>把一幅图像放置到画布上，使用以下方法:</p>\n<ul>\n<li>drawImage(<em>image,x,y</em>)</li>\n</ul>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>var c=document.getElementById(\"myCanvas\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>var ctx=c.getContext(\"2d\");</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>var img=document.getElementById(\"scream\");</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>ctx.drawImage(img,10,10);</pre></td></tr></table></figure><h1 id=\"什么是svg\"><a class=\"anchor\" href=\"#什么是svg\">#</a> 什么是 SVG？</h1>\n<ul>\n<li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li>\n<li>SVG 用于定义用于网络的基于矢量的图形</li>\n<li>SVG 使用 XML 格式定义图形</li>\n<li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失</li>\n<li>SVG 是万维网联盟的标准</li>\n</ul>\n<h2 id=\"html5-svg\"><a class=\"anchor\" href=\"#html5-svg\">#</a> HTML5 SVG</h2>\n<p>HTML5 支持内联 SVG</p>\n<p>HTML <strong>&lt;svg&gt;</strong> 元素是 SVG 图形的容器</p>\n<p>SVG 有多种绘制路径、框、圆、文本和图形图像的方法</p>\n<h2 id=\"svg优势\"><a class=\"anchor\" href=\"#svg优势\">#</a> SVG 优势</h2>\n<p>与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：</p>\n<ul>\n<li>SVG 图像可通过文本编辑器来创建和修改</li>\n<li>SVG 图像可被搜索、索引、脚本化或压缩</li>\n<li>SVG 是可伸缩的</li>\n<li>SVG 图像可在任何的分辨率下被高质量地打印</li>\n<li>SVG 可在图像质量不下降的情况下被放大</li>\n</ul>\n<h2 id=\"svg圆形\"><a class=\"anchor\" href=\"#svg圆形\">#</a> SVG 圆形</h2>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>&lt;svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\"></pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   &lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"2\" fill=\"red\" /></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>&lt;/svg></pre></td></tr></table></figure><h2 id=\"svg-与-canvas两者间的区别\"><a class=\"anchor\" href=\"#svg-与-canvas两者间的区别\">#</a> SVG 与 Canvas 两者间的区别</h2>\n<p>SVG 是一种使用 XML 描述 2D 图形的语言</p>\n<p>Canvas 通过 JavaScript 来绘制 2D 图形</p>\n<p>SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器</p>\n<p>在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形</p>\n<p>Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象</p>\n<h2 id=\"canvas-与-svg-的比较\"><a class=\"anchor\" href=\"#canvas-与-svg-的比较\">#</a> Canvas 与 SVG 的比较</h2>\n<p>下表列出了 canvas 与 SVG 之间的一些不同之处</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Canvas</th>\n<th style=\"text-align:left\">SVG</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">依赖分辨率不支持事件处理器弱的文本渲染能力能够以 .png 或 .jpg 格式保存结果图像最适合图像密集型的游戏，其中的许多对象会被频繁重绘</td>\n<td style=\"text-align:left\">不依赖分辨率支持事件处理器最适合带有大型渲染区域的应用程序（比如谷歌地图）复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）不适合游戏应用</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/blog/%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81/",
            "url": "https://entropywhite.com/computer-science/blog/%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81/",
            "title": "一些关于本博客问题",
            "date_published": "2022-06-10T01:17:00.000Z",
            "content_html": "<h1 id=\"关于本博客\"><a class=\"anchor\" href=\"#关于本博客\">#</a> 关于本博客</h1>\n<p>博客将更新一些不限于前端的知识，比如其他编程知识、游戏分享等</p>\n<p>基于 shoka 的主题进行自定义</p>\n<h1 id=\"访问博客食用方法\"><a class=\"anchor\" href=\"#访问博客食用方法\">#</a> 访问博客食用方法</h1>\n<h2 id=\"如果你发现刚刚还存在的博客突然变成github404无非几种情况\"><a class=\"anchor\" href=\"#如果你发现刚刚还存在的博客突然变成github404无非几种情况\">#</a> 如果你发现刚刚还存在的博客，突然变成 github404，无非几种情况</h2>\n<p>一是 github 服务器炸了（不太可能）</p>\n<p>二是我在更新博客（会存在一段时间 404，请至少过 5 分钟在访问）</p>\n<h2 id=\"博客加载缓慢\"><a class=\"anchor\" href=\"#博客加载缓慢\">#</a> 博客加载缓慢</h2>\n<p>在进入博客前有个加载页面，如果你在加载页面停留过久（1 分钟以上），可以尝试翻墙再访问看看如何（因为使用了 github 作服务器，有外网的因素）</p>\n",
            "tags": [
                "计算机科学",
                "hexo博客",
                "Theme Shoka Documentation",
                "Hexo"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98/",
            "url": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98/",
            "title": "博客问题",
            "date_published": "2022-06-10T00:48:00.000Z",
            "content_html": "<h2 id=\"bug1未解决\"><a class=\"anchor\" href=\"#bug1未解决\">#</a> bug1 (未解决)</h2>\n<p>在运行 hexo s 查看博客时出现报错</p>\n<p><img data-src=\"../../../../img/20.JPG\" alt></p>\n<p>只要在 hexo 中使用到 hexo-renderer-stylus，就会出现上面的警告，不去管他也能正常使用，但是看起来不舒服。</p>\n<p>提供两种修复办法</p>\n<p>一：将 node 从 14 降级到 12，警告消失，但是这样容易引起其他依赖问题</p>\n<p>二：Hexo 这里的 warning 是由于<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy9naXRodWIuY29tL3N0eWx1cy9zdHlsdXM=\"> stylus</span> 导致的，幸运的是 stylus 在 0.54.8 版本修复了这个问题，所以对于 Hexo 用户来说，重新装一下 <code>hexo-renderer-stylus</code> ，就可正常使用。</p>\n<p>但重装之后发现还是会报警告，继续追溯源头，发现是这其实是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy93d3cubnBtanMuY29tL3BhY2thZ2Uvbmli\"> ni</span>b 这个包里的 stylus 引起的问题，而这个包已经很久没更新了。</p>\n<p>2.1 将 hexo-renderer-stylus 更新到 2.0.1</p>\n<p>2.2 <strong>将 stylus 从 0.54.5 更新到 0.54.8</strong></p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>\"resolutions\": &#123;</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    \"stylus\": \"^0.54.8\"</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>  &#125;</pre></td></tr></table></figure><p>如果还是有警告，可以 cd node_module/nib，强行把它的 stylus 升级到 0.54.8（不推荐这么做）</p>\n<h2 id=\"bug2已解决\"><a class=\"anchor\" href=\"#bug2已解决\">#</a> bug2 (已解决)</h2>\n<p>在运行 hexo s 查看博客时出现如下报错</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ERROR &#123;</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  err: Error: Cannot find module 'pangu'</pre></td></tr></table></figure><p>下载 pangu 插件即可</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>npm install remark-pangu</pre></td></tr></table></figure><h2 id=\"bug3已解决\"><a class=\"anchor\" href=\"#bug3已解决\">#</a> bug3 (已解决)</h2>\n<p>在安装插件时发生报错</p>\n<p><img data-src=\"../../../../img/21.JPG\" alt></p>\n<p>将 npm 版本升级至最高即可</p>\n<h2 id=\"bug4已解决\"><a class=\"anchor\" href=\"#bug4已解决\">#</a> bug4 (已解决)</h2>\n<p>访问自己博客主页 (<span class=\"exturl\" data-url=\"aHR0cDovL3huLS01bXE0MGs1dWsuZ2l0aHViLmlv\">http:// 仓库名.github.io</span>) 时出现 404 画面</p>\n<p><img data-src=\"../../../../img/22.JPG\" alt></p>\n<p>在仓库页面，点击 Settings，一路拉到最下，看见 Change visibility，点击后出现以下页面</p>\n<p>原因是你的仓库没有公开，创建仓库时设置了私有</p>\n<p><img data-src=\"../../../../img/23.JPG\" alt></p>\n<p>Make public: 公开仓库、Make private: 私有仓库</p>\n<p>我们的博客仓库必须公开，不公开就会出现 404 页面。点击 Make public，输入黑体加粗 (Jerysurp/Jerysurp.github.io)，点红色字体即可，稍作等待后就会出现博客页面</p>\n<h2 id=\"bug5已解决\"><a class=\"anchor\" href=\"#bug5已解决\">#</a> bug5 (已解决)</h2>\n<p>上传到 github 时报错</p>\n<p><img data-src=\"../../../../img/38.png\" alt></p>\n<p>删除博客根目录下的 **.deploy_git** 文件</p>\n<p>使用 git bash 输入</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>git config --global core.autocrlf false</pre></td></tr></table></figure><p>将 git 加入到系统环境变量</p>\n<p>重新进行 hexo c d g</p>\n",
            "tags": [
                "计算机科学",
                "hexo博客",
                "Theme Shoka Documentation",
                "Hexo",
                "教程"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/",
            "url": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/",
            "title": "博客文件解析",
            "date_published": "2022-06-10T00:47:00.000Z",
            "content_html": "<p>hexo 博客</p>\n<p><img data-src=\"../../../../img/24.JPG\" alt></p>\n<p>node_modules：下载的插件 (依赖) 都在这</p>\n<p>public：静态页面</p>\n<p>source：写好的文章放里面</p>\n<p>themes：存放主题</p>\n<p>_config.yml：全局配置文件</p>\n<p>package.json：依赖包描述文件</p>\n<p>主题文件</p>\n<p><img data-src=\"../../../../img/30.JPG\" alt></p>\n<p>example：给你参考的模板</p>\n<p>languages：语言文件</p>\n<p>source：静态文件</p>\n<p>_config.yml：主题配置文件</p>\n<p>_images.yml：图像配置文件</p>\n<p>package.json：依赖包描述文件</p>\n",
            "tags": [
                "计算机科学",
                "hexo博客",
                "Theme Shoka Documentation",
                "Hexo",
                "教程"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/",
            "url": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/",
            "title": "博客主题",
            "date_published": "2022-06-10T00:46:00.000Z",
            "content_html": "<h1 id=\"第二章美化博客\"><a class=\"anchor\" href=\"#第二章美化博客\">#</a> 第二章：美化博客</h1>\n<h2 id=\"下载主题\"><a class=\"anchor\" href=\"#下载主题\">#</a> 下载主题</h2>\n<p>在下载主题前，需要前往<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=\"> Themes | Hexo</span>hexo 官网主题页面寻找自己喜欢的主题，这里以 shoka 举例，其他主题请自行查看其他攻略食用</p>\n<p>前往 github 下载 shoka 主题</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>https://github.com/amehime/hexo-theme-shoka</pre></td></tr></table></figure><p>或者用 git bash 下载 (这个我没成功)</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka</pre></td></tr></table></figure><p>下载好的主题放到博客根目录下的 themes 里</p>\n<h2 id=\"2下载依赖\"><a class=\"anchor\" href=\"#2下载依赖\">#</a> 2. 下载依赖</h2>\n<p>使用主题前先要安装一些主题依赖的插件，没有安装以下插件的话，主题会报错</p>\n<p>在博客根目录下打开 git bash，输入下列命令</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>npm un hexo-renderer-marked --save \"删除默认的渲染器\"</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>npm i hexo-renderer-multi-markdown-it --save \"md文件渲染器，压缩css/js/html\"</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>npm i hexo-autoprefixer --save \"给生成的css文件添加浏览器前缀\"</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>npm i hexo-algoliasearch --save \"站内搜索功能\"</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>npm i hexo-symbols-count-time --save \"文章或站点子数及阅读时间统计\"</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>npm i hexo-feed --save \"生成feed文件\"</pre></td></tr></table></figure><h3 id=\"配置\"><a class=\"anchor\" href=\"#配置\">#</a> 配置</h3>\n<p>打开全局配置文件，在 deploy 下面加入配置</p>\n<p>autoprefixer 配置</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>autoprefixer:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>\texclude:</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>\t\t- '*.min.css'</pre></td></tr></table></figure><p>markdown 配置</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>markdown:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  render: # 渲染器设置</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    html: false # 过滤 HTML 标签</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    xhtmlOut: true # 使用 '/' 来闭合单标签 （比如 &lt;br />）。</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    breaks: true # 转换段落里的 '\\n' 到 &lt;br>。</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    linkify: true # 将类似 URL 的文本自动转换为链接。</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    typographer:</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    quotes: '“”‘’'</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>  plugins: # markdown-it插件设置</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    - plugin:</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        name: markdown-it-toc-and-anchor</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        enable: true</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        options: # 文章目录以及锚点应用的class名称，shoka主题必须设置成这样</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>          tocClassName: 'toc'</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>          anchorClassName: 'anchor'</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    - plugin:</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        name: markdown-it-multimd-table</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        enable: true</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>        options:</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>          multiline: true</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>          rowspan: true</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>          headerless: true</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>    - plugin:</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>        name: ./markdown-it-furigana</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>        enable: true</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>        options:</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>          fallbackParens: \"()\"</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>    - plugin:</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>        name: ./markdown-it-spoiler</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>        enable: true</pre></td></tr><tr><td data-num=\"31\"></td><td><pre>        options:</pre></td></tr><tr><td data-num=\"32\"></td><td><pre>          title: \"你知道得太多了\"</pre></td></tr></table></figure><p>加入 minify 配置，压缩 html/css/js</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>minify:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>  html:</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    enable: true</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    exclude: #排除hexo-feed用到的模板</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>      - '**/json.ejs'</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>      - '**/atom.ejs'</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>      - '**/rss.ejs'</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>  css:</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>    enable: true</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    exclude:</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>      - '**/*.min.css'</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>  js:</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>    enable: true</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    mangle:</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>      toplevel: true</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>    output:</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>    compress:</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>    exclude:</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>      - '**/*.min.js'</pre></td></tr></table></figure><p>停用默认代码高亮功能，否则代码块的 mac 样式不能显示</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>highlight:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   enable: false</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>prismjs:</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   enable: false</pre></td></tr></table></figure><p>algolia 配置</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>algolia:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>   appId: #your appid</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>   apiKey: #your apikey</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>   adminApiKey: #your adminapikey</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>   chunkSize: 5000</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   indexName:</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   fields:</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>     - title #必须配置</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>     - path #必须配置</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>     - categories #推荐配置</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>     - content:strip:truncate,0,4000</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>     - gallery</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>     - photos</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>     - tags</pre></td></tr></table></figure><p>feed 配置</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>feed:</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>    limit: 20</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>    order_by: \"-date\"</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    tag_dir: false</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    category_dir: false</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    rss:</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>        enable: true</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>        template: \"themes/shoka/layout/_alternate/rss.ejs\"</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        output: \"rss.xml\"</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    atom:</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        enable: true</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        template: \"themes/shoka/layout/_alternate/atom.ejs\"</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        output: \"atom.xml\"</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>    jsonFeed:</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        enable: true</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        template: \"themes/shoka/layout/_alternate/json.ejs\"</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        output: \"feed.json\"</pre></td></tr></table></figure>",
            "tags": [
                "计算机科学",
                "hexo博客",
                "Theme Shoka Documentation",
                "Hexo",
                "教程"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/",
            "url": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/",
            "title": "安装hexo和部署到github",
            "date_published": "2022-06-10T00:45:00.000Z",
            "content_html": "<h1 id=\"安装hexo和部署到github\"><a class=\"anchor\" href=\"#安装hexo和部署到github\">#</a> 安装 hexo 和部署到 github</h1>\n<h2 id=\"下载nodejs\"><a class=\"anchor\" href=\"#下载nodejs\">#</a> 下载 NodeJs</h2>\n<p>下载 NodeJs 地址: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkLw==\">Download | Node.js (nodejs.org)</span></p>\n<p><img data-src=\"../../../../img/1.JPG\" alt></p>\n<p>默认点击 windows installer 即可</p>\n<p>安装时一路 next 即可，不用安装其他，但安装地址如需要可以更改 (一般不放 C 盘)</p>\n<h2 id=\"下载git\"><a class=\"anchor\" href=\"#下载git\">#</a> 下载 git</h2>\n<p>下载 git 地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9ucG0udGFvYmFvLm9yZy9taXJyb3JzL2dpdC1mb3Itd2luZG93cy92Mi4yMi4wLndpbmRvd3MuMS9HaXQtMi4yMi4wLTY0LWJpdC5leGU=\">https://npm.taobao.org/mirrors/git-for-windows/v2.22.0.windows.1/Git-2.22.0-64-bit.exe</span></p>\n<p>下载后会有一个 git bash 命令行工具</p>\n<h3 id=\"检查nodejs-npm和git版本及安装\"><a class=\"anchor\" href=\"#检查nodejs-npm和git版本及安装\">#</a> 检查 NodeJs、npm 和 git 版本及安装</h3>\n<p>打开 cmd 执行以下命令</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>node -v</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>npm -v</pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>git --version</pre></td></tr></table></figure><p><img data-src=\"../../../../img/2.JPG\" alt></p>\n<p>出现版本号即为安装成功</p>\n<h2 id=\"nodejs环境变量配置\"><a class=\"anchor\" href=\"#nodejs环境变量配置\">#</a> NodeJs 环境变量配置</h2>\n<h3 id=\"修改模块安装和缓存路径\"><a class=\"anchor\" href=\"#修改模块安装和缓存路径\">#</a> 修改模块安装和缓存路径</h3>\n<p>在你安装 nodejs 的目录下新建一个名字为 node_cache 的文件夹</p>\n<p><img data-src=\"../../../../img/3.JPG\" alt></p>\n<p>打开 cmd，使用命令修改模块安装路径，“” 里为自己的 nodejs 的路径</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>npm config set prefix \"\"</pre></td></tr></table></figure><p>使用命令修改缓存路径，“” 里为自己的 node_cache 文件夹的路径</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>npm config set cache \"\"</pre></td></tr></table></figure><p>最后使用命令检查是否配置成功</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>npm config get prefix</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>npm config get cache</pre></td></tr></table></figure><p><img data-src=\"../../../../img/4.JPG\" alt></p>\n<h3 id=\"配置环境变量\"><a class=\"anchor\" href=\"#配置环境变量\">#</a> 配置环境变量</h3>\n<p>点击 &quot;我的电脑&quot; 右键 — 属性 — 高级系统设置 — 环境变量 — 用户变量 — 编辑 — 将 nodejs 默认配置路径删除 (有就删，没有可以不管)</p>\n<p><img data-src=\"../../../../img/5.png\" alt></p>\n<p>点下方的系统变量的新建，填入图片里的信息</p>\n<p><img data-src=\"../../../../img/6.JPG\" alt></p>\n<p>打开 cmd，输入命令 &quot;node&quot;，回车，输入 require ('cluster')，出现配置说明成功</p>\n<p><img data-src=\"../../../../img/7.JPG\" alt></p>\n<p>在装有 install.sh 脚本的目录下右键打开 git，输入</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>source install.sh test_node</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>source install.sh test_git</pre></td></tr></table></figure><p>出现版本号和成功提示 环境变量配置成功</p>\n<p><img data-src=\"../../../../img/8.JPG\" alt></p>\n<p>创建 github</p>\n<h2 id=\"安装hexo\"><a class=\"anchor\" href=\"#安装hexo\">#</a> 安装 Hexo</h2>\n<p>在你想放置博客的文件夹下右键打开 git bash 执行下列命令</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>curl -O https://cdn.jsdelivr.net/gh/kjhuanhao/hexo-script@master/install.sh</pre></td></tr></table></figure><p><span class=\"exturl\" data-url=\"aHR0cDovL3huLS1pbnN0YWxsLTR0M2tmZHJvMTRnOXhhazU3Ym0ya3NxcWtrb3k0NmdzdGJsODduajQ4Yi5zaA==\">会在你右键的目录下安装一个 install.sh</span></p>\n<p><img data-src=\"../../../../img/9.JPG\" alt></p>\n<p>在装有 install.sh 的目录下，打开 git bash 执行下列命令</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>source install.sh hexo_win</pre></td></tr></table></figure><p><img data-src=\"../../../../img/10.JPG\" alt></p>\n<p>中间红色的错误是验证你的 github，如果弹出则输入你的 github 的账号密码，如果没有弹出也可以不管，出现最后一句话后，在你的博客目录下会出现一个 hexoblog 文件夹；</p>\n<p>进入博客目录下，打开 git bash，输入下列命令</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>hexo g</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>hexo s</pre></td></tr></table></figure><p>打开浏览器输入</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>http://localhost:4000</pre></td></tr></table></figure><p>即可查看自己的初始博客</p>\n<p><img data-src=\"../../../../img/11.JPG\" alt></p>\n<h2 id=\"创建github仓库\"><a class=\"anchor\" href=\"#创建github仓库\">#</a> 创建 github 仓库</h2>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>https://github.com/</pre></td></tr></table></figure><p>先要注册一个 GitHub 账户</p>\n<p>注册完登录后，在 GitHub.com 中看到一个 New repository，点击 new 新建仓库</p>\n<p><img data-src=\"../../../../img/12.JPG\" alt></p>\n<p>输入 Repository name，<span class=\"exturl\" data-url=\"aHR0cDovL3huLS1naXRodWItdnk3aXUwdTk4ZmY3dWxuang3NWJqbDJjbjM5YTRnYS5naXRodWIuaW8=\">建议设置为注册 github 名字.github.io</span></p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>Jerysury.github.io</pre></td></tr></table></figure><p>勾选 Add a README file 自述文件（后续有用），待 Create repository 绿色框亮起则点击创建仓库</p>\n<p><img data-src=\"../../../../img/13.JPG\" alt></p>\n<h2 id=\"获取ssh密钥\"><a class=\"anchor\" href=\"#获取ssh密钥\">#</a> 获取 SSH 密钥</h2>\n<p>打开 git bash，输入下列命令</p>\n<pre><code>git config --global user.name &quot;yourname&quot;\ngit config --global user.email &quot;youremail&quot;\n</code></pre>\n<p>yourname 输入你的 github 用户名</p>\n<p>youremail 输入你的 github 注册时的邮箱</p>\n<p>输入下列命令查看输入是否正确</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>git config --global --list</pre></td></tr></table></figure><p>确保无误后，输入下列命令获取 ssh 密钥</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>ssh-keygen -t rsa -C \"youremail\"</pre></td></tr></table></figure><p>出现第一个选项时输入 y，剩余一直空格即可</p>\n<p><img data-src=\"../../../../img/14.JPG\" alt></p>\n<p>创建成功后在 C:/ 用户 / 用户名 /.ssh 中找到密钥，带有 pub 后缀的是公钥，没带有 pub 后缀的是私钥，右键用记事本方式打开 id_rsa.pub 文件，复制里面的公钥</p>\n<p><img data-src=\"../../../../img/15.JPG\" alt></p>\n<p>回到 github，点击右上角头像，点击 Settings</p>\n<p><img data-src=\"../../../../img/16.JPG\" alt></p>\n<p>点击 Access 下方的 SSH and GPK keys，点击 New SSH key</p>\n<p><img data-src=\"../../../../img/17.JPG\" alt></p>\n<p>title 输入密钥名，key 里粘贴上一步中所复制的公钥，点击 Add SSH key 添加密钥，即可添加成功</p>\n<p><img data-src=\"../../../../img/18.JPG\" alt></p>\n<p>输入下列命令测试是否连通 github</p>\n<p><img data-src=\"../../../../img/19.JPG\" alt></p>\n<p>我这里不知道为什么 ip 去到了美国微软哪里，搜了很多办法也没修好，不过网址也能正常运作，我就暂时不管了</p>\n<p>这是成功界面</p>\n<p><img data-src=\"../../../../img/37.png\" alt></p>\n<h2 id=\"部署博客\"><a class=\"anchor\" href=\"#部署博客\">#</a> 部署博客</h2>\n<p>在你的博客根目录下打开_config.yml</p>\n<p><img data-src=\"../../../../img/25.JPG\" alt></p>\n<p>打开后拉到最下面，输入图片中的内容</p>\n<p><img data-src=\"../../../../img/26.JPG\" alt></p>\n<p>type：指定 git</p>\n<p>repo：你的 github 仓库地址，从仓库地址页面点击 Code，复制其 https 或 git 链接</p>\n<p>branch：github 仓库分支</p>\n<p><img data-src=\"../../../../img/27.JPG\" alt></p>\n<p>在博客根目录下打开 git bash，输入指令安装依赖</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>npm install hexo-deployer-git --save</pre></td></tr></table></figure><p>安装完后输入</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>hexo g</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>hexo d</pre></td></tr></table></figure><p><img data-src=\"../../../../img/28.JPG\" alt></p>\n<p>出现以上提示前往仓库查看是否有上传成功，报错不用管，不影响</p>\n<p>输入 http:// 你的 github 用户名.github.io 即可访问博客</p>\n<h1 id=\"使用域名访问博客\"><a class=\"anchor\" href=\"#使用域名访问博客\">#</a> 使用域名访问博客</h1>\n<p>在完成上面基础后，可以正常访问博客后，可使用域名来代替 github 的网址访问博客</p>\n<p>首先你需要获取一个域名，无论是腾讯云还是阿里云等等都可以，去自定义一个域名购买，域名一年制，只要后缀不是.com 之类的都很便宜，获取域名就不演示了，百度下都知道</p>\n<h2 id=\"修改或添加域名文件\"><a class=\"anchor\" href=\"#修改或添加域名文件\">#</a> 修改或添加域名文件</h2>\n<p>在放置你博客文件的仓库中，先查看有没有 **“<span class=\"exturl\" data-url=\"aHR0cDovL1JFQURNRS5tZA==\">README.md</span>”** 这个文件，这个在创建仓库时候有选过。</p>\n<p>如果有，则会在仓库底下有一栏这样的信息，点击右上角的笔，修改为你购买的域名（不要 www），点击最下方绿色按钮完成修改</p>\n<p><img data-src=\"../../../../img/32.png\" alt></p>\n<p>如果没有，则在仓库中，点击<strong> Add file</strong>，<strong>Create new file</strong>，文件名字填写 READNE，内容填写你购买的域名（不要 www）</p>\n<p>好像如果没有的话，最下方会提示你缺少这个文件，然后你可以选择去创建</p>\n<p><img data-src=\"../../../../img/31.png\" alt></p>\n<p>设置完文件后，点击仓库的<strong> Settings</strong>，在侧边栏点击<strong> Pages</strong>，在<strong> Custom domain</strong> 中输入你购买的域名（不要 www），点击 save，这时候会提示你 dns 之类的错误，先不管</p>\n<p><img data-src=\"../../../../img/33.png\" alt></p>\n<p>去到你所购买域名的客户商，查找该客户商的 DNS 解析（每家都不一样）</p>\n<p>添加两行记录</p>\n<p>一行主机记录为 @，类型为 CHAME，记录路径为你的仓库名</p>\n<p>一行主机记录为 www，类型为 CHAME，记录路径为你的仓库名</p>\n<p>这样带不带 www 都可以访问这个域名</p>\n<p>顺带提一句，这里可以解析为你 github 仓库的 ip 地址，但是 github 哪里的 dns 会告诉你转为仓库名</p>\n<p><img data-src=\"../../../../img/34.png\" alt></p>\n<p>回到 github 哪里，刷新页面重新检查域名 DNS（如果没自动检查就点击旁边的按钮）</p>\n<p>没问题之后最上方会显示你的网址准备好了，复制网址即可让他人访问你的博客了</p>\n<h1 id=\"关于sslhttps\"><a class=\"anchor\" href=\"#关于sslhttps\">#</a> 关于 SSL（https）</h1>\n<p>在自定义域名的下方是有一个强制启动 HTTPS 链接的<strong> Enforce HTTPS</strong>，因为我在域名哪里弄了 SSL 证书，勾选了这个之后就会提示我的博客链接不安全，证书来自 github（外网缘故？）</p>\n<p>我的建议还是获取证书去域名哪里安装较好</p>\n<p><img data-src=\"../../../../img/35.png\" alt></p>\n<p>这里以腾讯云为例，搜索 SSL 证书进入此界面，点击申请免费证书，经过里头的填写相关信息即可申请一张一年的免费证书（同一主域最多申请 20 张，也就是 20 年）</p>\n<p><img data-src=\"../../../../img/36.png\" alt></p>\n<p>申请到之后，会让你进行 DNS 验证（有手动和自动，区别在于你之前是否域名进行解析）</p>\n<p>待证书审核通过后可以下载保存</p>\n<p>后面的流程说实话我忘了。请大家自行百度</p>\n",
            "tags": [
                "计算机科学",
                "hexo博客",
                "Theme Shoka Documentation",
                "Hexo",
                "教程"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E5%8A%9F%E8%83%BD/",
            "url": "https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E5%8A%9F%E8%83%BD/",
            "title": "",
            "date_published": "2022-06-10T00:43:15.818Z",
            "content_html": "",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/css/%E5%85%B6%E4%BB%96CSS/content-visibility/",
            "url": "https://entropywhite.com/computer-science/web/css/%E5%85%B6%E4%BB%96CSS/content-visibility/",
            "title": "",
            "date_published": "2022-06-09T01:32:24.218Z",
            "content_html": "<h2 id=\"何为-content-visibility\"><a class=\"anchor\" href=\"#何为-content-visibility\">#</a> 何为  <code>content-visibility</code> ？</h2>\n<p><code>content-visibility</code> ：属性控制一个元素是否渲染其内容，它允许用户代理（浏览器）潜在地省略大量布局和渲染工作，直到需要它为止。</p>\n<p>有几个常见的取值</p>\n<pre><code>content-visibility: visible;\ncontent-visibility: hidden;\ncontent-visibility: auto;\n</code></pre>\n<ul>\n<li><code>content-visibility: visible</code> ：默认值，没有任何效果，相当于没有添加  <code>content-visibility</code> ，元素的渲染与往常一致。</li>\n<li><code>content-visibility: hidden</code> ：与  <code>display: none</code>  类似，用户代理将跳过其内容的渲染。（这里需要注意的是，跳过的是内容的渲染）</li>\n<li><code>content-visibility: auto</code> ：如果该元素不在屏幕上，并且与用户无关，则不会渲染其后代元素。</li>\n</ul>\n<h3 id=\"contain-intrinsic-size\"><a class=\"anchor\" href=\"#contain-intrinsic-size\">#</a> contain-intrinsic-size</h3>\n<p>当然，除  <code>content-visibility</code>  之外，还有一个与之配套的属性 --  <code>contain-intrinsic-size</code> 。</p>\n<p><code>contain-intrinsic-size</code> ：控制由  <code>content-visibility</code>  指定的元素的自然大小。</p>\n<p>上面两个属性光看定义和介绍会有点绕。</p>\n<p>我们首先来看看  <code>content-visibility</code>  如何具体使用。</p>\n<p><code>content-visibility: visible</code>  是默认值，添加后没有任何效果，我们就直接跳过。</p>\n<h2 id=\"利用-content-visibility-hidden-优化展示切换性能\"><a class=\"anchor\" href=\"#利用-content-visibility-hidden-优化展示切换性能\">#</a> 利用  <code>content-visibility: hidden</code>  优化展示切换性能</h2>\n<p>首先来看看  <code>content-visibility: hidden</code> ，它通常会拿来和  <code>display: none</code>  做比较，但是其实它们之间还是有很大的不同的。</p>\n<p>首先，假设我们有两个 DIV 包裹框：</p>\n<pre><code>&lt;div class=&quot;g-wrap&quot;&gt;\n    &lt;div&gt;1111&lt;/div&gt;\n    &lt;div class=&quot;hidden&quot;&gt;2222&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>设置两个 div 为  <code>200x200</code>  的黑色块：</p>\n<pre><code>.g-wrap &gt; div &#123;\n    width: 200px;\n    height: 200px;\n    background: #000;\n&#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0Z5uGrwQFUGN9iax3TS0lcuonBdqHpOgWnwACiaAnLgOBHQ3rsZYP7rZdw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>OK，没有问题，接下来，我们给其中的  <code>.hidden</code>  设置  <code>content-visibility: hidden</code> ，看看会发生什么：</p>\n<pre><code>.hidden &#123;\n    content-visibility: hidden;\n&#125;\n</code></pre>\n<p>效果如下：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0Zmot8P62VzRfeq6TGseWB8aZ7p3OqL8Tvj1oMa95K56picO6iapQQcE4Q/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>注意，仔细看效果，这里添加了  <code>content-visibility: hidden</code>  之后，<strong>消失的只是添加了该元素的 div 的子元素消失不见，而父元素本身及其样式，还是存在页面上的</strong>。</p>\n<p>如果我们去掉设置了  <code>content-visibility: hidden</code>  的元素本身的  <code>width</code> 、 <code>height</code> 、 <code>padding</code> 、 <code>margin</code>  等属性，则元素看上去就如同设置了  <code>display: none</code>  一般，在页面上消失不见了。</p>\n<p>那么， <code>content-visibility: hidden</code>  的作用是什么呢？</p>\n<p>设置了  <code>content-visibility: hidden</code>  的元素，<strong>其元素的子元素将被隐藏，但是，它的渲染状态将会被缓存</strong>。所以，当  <code>content-visibility: hidden</code>  被移除时，用户代理无需重头开始渲染它和它的子元素。</p>\n<p>因此，如果我们将这个属性应用在一些一开始需要被隐藏，但是其后在页面的某一时刻需要被渲染，或者是一些需要被频繁切换显示、隐藏状态的元素上，其渲染效率将会有一个非常大的提升。</p>\n<h2 id=\"利用-content-visibility-auto-实现懒加载或虚拟列表\"><a class=\"anchor\" href=\"#利用-content-visibility-auto-实现懒加载或虚拟列表\">#</a> 利用  <code>content-visibility: auto</code>  实现懒加载或虚拟列表</h2>\n<p>OK，接下来是  <code>content-visibility</code>  的核心用法，利用  <code>auto</code>  属性值。</p>\n<p><code>content-visibility: auto</code>  的作用是，如果该元素不在屏幕上，并且与用户无关，则不会渲染其后代元素。是不是与 LazyLoad 非常类似？</p>\n<p>我们来看这样一个 DEMO ，了解其作用：</p>\n<p>假设，我们存在这样一个 HTML 结构，含有大量的文本内容：</p>\n<pre><code>&lt;div class=&quot;g-wrap&quot;&gt;\n    &lt;div class=&quot;paragraph&quot;&gt;...&lt;/div&gt;\n    // ... 包含了 N 个 paragraph\n    &lt;div class=&quot;paragraph&quot;&gt;...&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>每个  <code>.paragraph</code>  的内容如下：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZlicfKepfpKM9LsEyKNEAa4sHIfnuUsvatwBL6C7K87ch3MN58OmL7mQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>因此，整个的页面看起来就是这样的：</p>\n<p><img data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\"></p>\n<p>由于，我们没有对页面内容进行任何处理，因此，所有的  <code>.paragraph</code>  在页面刷新的一瞬间，都会进行渲染，看到的效果就如上所示。</p>\n<p>当然，现代浏览器愈加趋于智能，基于这种场景，其实我们非常希望对于仍未看到，仍旧未滚动到的区域，可以延迟加载，只有到我们需要展示、滚动到该处时，页面内容才进行渲染。</p>\n<p>基于这种场景， <code>content-visibility: auto</code>  就应运而生了，它允许浏览器对于设置了该属性的元素进行判断，如果该元素当前不处于视口内，则不渲染该元素。</p>\n<p>我们基于上述的代码，只需要最小化，添加这样一段代码：</p>\n<pre><code>.paragraph &#123;\n    content-visibility: auto;\n&#125;\n</code></pre>\n<p>再看看效果，仔细观察右侧的滚动条：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZkW8pdFFIClxN4yTgVCCA5ovG2ib0bUuEfBpTSoAlEHrbQgAezcFxiaiaw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<blockquote>\n<p>这里我使用了  <code>::-webkit-scrollbar</code>  相关样式，让滚动条更明显。</p>\n</blockquote>\n<p>可能你还没意识到发生了什么，我们对比下添加了  <code>content-visibility: auto</code>  和没有添加  <code>content-visibility: auto</code>  的两种效果下文本的整体高度：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZEGWYB2KLOLNib2gOhibZ4WMiaFRwJ5sdWEfDSAibwDMuJN6YFm2DZUPvsg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>有着非常明显的差异，这是因为，设置了  <code>content-visibility: auto</code>  的元素，在非可视区域内，目前并没有被渲染，因此，右侧内容的高度其实是比正常状态下少了一大截的。</p>\n<p>好，我们实际开始进行滚动，看看会发生什么：</p>\n<p><img data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\"></p>\n<p>由于下方的元素在滚动的过程中，出现在视口范围内才被渲染，因此，滚动条出现了明显的飘忽不定的抖动现象。（当然这也是使用了  <code>content-visibility: auto</code>  的一个小问题之一），不过明显可以看出，这与我们通常使用 JavaScript 实现的懒加载或者延迟加载非常类似。</p>\n<p>当然，与懒加载不同的是，在向下滚动的过程中，上方消失的已经被渲染过且消失在视口的元素，也会因为消失在视口中，重新被隐藏。因此，即便页面滚动到最下方，整体的滚动条高度还是没有什么变化的。</p>\n<h2 id=\"content-visibility-是否能够优化渲染性能\"><a class=\"anchor\" href=\"#content-visibility-是否能够优化渲染性能\">#</a>  <code>content-visibility</code>  是否能够优化渲染性能？</h2>\n<p>那么， <code>content-visibility</code>  是否能够优化渲染性能呢？</p>\n<p>在 <strong>Youtube -- Slashing layout cost with content-visibility</strong> [1] 中，给了一个非常好的例子。</p>\n<p>这里我简单复现一下。</p>\n<p>对于一个存在巨量 HTML 内容的页面，譬如类似于这个页面 -- <strong>HTML - Living Standard</strong>[2]</p>\n<p><img data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\"></p>\n<p>可以感受到，往下翻，根本翻不到尽头。（这里我在本地模拟了该页面，复制了该页面的所有 DOM，并非实际在该网站进行测试）</p>\n<p>如果不对这个页面做任何处理，看看首次渲染需要花费的时间：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZHk1xzQO5qJ1ialQcmE6aTkaEvXhqFCUxtqrgiaoeiatz4VPZMl1YUNmWg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>可以看到，DOMContentLoaded 的时间的  <code>3s+</code> ，而花费在 Rendering 上的就有整整  <code>2900ms</code> ！</p>\n<p>而如果给这个页面的每个段落，添加上  <code>content-visibility: auto</code> ，再看看整体的耗时：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZNxIaXNwkaI02Ifd5zJRuCbaT1PWknVeNTeRsIQuCC4YC6xaD8wZr6w/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>可以看到，DOMContentLoaded 的时间骤降至了  <code>500ms+</code> ，而花费在 Rendering 上的，直接优化到了  <code>61ms</code> ！</p>\n<p>2900ms --&gt; 61ms，可谓是惊人级别的优化了。因此， <code>content-visibility: auto</code>  对于长文本、长列表功能的优化是显而易见的。</p>\n<h2 id=\"利用-contain-intrinsic-size-解决滚动条抖动问题\"><a class=\"anchor\" href=\"#利用-contain-intrinsic-size-解决滚动条抖动问题\">#</a> 利用  <code>contain-intrinsic-size</code>  解决滚动条抖动问题</h2>\n<p>当然， <code>content-visibility</code>  也存在一些小问题。</p>\n<p>从上面的例子，也能看到，在利用  <code>content-visibility: auto</code>  处理长文本、长列表的时候。在滚动页面的过程中，滚动条一直在抖动，这不是一个很好的体验。</p>\n<p>当然，这也是许多虚拟列表都会存在的一些问题。</p>\n<p>好在，规范制定者也发现了这个问题。这里我们可以使用另外一个 CSS 属性，也就是文章一开头提到的另外一个属性 --  <code>contain-intrinsic-size</code> ，来解决这个问题。</p>\n<p><code>contain-intrinsic-size</code> ：控制由  <code>content-visibility</code>  指定的元素的自然大小。</p>\n<p>什么意思呢？</p>\n<p>还是上面的例子</p>\n<pre><code>&lt;div class=&quot;g-wrap&quot;&gt;\n    &lt;div class=&quot;paragraph&quot;&gt;...&lt;/div&gt;\n    // ... 包含了 N 个 paragraph\n    &lt;div class=&quot;paragraph&quot;&gt;...&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p>如果我们不使用  <code>contain-intrinsic-size</code> ，只对视口之外的元素使用  <code>content-visibility: auto</code> ，那么视口外的元素高度通常就为 0。</p>\n<blockquote>\n<p>当然，如果直接给父元素设置固定的  <code>height</code> ，也是会有高度的。</p>\n</blockquote>\n<p>那么实际的滚动效果，滚动条就是抖动的：</p>\n<p><img data-src=\"data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==\" alt=\"图片\"></p>\n<p>所以，我们可以同时利用上  <code>contain-intrinsic-size</code> ，如果能准确知道设置了  <code>content-visibility: auto</code>  的元素在渲染状态下的高度，就填写对应的高度。如果如法准确知道高度，也可以填写一个大概的值：</p>\n<pre><code>.paragraph &#123;\n    content-visibility: auto;\n    contain-intrinsic-size: 320px;\n&#125;\n</code></pre>\n<p>如此之后，浏览器会给未被实际渲染的视口之外的  <code>.paragraph</code>  元素一个高度，避免出现滚动条抖动的现象：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZbCM0FEwXgXiadeT3tw6Pn4ib3IibQfSFPGqO2nzxYdWam89CXRkS1WVqQ/640?wx_fmt=gif&amp;wxfrom=5&amp;wx_lazy=1\" alt=\"图片\"></p>\n<h2 id=\"content-visibility-的一些其他问题\"><a class=\"anchor\" href=\"#content-visibility-的一些其他问题\">#</a>  <code>content-visibility</code>  的一些其他问题</h2>\n<p>首先，看看  <code>content-visibility</code>  的兼容性（2022-06-03）：</p>\n<p><img data-src=\"https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZHACoqdZP6j8hicFRnuwBQjtsnVicWCFJ3D25tjolZkEAEVbfibMK7GTGw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" alt=\"图片\"></p>\n<p>目前还是比较惨淡的，并且我没有实际在业务中使用它，需要再等待一段时间。<strong>当然，由于该属性属于渐进增强一类的功能，即便失效，也完全不影响页面本身的展示。</strong></p>\n<p>同时，也有一些同学表示，利用  <code>content-visibility: auto</code>  只能解决部分场景，在海量 DOM 的场景下的实际效果，还有待进一步的实测。真正运用的时候，多做对比，再做取舍。</p>\n<p>当然，现代浏览器已经越来越智能，类似  <code>content-visibility</code>  功能的属性也越来越多，我们在性能优化的路上有了更多选择，总归是一件好事。</p>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/css/css%E9%A2%84%E5%A4%84%E7%90%86/scss-master/docs/README/",
            "url": "https://entropywhite.com/computer-science/web/css/css%E9%A2%84%E5%A4%84%E7%90%86/scss-master/docs/README/",
            "title": "",
            "date_published": "2022-06-02T00:52:28.542Z",
            "content_html": "<h2 id=\"basic\"><a class=\"anchor\" href=\"#basic\">#</a> Basic</h2>\n<p>The generated ggdreams_scss_tutorial's documentation is at https://ggdreams_scss_tutorial.readthedocs.io/</p>\n<p>This directory contains the documentation source.  It is written using reST<br>\n(re-Structured Text) format source files which are processed using Sphinx and<br>\nturned into HTML, PDF or ePub documents. If you wish to build these yourself,<br>\nyou need to install Sphinx. Sphinx is available on many Linux distributions as a<br>\npre-built package. You can also install Sphinx on all platforms using the Python<br>\npackage manager &quot;pip&quot;. For more information on Sphinx, please visit this page:</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL3d3dy5zcGhpbngtZG9jLm9yZw==\">http://www.sphinx-doc.org</span></p>\n<p>Once Sphinx is installed, the supplied Makefile can be used to build the<br>\ndifferent targets.</p>\n<h2 id=\"contribute\"><a class=\"anchor\" href=\"#contribute\">#</a> Contribute</h2>\n<p>直接修改顶层目录中的 <code>.md</code>  文件，文档将会由 Actions 自动生成，并发布于 readthedocs 文档托管服务。</p>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/async%E5%87%BD%E6%95%B0/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/async%E5%87%BD%E6%95%B0/",
            "title": "",
            "date_published": "2022-05-26T02:43:38.928Z",
            "content_html": "<h2 id=\"async\"><a class=\"anchor\" href=\"#async\">#</a> async</h2>\n<p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。</p>\n<h3 id=\"语法\"><a class=\"anchor\" href=\"#语法\">#</a> 语法</h3>\n<pre><code>async function name([param[, param[, ... param]]]) &#123; statements &#125;\n</code></pre>\n<ul>\n<li>name: 函数名称。</li>\n<li>param: 要传递给函数的参数的名称。</li>\n<li>statements: 函数体语句。</li>\n</ul>\n<h3 id=\"返回值\"><a class=\"anchor\" href=\"#返回值\">#</a> 返回值</h3>\n<p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</p>\n<pre><code>async function helloAsync()&#123;\n    return &quot;helloAsync&quot;;\n  &#125;\n  \nconsole.log(helloAsync())  // Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;\n \nhelloAsync().then(v=&gt;&#123;\n   console.log(v);         // helloAsync\n&#125;)\n</code></pre>\n<p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p>\n<p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p>\n<pre><code>function testAwait()&#123;\n   return new Promise((resolve) =&gt; &#123;\n       setTimeout(function()&#123;\n          console.log(&quot;testAwait&quot;);\n          resolve();\n       &#125;, 1000);\n   &#125;);\n&#125;\n \nasync function helloAsync()&#123;\n   await testAwait();\n   console.log(&quot;helloAsync&quot;);\n &#125;\nhelloAsync();\n// testAwait\n// helloAsync\n</code></pre>\n<h2 id=\"await\"><a class=\"anchor\" href=\"#await\">#</a> await</h2>\n<p>await 操作符用于等待一个 Promise 对象，它只能在异步函数 async function 内部使用。</p>\n<h3 id=\"语法-2\"><a class=\"anchor\" href=\"#语法-2\">#</a> 语法</h3>\n<pre><code>[return_value] = await expression;\n</code></pre>\n<ul>\n<li>expression: 一个 Promise 对象或者任何要等待的值。</li>\n</ul>\n<h3 id=\"返回值-2\"><a class=\"anchor\" href=\"#返回值-2\">#</a> 返回值</h3>\n<p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p>\n<p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</p>\n<pre><code>function testAwait (x) &#123;\n  return new Promise(resolve =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      resolve(x);\n    &#125;, 2000);\n  &#125;);\n&#125;\n \nasync function helloAsync() &#123;\n  var x = await testAwait (&quot;hello world&quot;);\n  console.log(x); \n&#125;\nhelloAsync ();\n// hello world\n</code></pre>\n<p>正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。</p>\n<pre><code>function testAwait()&#123;\n   console.log(&quot;testAwait&quot;);\n&#125;\nasync function helloAsync()&#123;\n   await testAwait();\n   console.log(&quot;helloAsync&quot;);\n&#125;\nhelloAsync();\n// testAwait\n// helloAsync\n</code></pre>\n<p>await 针对所跟不同表达式的处理方式：</p>\n<ul>\n<li>Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。</li>\n<li>非 Promise 对象：直接返回对应的值。</li>\n</ul>\n<pre><code>async function a()&#123;  \n  console.log(&quot;1&quot;)  \n   console.log(&quot;2&quot;)\n&#125;\na()\nconsole.log(&quot;3&quot;)\n//打印： 1 2 3 \n</code></pre>\n<p>使用 await 测试：</p>\n<pre><code>async function a()&#123;  \n  await 1  \n  console.log(&quot;1&quot;)  \n  console.log(&quot;2&quot;)\n&#125;\na()\nconsole.log(&quot;3&quot;)\n//打印： 3 1 2\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Generator%E5%87%BD%E6%95%B0/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Generator%E5%87%BD%E6%95%B0/",
            "title": "",
            "date_published": "2022-05-26T02:43:31.605Z",
            "content_html": "<p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法</p>\n<h3 id=\"generator-函数组成\"><a class=\"anchor\" href=\"#generator-函数组成\">#</a> Generator 函数组成</h3>\n<p>Generator 有两个区分于普通函数的部分：</p>\n<ul>\n<li>一是在 function 后面，函数名之前有个 * ；</li>\n<li>函数内部有 yield 表达式。</li>\n</ul>\n<p>其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。</p>\n<pre><code>function* func()&#123;\n console.log(&quot;one&quot;);\n yield '1';\n console.log(&quot;two&quot;);\n yield '2'; \n console.log(&quot;three&quot;);\n return '3';\n&#125;\n</code></pre>\n<h3 id=\"执行机制\"><a class=\"anchor\" href=\"#执行机制\">#</a> 执行机制</h3>\n<p>调用 Generator 函数和调用普通函数一样，在函数名后面加上 () 即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象 Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行</p>\n<pre><code>f.next();\n// one\n// &#123;value: &quot;1&quot;, done: false&#125;\n \nf.next();\n// two\n// &#123;value: &quot;2&quot;, done: false&#125;\n \nf.next();\n// three\n// &#123;value: &quot;3&quot;, done: true&#125;\n \nf.next();\n// &#123;value: undefined, done: true&#125;\n</code></pre>\n<p>第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one , 执行到 yield 就停下来，并将 yield 后边表达式的值 '1'，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。</p>\n<p>第二次调用 next 方法时，同上步 。</p>\n<p>第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为 true 。</p>\n<p>第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。</p>\n<h3 id=\"函数返回的遍历器对象的方法\"><a class=\"anchor\" href=\"#函数返回的遍历器对象的方法\">#</a> 函数返回的遍历器对象的方法</h3>\n<p><strong>next 方法</strong></p>\n<p>一般情况下，next 方法不传入参数的时候，yield 表达式的返回值是 undefined 。当 next 传入参数的时候，该参数会作为上一步 yield 的返回值。</p>\n<pre><code>function* sendParameter()&#123;\n    console.log(&quot;start&quot;);\n    var x = yield '2';\n    console.log(&quot;one:&quot; + x);\n    var y = yield '3';\n    console.log(&quot;two:&quot; + y);\n    console.log(&quot;total:&quot; + (x + y));\n&#125;\n</code></pre>\n<p>next 不传参</p>\n<pre><code>var sendp1 = sendParameter();\nsendp1.next();\n// start\n// &#123;value: &quot;2&quot;, done: false&#125;\nsendp1.next();\n// one:undefined\n// &#123;value: &quot;3&quot;, done: false&#125;\nsendp1.next();\n// two:undefined\n// total:NaN\n// &#123;value: undefined, done: true&#125;\nnext传参\nvar sendp2 = sendParameter();\nsendp2.next(10);\n// start\n// &#123;value: &quot;2&quot;, done: false&#125;\nsendp2.next(20);\n// one:20\n// &#123;value: &quot;3&quot;, done: false&#125;\nsendp2.next(30);\n// two:30\n// total:50\n// &#123;value: undefined, done: true&#125;\n</code></pre>\n<p>除了使用 next ，还可以使用 for... of 循环遍历 Generator 函数生产的 Iterator 对象。</p>\n<p><strong>return 方法</strong></p>\n<p>return 方法返回给定值，并结束遍历 Generator 函数。</p>\n<p>return 方法提供参数时，返回该参数；不提供参数时，返回 undefined 。</p>\n<pre><code>function* foo()&#123;\n    yield 1;\n    yield 2;\n    yield 3;\n&#125;\nvar f = foo();\nf.next();\n// &#123;value: 1, done: false&#125;\nf.return(&quot;foo&quot;);\n// &#123;value: &quot;foo&quot;, done: true&#125;\nf.next();\n// &#123;value: undefined, done: true&#125;\nthrow 方法\nthrow 方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获。\nvar g = function* () &#123;\n  try &#123;\n    yield;\n  &#125; catch (e) &#123;\n    console.log('catch inner', e);\n  &#125;\n&#125;;\n \nvar i = g();\ni.next();\n \ntry &#123;\n  i.throw('a');\n  i.throw('b');\n&#125; catch (e) &#123;\n  console.log('catch outside', e);\n&#125;\n// catch inner a\n// catch outside b\n</code></pre>\n<p>遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，第二个因为函数体内部的 catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。</p>\n<p><strong>yield* 表达式</strong></p>\n<p>yield* 表达式表示 yield 返回一个遍历器对象，用于在 Generator 函数内部，调用另一个 Generator 函数。</p>\n<pre><code>function* callee() &#123;\n    console.log('callee: ' + (yield));\n&#125;\nfunction* caller() &#123;\n    while (true) &#123;\n        yield* callee();\n    &#125;\n&#125;\nconst callerObj = caller();\ncallerObj.next();\n// &#123;value: undefined, done: false&#125;\ncallerObj.next(&quot;a&quot;);\n// callee: a\n// &#123;value: undefined, done: false&#125;\ncallerObj.next(&quot;b&quot;);\n// callee: b\n// &#123;value: undefined, done: false&#125;\n \n// 等同于\nfunction* caller() &#123;\n    while (true) &#123;\n        for (var value of callee) &#123;\n          yield value;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"使用场景\"><a class=\"anchor\" href=\"#使用场景\">#</a> 使用场景</h3>\n<p><strong>实现 Iterator</strong></p>\n<p>为不具备 Iterator 接口的对象提供遍历方法。</p>\n<pre><code>function* objectEntries(obj) &#123;\n    const propKeys = Reflect.ownKeys(obj);\n    for (const propKey of propKeys) &#123;\n        yield [propKey, obj[propKey]];\n    &#125;\n&#125;\n \nconst jane = &#123; first: 'Jane', last: 'Doe' &#125;;\nfor (const [key,value] of objectEntries(jane)) &#123;\n    console.log(`$&#123;key&#125;: $&#123;value&#125;`);\n&#125;\n// first: Jane\n// last: Doe\n</code></pre>\n<p>Reflect.ownKeys () 返回对象所有的属性，不管属性是否可枚举，包括 Symbol。</p>\n<p>jane 原生是不具备 Iterator 接口无法通过 for... of 遍历。这边用了 Generator 函数加上了 Iterator 接口，所以就可以遍历 jane 对象了。</p>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Promise%E5%AF%B9%E8%B1%A1/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Promise%E5%AF%B9%E8%B1%A1/",
            "title": "",
            "date_published": "2022-05-26T02:43:24.985Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>是异步编程的一种解决方案。</p>\n<p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>\n<h2 id=\"promise-状态\"><a class=\"anchor\" href=\"#promise-状态\">#</a> Promise 状态</h2>\n<h3 id=\"状态的特点\"><a class=\"anchor\" href=\"#状态的特点\">#</a> 状态的特点</h3>\n<p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</p>\n<p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。</p>\n<pre><code>const p1 = new Promise(function(resolve,reject)&#123;\n    resolve('success1');\n    resolve('success2');\n&#125;); \nconst p2 = new Promise(function(resolve,reject)&#123;  \n    resolve('success3'); \n    reject('reject');\n&#125;);\np1.then(function(value)&#123;  \n    console.log(value); // success1\n&#125;);\np2.then(function(value)&#123; \n    console.log(value); // success3\n&#125;);\n</code></pre>\n<h3 id=\"状态的缺点\"><a class=\"anchor\" href=\"#状态的缺点\">#</a> 状态的缺点</h3>\n<p>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</p>\n<p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p>\n<p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<h2 id=\"then-方法\"><a class=\"anchor\" href=\"#then-方法\">#</a> then 方法</h2>\n<p>then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。</p>\n<h3 id=\"then-方法的特点\"><a class=\"anchor\" href=\"#then-方法的特点\">#</a> then 方法的特点</h3>\n<p>在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用</p>\n<pre><code>const p = new Promise(function(resolve,reject)&#123;\n  resolve('success');\n&#125;);\n \np.then(function(value)&#123;\n  console.log(value);\n&#125;);\n \nconsole.log('first');\n// first\n// success\n</code></pre>\n<p>通过 <strong>.then</strong> 形式添加的回调函数，不论什么时候，都会被调用。</p>\n<p>通过多次调用</p>\n<p>.then</p>\n<p>，可以添加多个回调函数，它们会按照插入顺序并且独立运行。</p>\n<pre><code>const p = new Promise(function(resolve,reject)&#123;\n  resolve(1);\n&#125;).then(function(value)&#123; // 第一个then // 1\n  console.log(value);\n  return value * 2;\n&#125;).then(function(value)&#123; // 第二个then // 2\n  console.log(value);\n&#125;).then(function(value)&#123; // 第三个then // undefined\n  console.log(value);\n  return Promise.resolve('resolve'); \n&#125;).then(function(value)&#123; // 第四个then // resolve\n  console.log(value);\n  return Promise.reject('reject'); \n&#125;).then(function(value)&#123; // 第五个then //reject:reject\n  console.log('resolve:' + value);\n&#125;, function(err) &#123;\n  console.log('reject:' + err);\n&#125;);\n</code></pre>\n<p>then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。</p>\n<h3 id=\"then-方法注意点\"><a class=\"anchor\" href=\"#then-方法注意点\">#</a> then 方法注意点</h3>\n<p>简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。</p>\n<p>注意总是返回或终止 Promise 链。</p>\n<pre><code>const p1 = new Promise(function(resolve,reject)&#123;\n  resolve(1);\n&#125;).then(function(result) &#123;\n  p2(result).then(newResult =&gt; p3(newResult));\n&#125;).then(() =&gt; p4());\n</code></pre>\n<p>创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。</p>\n<p>大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 <strong>.catch(error =&gt; console.log(error));</strong></p>\n<h2 id=\"更多文章\"><a class=\"anchor\" href=\"#更多文章\">#</a> 更多文章</h2>\n<p><a href=\"JS-Promise%E5%AF%B9%E8%B1%A1\">JS-Promise 对象</a></p>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%A8%A1%E5%9D%97/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%A8%A1%E5%9D%97/",
            "title": "",
            "date_published": "2022-05-26T02:43:21.624Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。</p>\n<p>ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>\n<p>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p>\n<h2 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h2>\n<p>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 <strong>use strict;</strong>。</p>\n<p>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。</p>\n<p>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。</p>\n<p>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</p>\n<h2 id=\"export-与-import\"><a class=\"anchor\" href=\"#export-与-import\">#</a> export 与 import</h2>\n<h3 id=\"基本用法\"><a class=\"anchor\" href=\"#基本用法\">#</a> 基本用法</h3>\n<p>模块导入导出各种类型的变量，如字符串，数值，函数，类。</p>\n<ul>\n<li>导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。</li>\n<li>不仅能导出声明还能导出引用（例如函数）。</li>\n<li>export 命令可以出现在模块的任何位置，但必需处于模块顶层。</li>\n<li>import 命令会提升到整个模块的头部，首先执行。</li>\n</ul>\n<pre><code>/*-----export [test.js]-----*/\nlet myName = &quot;Tom&quot;;\nlet myAge = 20;\nlet myfn = function()&#123;\n    return &quot;My name is&quot; + myName + &quot;! I'm '&quot; + myAge + &quot;years old.&quot;\n&#125;\nlet myClass =  class myClass &#123;\n    static a = &quot;yeah!&quot;;\n&#125;\nexport &#123; myName, myAge, myfn, myClass &#125;\n \n/*-----import [xxx.js]-----*/\nimport &#123; myName, myAge, myfn, myClass &#125; from &quot;./test.js&quot;;\nconsole.log(myfn());// My name is Tom! I'm 20 years old.\nconsole.log(myAge);// 20\nconsole.log(myName);// Tom\nconsole.log(myClass.a );// yeah!\n</code></pre>\n<p>建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。</p>\n<p>函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。</p>\n<h3 id=\"as-的用法\"><a class=\"anchor\" href=\"#as-的用法\">#</a> as 的用法</h3>\n<p>export 命令导出的接口名称，须和模块内部的变量有一一对应关系。</p>\n<p>导入的变量名，须和导出的接口名称相同，即顺序可以不一致。</p>\n<pre><code>/*-----export [test.js]-----*/\nlet myName = &quot;Tom&quot;;\nexport &#123; myName as exportName &#125;\n \n/*-----import [xxx.js]-----*/\nimport &#123; exportName &#125; from &quot;./test.js&quot;;\nconsole.log(exportName);// Tom\n使用 as 重新定义导出的接口名称，隐藏模块内部的变量\n/*-----export [test1.js]-----*/\nlet myName = &quot;Tom&quot;;\nexport &#123; myName &#125;\n/*-----export [test2.js]-----*/\nlet myName = &quot;Jerry&quot;;\nexport &#123; myName &#125;\n/*-----import [xxx.js]-----*/\nimport &#123; myName as name1 &#125; from &quot;./test1.js&quot;;\nimport &#123; myName as name2 &#125; from &quot;./test2.js&quot;;\nconsole.log(name1);// Tom\nconsole.log(name2);// Jerry\n</code></pre>\n<p>不同模块导出接口名称命名重复， 使用 as 重新定义变量名。</p>\n<h3 id=\"import-命令的特点\"><a class=\"anchor\" href=\"#import-命令的特点\">#</a> import 命令的特点</h3>\n<p><strong>只读属性</strong>：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。</p>\n<pre><code>import &#123;a&#125; from &quot;./xxx.js&quot;\na = &#123;&#125;; // error\n \nimport &#123;a&#125; from &quot;./xxx.js&quot;\na.foo = &quot;hello&quot;; // a = &#123; foo : 'hello' &#125;\n</code></pre>\n<p><strong>单例模式</strong>：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。</p>\n<pre><code>import &#123; a &#125; &quot;./xxx.js&quot;;\nimport &#123; a &#125; &quot;./xxx.js&quot;;\n// 相当于 import &#123; a &#125; &quot;./xxx.js&quot;;\n \nimport &#123; a &#125; from &quot;./xxx.js&quot;;\nimport &#123; b &#125; from &quot;./xxx.js&quot;;\n// 相当于 import &#123; a, b &#125; from &quot;./xxx.js&quot;;\n</code></pre>\n<p>静态执行特性：import 是静态执行，所以不能使用表达式和变量。</p>\n<pre><code>import &#123; &quot;f&quot; + &quot;oo&quot; &#125; from &quot;methods&quot;;\n// error\nlet module = &quot;methods&quot;;\nimport &#123; foo &#125; from module;\n// error\nif (true) &#123;\n  import &#123; foo &#125; from &quot;method1&quot;;\n&#125; else &#123;\n  import &#123; foo &#125; from &quot;method2&quot;;\n&#125;\n// error\n</code></pre>\n<h3 id=\"export-default-命令\"><a class=\"anchor\" href=\"#export-default-命令\">#</a> export default 命令</h3>\n<ul>\n<li>在一个文件或模块中，export、import 可以有多个，export default 仅有一个。</li>\n<li>export default 中的 default 是对应的导出接口变量。</li>\n<li>通过 export 方式导出，在导入时要加 { }，export default 则不需要。</li>\n<li>export default 向外暴露的成员，可以使用任意变量来接收。</li>\n</ul>\n<pre><code>var a = &quot;My name is Tom!&quot;;\nexport default a; // 仅有一个\nexport default var c = &quot;error&quot;; \n// error，default 已经是对应的导出变量，不能跟着变量声明语句\n \nimport b from &quot;./xxx.js&quot;; // 不需要加&#123;&#125;， 使用任意变量接收\n</code></pre>\n<h2 id=\"复合使用\"><a class=\"anchor\" href=\"#复合使用\">#</a> 复合使用</h2>\n<blockquote>\n<p><strong>注</strong>：import () 是提案，这边暂时不延伸讲解。</p>\n</blockquote>\n<p>export 与 import 可以在同一模块使用，使用特点：</p>\n<ul>\n<li>\n<p>可以将导出接口改名，包括 default。</p>\n</li>\n<li>\n<p>复合使用 export 与 import ，也可以导出全部，当前模块导出的接口会覆盖继承导出的。</p>\n</li>\n<li>\n<pre><code> export &#123; foo, bar &#125; from &quot;methods&quot;;\n  \n // 约等于下面两段语句，不过上面导入导出方式该模块没有导入 foo 与 bar\n import &#123; foo, bar &#125; from &quot;methods&quot;;\n export &#123; foo, bar &#125;;\n  \n /* ------- 特点 1 --------*/\n // 普通改名\n export &#123; foo as bar &#125; from &quot;methods&quot;;\n // 将 foo 转导成 default\n export &#123; foo as default &#125; from &quot;methods&quot;;\n // 将 default 转导成 foo\n export &#123; default as foo &#125; from &quot;methods&quot;;\n  \n /* ------- 特点 2 --------*/\n export * from &quot;methods&quot;;\n</code></pre>\n</li>\n</ul>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Class%E7%B1%BB/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Class%E7%B1%BB/",
            "title": "",
            "date_published": "2022-05-26T02:43:17.276Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>在 ES6 中，class (类) 作为对象的模板被引入，可以通过 class 关键字定义类。</p>\n<p>class 的本质是 function。</p>\n<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>\n<h2 id=\"基础用法\"><a class=\"anchor\" href=\"#基础用法\">#</a> 基础用法</h2>\n<h3 id=\"类定义\"><a class=\"anchor\" href=\"#类定义\">#</a> 类定义</h3>\n<p>类表达式可以为匿名或命名。</p>\n<pre><code>// 匿名类\nlet Example = class &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\n// 命名类\nlet Example = class Example &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"类声明\"><a class=\"anchor\" href=\"#类声明\">#</a> 类声明</h3>\n<pre><code>class Example &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\n</code></pre>\n<p>注意要点：不可重复声明</p>\n<pre><code>class Example&#123;&#125;\nclass Example&#123;&#125;\n// Uncaught SyntaxError: Identifier 'Example' has already been \n// declared\n \nlet Example1 = class&#123;&#125;\nclass Example&#123;&#125;\n// Uncaught SyntaxError: Identifier 'Example' has already been \n// declared\n</code></pre>\n<h3 id=\"注意要点\"><a class=\"anchor\" href=\"#注意要点\">#</a> 注意要点</h3>\n<p>类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。</p>\n<p>类中方法不需要 function 关键字。</p>\n<p>方法间不能加分号</p>\n<pre><code>new Example(); \nclass Example &#123;&#125;\n</code></pre>\n<h3 id=\"类的主体\"><a class=\"anchor\" href=\"#类的主体\">#</a> 类的主体</h3>\n<p><strong>属性</strong></p>\n<p>prototype</p>\n<p>ES6 中，prototype 仍旧存在，虽然可以直接自类中定义方法，但是其实方法还是定义在 prototype 上的。 覆盖方法 / 初始化时添加方法</p>\n<pre><code>Example.prototype=&#123;\n    //methods\n&#125;\n</code></pre>\n<p>添加方法</p>\n<pre><code>Object.assign(Example.prototype,&#123;\n    //methods\n&#125;)\n</code></pre>\n<p>静态属性</p>\n<p>静态属性：class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。</p>\n<pre><code>class Example &#123;\n// 新提案\n    static a = 2;\n&#125;\n// 目前可行写法\nExample.b = 2;\n</code></pre>\n<p>公共属性</p>\n<pre><code>class Example&#123;&#125;\nExample.prototype.a = 2;\n</code></pre>\n<p>实例属性</p>\n<p>实例属性：定义在实例对象（ this ）上的属性。</p>\n<pre><code>class Example &#123;\n    a = 2;\n    constructor () &#123;\n        console.log(this.a);\n    &#125;\n&#125;\n</code></pre>\n<p>name 属性</p>\n<p>返回跟在 class 后的类名 (存在时)。</p>\n<pre><code>let Example=class Exam &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\nconsole.log(Example.name); // Exam\n \nlet Example=class &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\nconsole.log(Example.name); // Example\n</code></pre>\n<p><strong>方法</strong></p>\n<p>constructor 方法</p>\n<p>constructor 方法是类的默认方法，创建类的实例化对象时被调用。</p>\n<pre><code>class Example&#123;\n    constructor()&#123;\n      console.log('我是constructor');\n    &#125;\n&#125;\nnew Example(); // 我是constructor\n</code></pre>\n<p>返回对象</p>\n<pre><code>class Test &#123;\n    constructor()&#123;\n        // 默认返回实例对象 this\n    &#125;\n&#125;\nconsole.log(new Test() instanceof Test); // true\n \nclass Example &#123;\n    constructor()&#123;\n        // 指定返回对象\n        return new Test();\n    &#125;\n&#125;\nconsole.log(new Example() instanceof Example); // false\n</code></pre>\n<p>静态方法</p>\n<pre><code>class Example&#123;\n    static sum(a, b) &#123;\n        console.log(a+b);\n    &#125;\n&#125;\nExample.sum(1, 2); // 3\n</code></pre>\n<p>原型方法</p>\n<pre><code>class Example &#123;\n    sum(a, b) &#123;\n        console.log(a + b);\n    &#125;\n&#125;\nlet exam = new Example();\nexam.sum(1, 2); // 3\n</code></pre>\n<p>实例方法</p>\n<pre><code>class Example &#123;\n    constructor() &#123;\n        this.sum = (a, b) =&gt; &#123;\n            console.log(a + b);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"类的实例化\"><a class=\"anchor\" href=\"#类的实例化\">#</a> 类的实例化</h3>\n<p><strong>new</strong></p>\n<p>class 的实例化必须通过 new 关键字</p>\n<pre><code>class Example &#123;&#125;\n \nlet exam1 = Example(); \n// Class constructor Example cannot be invoked without 'new'\n</code></pre>\n<p><strong>实例化对象</strong></p>\n<p>共享原型对象</p>\n<pre><code>class Example &#123;\n    constructor(a, b) &#123;\n        this.a = a;\n        this.b = b;\n        console.log('Example');\n    &#125;\n    sum() &#123;\n        return this.a + this.b;\n    &#125;\n&#125;\nlet exam1 = new Example(2, 1);\nlet exam2 = new Example(3, 1);\n \n// __proto__ 已废弃，不建议使用\n// console.log(exam1.__proto__ == exam2.__proto__); \n \nconsole.log(Object.getPrototypeOf(exam1) === Object.getPrototypeOf(exam2));// true\n \nObject.getPrototypeOf(exam1).sub = function() &#123;\n    return this.a - this.b;\n&#125;\nconsole.log(exam1.sub()); // 1\nconsole.log(exam2.sub()); // 2\n</code></pre>\n<h2 id=\"decorator\"><a class=\"anchor\" href=\"#decorator\">#</a> decorator</h2>\n<p>decorator 是一个函数，用来修改类的行为，在代码编译时产生作用。</p>\n<h3 id=\"类修饰\"><a class=\"anchor\" href=\"#类修饰\">#</a> 类修饰</h3>\n<p>一个参数</p>\n<p>第一个参数 target，指向类本身</p>\n<pre><code>function testable(target) &#123;\n    target.isTestable = true;\n&#125;\n@testable\nclass Example &#123;&#125;\nExample.isTestable; // true\n</code></pre>\n<p>多个参数 —— 嵌套实现</p>\n<pre><code>function testable(isTestable) &#123;\n    return function(target) &#123;\n        target.isTestable=isTestable;\n    &#125;\n&#125;\n@testable(true)\nclass Example &#123;&#125;\nExample.isTestable; // true\n</code></pre>\n<p>实例属性</p>\n<p>上面两个例子添加的是静态属性，若要添加实例属性，在类的 prototype 上操作即可。</p>\n<h3 id=\"方法修饰\"><a class=\"anchor\" href=\"#方法修饰\">#</a> 方法修饰</h3>\n<p>3 个参数：target（类的原型对象）、name（修饰的属性名）、descriptor（该属性的描述对象）</p>\n<pre><code>class Example &#123;\n    @writable\n    sum(a, b) &#123;\n        return a + b;\n    &#125;\n&#125;\nfunction writable(target, name, descriptor) &#123;\n    descriptor.writable = false;\n    return descriptor; // 必须返回\n&#125;\n</code></pre>\n<p>修饰器执行顺序</p>\n<p>由外向内进入，由内向外执行</p>\n<pre><code>class Example &#123;\n    @logMethod(1)\n    @logMethod(2)\n    sum(a, b)&#123;\n        return a + b;\n    &#125;\n&#125;\nfunction logMethod(id) &#123;\n    console.log('evaluated logMethod'+id);\n    return (target, name, desctiptor) =&gt; console.log('excuted         logMethod '+id);\n&#125;\n// evaluated logMethod 1\n// evaluated logMethod 2\n// excuted logMethod 2\n// excuted logMethod 1\n</code></pre>\n<h2 id=\"封装与继承\"><a class=\"anchor\" href=\"#封装与继承\">#</a> 封装与继承</h2>\n<h3 id=\"getter-setter\"><a class=\"anchor\" href=\"#getter-setter\">#</a> getter / setter</h3>\n<p>定义</p>\n<pre><code>class Example&#123;\n    constructor(a, b) &#123;\n        this.a = a; // 实例化时调用 set 方法\n        this.b = b;\n    &#125;\n    get a()&#123;\n        console.log('getter');\n        return this.a;\n    &#125;\n    set a(a)&#123;\n        console.log('setter');\n        this.a = a; // 自身递归调用\n    &#125;\n&#125;\nlet exam = new Example(1,2); // 不断输出 setter ，最终导致 RangeError\nclass Example1&#123;\n    constructor(a, b) &#123;\n        this.a = a;\n        this.b = b;\n    &#125;\n    get a()&#123;\n        console.log('getter');\n        return this._a;\n    &#125;\n    set a(a)&#123;\n        console.log('setter');\n        this._a = a;\n    &#125;\n&#125;\nlet exam1 = new Example1(1,2); // 只输出 setter , 不会调用 getter 方法\nconsole.log(exam1._a); // 1, 可以直接访问\n</code></pre>\n<p>getter 不可单独出现</p>\n<pre><code>class Example &#123;\n    constructor(a) &#123;\n        this.a = a; \n    &#125;\n    get a() &#123;\n        return this.a;\n    &#125;\n&#125;\nlet exam = new Example(1); // Uncaught TypeError: Cannot set property // a of #&lt;Example&gt; which has only a getter\n</code></pre>\n<p>getter 与 setter 必须同级出现</p>\n<pre><code>class Father &#123;\n    constructor()&#123;&#125;\n    get a() &#123;\n        return this._a;\n    &#125;\n&#125;\nclass Child extends Father &#123;\n    constructor()&#123;\n        super();\n    &#125;\n    set a(a) &#123;\n        this._a = a;\n    &#125;\n&#125;\nlet test = new Child();\ntest.a = 2;\nconsole.log(test.a); // undefined\n \nclass Father1 &#123;\n    constructor()&#123;&#125;\n    // 或者都放在子类中\n    get a() &#123;\n        return this._a;\n    &#125;\n    set a(a) &#123;\n        this._a = a;\n    &#125;\n&#125;\nclass Child1 extends Father1 &#123;\n    constructor()&#123;\n        super();\n    &#125;\n&#125;\nlet test1 = new Child1();\ntest1.a = 2;\nconsole.log(test1.a); // 2\n</code></pre>\n<h3 id=\"extends\"><a class=\"anchor\" href=\"#extends\">#</a> extends</h3>\n<p>通过 extends 实现类的继承</p>\n<pre><code>class Child extends Father &#123; ... &#125;\n</code></pre>\n<h3 id=\"super\"><a class=\"anchor\" href=\"#super\">#</a> super</h3>\n<p>子类 constructor 方法中必须有 super ，且必须出现在 this 之前</p>\n<pre><code>class Father &#123;\n    constructor() &#123;&#125;\n&#125;\nclass Child extends Father &#123;\n    constructor() &#123;&#125;\n    // or \n    // constructor(a) &#123;\n        // this.a = a;\n        // super();\n    // &#125;\n&#125;\nlet test = new Child(); // Uncaught ReferenceError: Must call super \n// constructor in derived class before accessing 'this' or returning \n// from derived constructor\n</code></pre>\n<p>调用父类构造函数，只能出现在子类的构造函数</p>\n<pre><code>class Father &#123;\n    test()&#123;\n        return 0;\n    &#125;\n    static test1()&#123;\n        return 1;\n    &#125;\n&#125;\nclass Child extends Father &#123;\n    constructor()&#123;\n        super();\n    &#125;\n&#125;\nclass Child1 extends Father &#123;\n    test2() &#123;\n        super(); // Uncaught SyntaxError: 'super' keyword unexpected     \n        // here\n    &#125;\n&#125;\n</code></pre>\n<p>调用父类方法，super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类</p>\n<pre><code>class Child2 extends Father &#123;\n    constructor()&#123;\n        super();\n        // 调用父类普通方法\n        console.log(super.test()); // 0\n    &#125;\n    static test3()&#123;\n        // 调用父类静态方法\n        return super.test1+2;\n    &#125;\n&#125;\nChild2.test3(); // 3\n</code></pre>\n<h3 id=\"注意要点-2\"><a class=\"anchor\" href=\"#注意要点-2\">#</a> 注意要点</h3>\n<p>不可继承常规对象</p>\n<pre><code>var Father = &#123;\n    // ...\n&#125;\nclass Child extends Father &#123;\n     // ...\n&#125;\n// Uncaught TypeError: Class extends value #&lt;Object&gt; is not a constructor or null\n \n// 解决方案\nObject.setPrototypeOf(Child.prototype, Father);\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%87%BD%E6%95%B0/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%87%BD%E6%95%B0/",
            "title": "",
            "date_published": "2022-05-26T02:43:13.789Z",
            "content_html": "<h2 id=\"函数参数的扩展\"><a class=\"anchor\" href=\"#函数参数的扩展\">#</a> 函数参数的扩展</h2>\n<h3 id=\"默认参数\"><a class=\"anchor\" href=\"#默认参数\">#</a> 默认参数</h3>\n<p>基本用法</p>\n<pre><code>function fn(name,age=17)&#123;\n console.log(name+&quot;,&quot;+age);\n&#125;\nfn(&quot;Amy&quot;,18);  // Amy,18\nfn(&quot;Amy&quot;,&quot;&quot;);  // Amy,\nfn(&quot;Amy&quot;);     // Amy,17\n</code></pre>\n<p>注意点：使用函数默认参数时，不允许有同名参数</p>\n<pre><code>// 不报错\nfunction fn(name,name)&#123;\n console.log(name);\n&#125;\n \n// 报错\n//SyntaxError: Duplicate parameter name not allowed in this context\nfunction fn(name,name,age=17)&#123;\n console.log(name+&quot;,&quot;+age);\n&#125;\n</code></pre>\n<p>只有在未传递参数，或者参数为 undefined 时，才会使用默认参数，null 值被认为是有效的值传递</p>\n<pre><code>function fn(name,age=17)&#123;\n    console.log(name+&quot;,&quot;+age);\n&#125;\nfn(&quot;Amy&quot;,null); // Amy,null\n</code></pre>\n<p>函数参数默认值存在暂时性死区，在函数参数默认值表达式中，还未初始化赋值的参数值无法作为其他参数的默认值</p>\n<pre><code>function f(x,y=x)&#123;\n    console.log(x,y);\n&#125;\nf(1);  // 1 1\n \nfunction f(x=y)&#123;\n    console.log(x);\n&#125;\nf();  // ReferenceError: y is not defined\n</code></pre>\n<h3 id=\"不定参数\"><a class=\"anchor\" href=\"#不定参数\">#</a> 不定参数</h3>\n<p>不定参数用来表示不确定参数个数，形如，... 变量名，由... 加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。</p>\n<p>基本用法</p>\n<pre><code>function f(...values)&#123;\n    console.log(values.length);\n&#125;\nf(1,2);      //2\nf(1,2,3,4);  //4\n</code></pre>\n<h2 id=\"箭头函数\"><a class=\"anchor\" href=\"#箭头函数\">#</a> 箭头函数</h2>\n<p>箭头函数提供了一种更加简洁的函数书写方式。基本语法是</p>\n<pre><code>参数 =&gt; 函数体\n</code></pre>\n<p>基本用法</p>\n<pre><code>var f = v =&gt; v;\n//等价于\nvar f = function(a)&#123;\n return a;\n&#125;\nf(1);  //1\n</code></pre>\n<p>当箭头函数没有参数或者有多个参数，要用 <strong>()</strong> 括起来</p>\n<pre><code>var f = (a,b) =&gt; a+b;\nf(6,2);  //8\n</code></pre>\n<p>当箭头函数函数体有多行语句，用 <strong>{}</strong> 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 <strong>{}</strong> , 结果会自动返回</p>\n<pre><code>var f = (a,b) =&gt; &#123;\n let result = a+b;\n return result;\n&#125;\nf(6,2);  // 8\n</code></pre>\n<p>当箭头函数要返回对象的时候，为了区分于代码块，要用 <strong>()</strong> 将对象包裹起来</p>\n<pre><code>// 报错\nvar f = (id,name) =&gt; &#123;id: id, name: name&#125;;\nf(6,2);  // SyntaxError: Unexpected token :\n \n// 不报错\nvar f = (id,name) =&gt; (&#123;id: id, name: name&#125;);\nf(6,2);  // &#123;id: 6, name: 2&#125;\n</code></pre>\n<p>注意点：没有 this、super、arguments 和 new.target 绑定</p>\n<pre><code>var func = () =&gt; &#123;\n  // 箭头函数里面没有 this 对象，\n  // 此时的 this 是外层的 this 对象，即 Window \n  console.log(this)\n&#125;\nfunc(55)  // Window \n \nvar func = () =&gt; &#123;    \n  console.log(arguments)\n&#125;\nfunc(55);  // ReferenceError: arguments is not defined\n</code></pre>\n<p>箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象</p>\n<pre><code>function fn()&#123;\n  setTimeout(()=&gt;&#123;\n    // 定义时，this 绑定的是 fn 中的 this 对象\n    console.log(this.a);\n  &#125;,0)\n&#125;\nvar a = 20;\n// fn 的 this 对象为 &#123;a: 18&#125;\nfn.call(&#123;a: 18&#125;);  // 18\n</code></pre>\n<p>不可以作为构造函数，也就是不能使用 new 命令，否则会报错</p>\n<h3 id=\"适合使用的场景\"><a class=\"anchor\" href=\"#适合使用的场景\">#</a> 适合使用的场景</h3>\n<p>ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。</p>\n<pre><code>// 回调函数\nvar Person = &#123;\n    'age': 18,\n    'sayHello': function () &#123;\n      setTimeout(function () &#123;\n        console.log(this.age);\n      &#125;);\n    &#125;\n&#125;;\nvar age = 20;\nPerson.sayHello();  // 20\n \nvar Person1 = &#123;\n    'age': 18,\n    'sayHello': function () &#123;\n      setTimeout(()=&gt;&#123;\n        console.log(this.age);\n      &#125;);\n    &#125;\n&#125;;\nvar age = 20;\nPerson1.sayHello();  // 18\n</code></pre>\n<p>所以，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。</p>\n<h3 id=\"不适合使用的场景\"><a class=\"anchor\" href=\"#不适合使用的场景\">#</a> 不适合使用的场景</h3>\n<p>定义函数的方法，且该方法中包含 this</p>\n<pre><code>var Person = &#123;\n    'age': 18,\n    'sayHello': ()=&gt;&#123;\n        console.log(this.age);\n      &#125;\n&#125;;\nvar age = 20;\nPerson.sayHello();  // 20\n// 此时 this 指向的是全局对象\n \nvar Person1 = &#123;\n    'age': 18,\n    'sayHello': function () &#123;\n        console.log(this.age);\n    &#125;\n&#125;;\nvar age = 20;\nPerson1.sayHello();   // 18\n// 此时的 this 指向 Person1 对象\n</code></pre>\n<p>需要动态 this 的时候</p>\n<pre><code>var button = document.getElementById('userClick');\nbutton.addEventListener('click', () =&gt; &#123;\n     this.classList.toggle('on');\n&#125;);\n</code></pre>\n<p>button 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象。</p>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E7%BB%84/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E7%BB%84/",
            "title": "",
            "date_published": "2022-05-26T02:43:10.552Z",
            "content_html": "<h2 id=\"数组创建\"><a class=\"anchor\" href=\"#数组创建\">#</a> 数组创建</h2>\n<h3 id=\"arrayof\"><a class=\"anchor\" href=\"#arrayof\">#</a> Array.of()</h3>\n<p>将参数中所有值作为元素形成数组</p>\n<pre><code>console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]\n \n// 参数值可为不同类型\nconsole.log(Array.of(1, '2', true)); // [1, '2', true]\n \n// 参数为空时返回空数组\nconsole.log(Array.of()); // []\n</code></pre>\n<h3 id=\"arrayfrom\"><a class=\"anchor\" href=\"#arrayfrom\">#</a> Array.from()</h3>\n<p>将类数组对象或可迭代对象转化为数组。</p>\n<pre><code>// 参数为数组,返回与原数组一样的数组\nconsole.log(Array.from([1, 2])); // [1, 2]\n \n// 参数含空位\nconsole.log(Array.from([1, , 3])); // [1, undefined, 3]\n</code></pre>\n<p><strong>参数</strong></p>\n<pre><code>Array.from(arrayLike[, mapFn[, thisArg]])\n</code></pre>\n<p>返回值为转换后的数组。</p>\n<p><strong>arrayLike</strong></p>\n<p>想要转换的类数组对象或可迭代对象。</p>\n<pre><code>console.log(Array.from([1, 2, 3])); // [1, 2, 3]\n</code></pre>\n<p><strong>mapFn</strong></p>\n<p>可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素。</p>\n<pre><code>console.log(Array.from([1, 2, 3], (n) =&gt; n * 2)); // [2, 4, 6]\n</code></pre>\n<p><strong>thisArg</strong></p>\n<p>可选，用于指定 map 函数执行时的 this 对象。</p>\n<pre><code>let map = &#123;\n    do: function(n) &#123;\n        return n * 2;\n    &#125;\n&#125;\nlet arrayLike = [1, 2, 3];\nconsole.log(Array.from(arrayLike, function (n)&#123;\n    return this.do(n);\n&#125;, map)); // [2, 4, 6]\n</code></pre>\n<h3 id=\"类数组对象\"><a class=\"anchor\" href=\"#类数组对象\">#</a> 类数组对象</h3>\n<p>一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符</p>\n<pre><code>let arr = Array.from(&#123;\n  0: '1',\n  1: '2',\n  2: 3,\n  length: 3\n&#125;);\nconsole.log(arr); // ['1', '2', 3]\n \n// 没有 length 属性,则返回空数组\nlet array = Array.from(&#123;\n  0: '1',\n  1: '2',\n  2: 3,\n&#125;);\nconsole.log(array); // []\n \n// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  \nlet array1 = Array.from(&#123;\n  a: 1,\n  b: 2,\n  length: 2\n&#125;);\nconsole.log(array1); // [undefined, undefined]\n</code></pre>\n<h3 id=\"转换可迭代对象\"><a class=\"anchor\" href=\"#转换可迭代对象\">#</a> 转换可迭代对象</h3>\n<p><strong>转换 map</strong></p>\n<pre><code>let map = new Map();\nmap.set('key0', 'value0');\nmap.set('key1', 'value1');\nconsole.log(Array.from(map)); // [['key0', 'value0'],['key1',\n// 'value1']]\n</code></pre>\n<p><strong>转换 set</strong></p>\n<pre><code>let arr = [1, 2, 3];\nlet set = new Set(arr);\nconsole.log(Array.from(set)); // [1, 2, 3]\n</code></pre>\n<p><strong>转换字符串</strong></p>\n<pre><code>let str = 'abc';\nconsole.log(Array.from(str)); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n</code></pre>\n<h2 id=\"扩展的方法\"><a class=\"anchor\" href=\"#扩展的方法\">#</a> 扩展的方法</h2>\n<h3 id=\"查找\"><a class=\"anchor\" href=\"#查找\">#</a> 查找</h3>\n<p><strong>find()</strong></p>\n<p>查找数组中符合条件的元素，若有多个符合条件的元素，则返回第一个元素。</p>\n<pre><code>let arr = Array.of(1, 2, 3, 4);\nconsole.log(arr.find(item =&gt; item &gt; 2)); // 3\n \n// 数组空位处理为 undefined\nconsole.log([, 1].find(n =&gt; true)); // undefined\n</code></pre>\n<p><strong>findIndex()</strong></p>\n<p>查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。</p>\n<pre><code>let arr = Array.of(1, 2, 1, 3);\n// 参数1：回调函数\n// 参数2(可选)：指定回调函数中的 this 值\nconsole.log(arr.findIndex(item =&gt; item == 2)); // 1\n \n// 数组空位处理为 undefined\nconsole.log([, 1].findIndex(n =&gt; true)); //0\n</code></pre>\n<h3 id=\"填充\"><a class=\"anchor\" href=\"#填充\">#</a> 填充</h3>\n<p><strong>fill()</strong></p>\n<p>将一定范围索引的数组元素内容填充为单个指定的值。</p>\n<pre><code>let arr = Array.of(1, 2, 3, 4);\n// 参数1：用来填充的值\n// 参数2：被填充的起始索引\n// 参数3(可选)：被填充的结束索引，默认为数组末尾\nconsole.log(arr.fill(0,1,2)); // [1, 0, 3, 4]\n</code></pre>\n<p><strong>copyWithin()</strong></p>\n<p>将一定范围索引的数组元素修改为此数组另一指定范围索引的元素。</p>\n<pre><code>// 参数1：被修改的起始索引\n// 参数2：被用来覆盖的数据的起始索引\n// 参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾\nconsole.log([1, 2, 3, 4].copyWithin(0,2,4)); // [3, 4, 3, 4]\n \n// 参数1为负数表示倒数\nconsole.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1, 2, 1, 2]\n \nconsole.log([1, 2, ,4].copyWithin(0, 2, 4)); // [, 4, , 4]\n</code></pre>\n<h3 id=\"遍历\"><a class=\"anchor\" href=\"#遍历\">#</a> 遍历</h3>\n<p><strong>entries()</strong></p>\n<p>遍历键值对</p>\n<pre><code>for(let [key, value] of ['a', 'b'].entries())&#123;\n    console.log(key, value);\n&#125;\n// 0 &quot;a&quot;\n// 1 &quot;b&quot;\n \n// 不使用 for... of 循环\nlet entries = ['a', 'b'].entries();\nconsole.log(entries.next().value); // [0, &quot;a&quot;]\nconsole.log(entries.next().value); // [1, &quot;b&quot;]\n \n// 数组含空位\nconsole.log([...[,'a'].entries()]); // [[0, undefined], [1, &quot;a&quot;]]\n</code></pre>\n<p><strong>keys()</strong></p>\n<p>遍历键名。</p>\n<pre><code>for(let key of ['a', 'b'].keys())&#123;\n    console.log(key);\n&#125;\n// 0\n// 1\n \n// 数组含空位\nconsole.log([...[,'a'].keys()]); // [0, 1]\n</code></pre>\n<p><strong>values()</strong></p>\n<p>遍历键值。</p>\n<pre><code>for(let value of ['a', 'b'].values())&#123;\n    console.log(value);\n&#125;\n// &quot;a&quot;\n// &quot;b&quot;\n \n// 数组含空位\nconsole.log([...[,'a'].values()]); // [undefined, &quot;a&quot;]\n</code></pre>\n<h3 id=\"包含\"><a class=\"anchor\" href=\"#包含\">#</a> 包含</h3>\n<p><strong>includes()</strong></p>\n<p>数组是否包含指定值。</p>\n<p>注意：与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值；Map 的 has 方法用于查找键名</p>\n<pre><code>// 参数1：包含的指定值\n[1, 2, 3].includes(1);    // true\n \n// 参数2：可选，搜索的起始索引，默认为0\n[1, 2, 3].includes(1, 2); // false\n \n// NaN 的包含判断\n[1, NaN, 3].includes(NaN); // true\n</code></pre>\n<h3 id=\"嵌套数组转一维数组\"><a class=\"anchor\" href=\"#嵌套数组转一维数组\">#</a> 嵌套数组转一维数组</h3>\n<p><strong>flat()</strong></p>\n<pre><code>console.log([1 ,[2, 3]].flat()); // [1, 2, 3]\n \n// 指定转换的嵌套层数\nconsole.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]]\n \n// 不管嵌套多少层\nconsole.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]\n \n// 自动跳过空位\nconsole.log([1, [2, , 3]].flat());&lt;p&gt; // [1, 2, 3]\n</code></pre>\n<p><strong>flatMap()</strong></p>\n<p>先对数组中每个元素进行了的处理，再对数组执行 flat () 方法</p>\n<pre><code>// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组\n// 参数2：指定遍历函数中 this 的指向\nconsole.log([1, 2, 3].flatMap(n =&gt; [n * 2])); // [2, 4, 6]\n</code></pre>\n<h2 id=\"数组缓冲区\"><a class=\"anchor\" href=\"#数组缓冲区\">#</a> 数组缓冲区</h2>\n<p>数组缓冲区是内存中的一段地址。</p>\n<p>定型数组的基础。</p>\n<p>实际字节数在创建时确定，之后只可修改其中的数据，不可修改大小。</p>\n<h3 id=\"创建数组缓冲区\"><a class=\"anchor\" href=\"#创建数组缓冲区\">#</a> 创建数组缓冲区</h3>\n<p>通过构造函数创建:</p>\n<pre><code>let buffer = new ArrayBuffer(10);\nconsole.log(buffer.byteLength); // 10\n分割已有数组缓冲区\nlet buffer = new ArrayBuffer(10);\nlet buffer1 = buffer.slice(1, 3);\nconsole.log(buffer1.byteLength); // 2\n</code></pre>\n<h3 id=\"视图\"><a class=\"anchor\" href=\"#视图\">#</a> 视图</h3>\n<p>视图是用来操作内存的接口。</p>\n<p>视图可以操作数组缓冲区或缓冲区字节的子集，并按照其中一种数值数据类型来读取和写入数据。</p>\n<p>DataView 类型是一种通用的数组缓冲区视图，其支持所有 8 种数值型数据类型。</p>\n<p>创建:</p>\n<pre><code>// 默认 DataView 可操作数组缓冲区全部内容\nlet buffer = new ArrayBuffer(10);\n    dataView = new DataView(buffer); \ndataView.setInt8(0,1);\nconsole.log(dataView.getInt8(0)); // 1\n \n// 通过设定偏移量(参数2)与长度(参数3)指定 DataView 可操作的字节范围\nlet buffer1 = new ArrayBuffer(10);\n    dataView1 = new DataView(buffer1, 0, 3);\ndataView1.setInt8(5,1); // RangeError\n</code></pre>\n<h2 id=\"定型数组\"><a class=\"anchor\" href=\"#定型数组\">#</a> 定型数组</h2>\n<p>数组缓冲区的特定类型的视图。</p>\n<p>可以强制使用特定的数据类型，而不是使用通用的 DataView 对象来操作数组缓冲区。</p>\n<h3 id=\"创建\"><a class=\"anchor\" href=\"#创建\">#</a> 创建</h3>\n<p>通过数组缓冲区生成</p>\n<pre><code>let buffer = new ArrayBuffer(10),\n    view = new Int8Array(buffer);\nconsole.log(view.byteLength); // 10\n</code></pre>\n<p>通过构造函数</p>\n<pre><code>let view = new Int32Array(10);\nconsole.log(view.byteLength); // 40\nconsole.log(view.length);     // 10\n \n// 不传参则默认长度为0\n// 在这种情况下数组缓冲区分配不到空间，创建的定型数组不能用来保存数据\nlet view1 = new Int32Array();\nconsole.log(view1.byteLength); // 0\nconsole.log(view1.length);     // 0\n \n// 可接受参数包括定型数组、可迭代对象、数组、类数组对象\nlet arr = Array.from(&#123;\n  0: '1',\n  1: '2',\n  2: 3,\n  length: 3\n&#125;);\nlet view2 = new Int16Array([1, 2]),\n    view3 = new Int32Array(view2),\n    view4 = new Int16Array(new Set([1, 2, 3])),\n    view5 = new Int16Array([1, 2, 3]),\n    view6 = new Int16Array(arr);\nconsole.log(view2 .buffer === view3.buffer); // false\nconsole.log(view4.byteLength); // 6\nconsole.log(view5.byteLength); // 6\nconsole.log(view6.byteLength); // 6\n</code></pre>\n<h3 id=\"注意要点\"><a class=\"anchor\" href=\"#注意要点\">#</a> 注意要点</h3>\n<p>length 属性不可写，如果尝试修改这个值，在非严格模式下会直接忽略该操作，在严格模式下会抛出错误</p>\n<pre><code>let view = new Int16Array([1, 2]);\nview.length = 3;\nconsole.log(view.length); // 2\n</code></pre>\n<p>定型数组可使用 entries ()、keys ()、values () 进行迭代</p>\n<pre><code>let view = new Int16Array([1, 2]);\nfor(let [k, v] of view.entries())&#123;\n    console.log(k, v);\n&#125;\n// 0 1\n// 1 2\n</code></pre>\n<p>find () 等方法也可用于定型数组，但是定型数组中的方法会额外检查数值类型是否安全，也会通过 Symbol.species 确认方法的返回值是定型数组而非普通数组。concat () 方法由于两个定型数组合并结果不确定，故不能用于定型数组；另外，由于定型数组的尺寸不可更改，可以改变数组的尺寸的方法，例如 splice () ，不适用于定型数组。</p>\n<pre><code>let view = new Int16Array([1, 2]);\nview.find((n) &gt; 1); // 2\n</code></pre>\n<p>所有定型数组都含有静态 of () 方法和 from () 方法，运行效果分别与 Array.of () 方法和 Array.from () 方法相似，区别是定型数组的方法返回定型数组，而普通数组的方法返回普通数组。</p>\n<pre><code>let view = Int16Array.of(1, 2);\nconsole.log(view instanceof Int16Array); // true\n</code></pre>\n<p>定型数组不是普通数组，不继承自 Array</p>\n<pre><code>let view = new Int16Array([1, 2]);\nconsole.log(Array.isArray(view)); // false\n</code></pre>\n<p>定型数组中增加了 set () 与 subarray () 方法。 set () 方法用于将其他数组复制到已有定型数组，subarray () 用于提取已有定型数组的一部分形成新的定型数组。</p>\n<pre><code>// set 方法\n// 参数1：一个定型数组或普通数组\n// 参数2：可选，偏移量，开始插入数据的位置，默认为0\nlet view= new Int16Array(4);\nview.set([1, 2]);\nview.set([3, 4], 2);\nconsole.log(view); // [1, 2, 3, 4]\n \n// subarray 方法\n// 参数1：可选，开始位置\n// 参数2：可选，结束位置(不包含结束位置)\nlet view= new Int16Array([1, 2, 3, 4]), \n    subview1 = view.subarray(), \n    subview2 = view.subarray(1), \n    subview3 = view.subarray(1, 3);\nconsole.log(subview1); // [1, 2, 3, 4]\nconsole.log(subview2); // [2, 3, 4]\nconsole.log(subview3); // [2, 3]\n</code></pre>\n<h2 id=\"扩展运算符\"><a class=\"anchor\" href=\"#扩展运算符\">#</a> 扩展运算符</h2>\n<h3 id=\"复制数组\"><a class=\"anchor\" href=\"#复制数组\">#</a> 复制数组</h3>\n<pre><code>let arr = [1, 2],\n    arr1 = [...arr];\nconsole.log(arr1); // [1, 2]\n \n// 数组含空位\nlet arr2 = [1, , 3],\n    arr3 = [...arr2];\nconsole.log(arr3); [1, undefined, 3]\n</code></pre>\n<p>合并数组</p>\n<pre><code>console.log([...[1, 2],...[3, 4]]); // [1, 2, 3, 4]\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AF%B9%E8%B1%A1/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AF%B9%E8%B1%A1/",
            "title": "",
            "date_published": "2022-05-26T02:43:07.644Z",
            "content_html": "<h2 id=\"对象字面量\"><a class=\"anchor\" href=\"#对象字面量\">#</a> 对象字面量</h2>\n<h3 id=\"属性的简洁表示法\"><a class=\"anchor\" href=\"#属性的简洁表示法\">#</a> 属性的简洁表示法</h3>\n<p>ES6 允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。</p>\n<pre><code>const age = 12;\nconst name = &quot;Amy&quot;;\nconst person = &#123;age, name&#125;;\nperson   //&#123;age: 12, name: &quot;Amy&quot;&#125;\n//等同于\nconst person = &#123;age: age, name: name&#125;\n</code></pre>\n<h3 id=\"方法名也可以简写\"><a class=\"anchor\" href=\"#方法名也可以简写\">#</a> 方法名也可以简写</h3>\n<pre><code>const person = &#123;\n  sayHi()&#123;\n    console.log(&quot;Hi&quot;);\n  &#125;\n&#125;\nperson.sayHi();  //&quot;Hi&quot;\n//等同于\nconst person = &#123;\n  sayHi:function()&#123;\n    console.log(&quot;Hi&quot;);\n  &#125;\n&#125;\nperson.sayHi();//&quot;Hi&quot;\n</code></pre>\n<p>如果是 Generator 函数，则要在前面加一个星号</p>\n<pre><code>const obj = &#123;\n  * myGenerator() &#123;\n    yield 'hello world';\n  &#125;\n&#125;;\n//等同于\nconst obj = &#123;\n  myGenerator: function* () &#123;\n    yield 'hello world';\n  &#125;\n&#125;;\n</code></pre>\n<h3 id=\"属性名表达式\"><a class=\"anchor\" href=\"#属性名表达式\">#</a> 属性名表达式</h3>\n<p>ES6 允许用表达式作为属性名，但是一定要将表达式放在方括号内</p>\n<pre><code>const obj = &#123;\n [&quot;he&quot;+&quot;llo&quot;]()&#123;\n   return &quot;Hi&quot;;\n  &#125;\n&#125;\nobj.hello();  //&quot;Hi&quot;\n</code></pre>\n<p>注意点：属性的简洁表示法和属性名表达式不能同时使用，否则会报错</p>\n<pre><code>const hello = &quot;Hello&quot;;\nconst obj = &#123;\n [hello]\n&#125;;\nobj  //SyntaxError: Unexpected token &#125;\n \nconst hello = &quot;Hello&quot;;\nconst obj = &#123;\n [hello+&quot;2&quot;]:&quot;world&quot;\n&#125;;\nobj  //&#123;Hello2: &quot;world&quot;&#125;\n</code></pre>\n<h2 id=\"对象的拓展运算符\"><a class=\"anchor\" href=\"#对象的拓展运算符\">#</a> 对象的拓展运算符</h2>\n<p>拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象。</p>\n<h3 id=\"基本用法\"><a class=\"anchor\" href=\"#基本用法\">#</a> 基本用法</h3>\n<pre><code>let person = &#123;name: &quot;Amy&quot;, age: 15&#125;;\nlet someone = &#123; ...person &#125;;\nsomeone;  //&#123;name: &quot;Amy&quot;, age: 15&#125;\n</code></pre>\n<h3 id=\"可用于合并两个对象\"><a class=\"anchor\" href=\"#可用于合并两个对象\">#</a> 可用于合并两个对象</h3>\n<pre><code>let age = &#123;age: 15&#125;;\nlet name = &#123;name: &quot;Amy&quot;&#125;;\nlet person = &#123;...age, ...name&#125;;\nperson;  //&#123;age: 15, name: &quot;Amy&quot;&#125;\n</code></pre>\n<h3 id=\"注意点\"><a class=\"anchor\" href=\"#注意点\">#</a> 注意点</h3>\n<p>自定义的属性和拓展运算符对象里面属性的相同的时候：<strong>自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。</strong></p>\n<pre><code>let person = &#123;name: &quot;Amy&quot;, age: 15&#125;;\nlet someone = &#123; ...person, name: &quot;Mike&quot;, age: 17&#125;;\nsomeone;  //&#123;name: &quot;Mike&quot;, age: 17&#125;\n</code></pre>\n<p>自定义的属性在拓展运算度前面，则变成设置新对象默认属性值。</p>\n<pre><code>let person = &#123;name: &quot;Amy&quot;, age: 15&#125;;\nlet someone = &#123;name: &quot;Mike&quot;, age: 17, ...person&#125;;\nsomeone;  //&#123;name: &quot;Amy&quot;, age: 15&#125;\n</code></pre>\n<p>拓展运算符后面是空对象，没有任何效果也不会报错。</p>\n<pre><code>let a = &#123;...&#123;&#125;, a: 1, b: 2&#125;;\na;  //&#123;a: 1, b: 2&#125;\n</code></pre>\n<p>拓展运算符后面是 null 或者 undefined，没有效果也不会报错</p>\n<pre><code>let b = &#123;...null, ...undefined, a: 1, b: 2&#125;;\nb;  //&#123;a: 1, b: 2&#125;\n</code></pre>\n<h2 id=\"对象的新方法\"><a class=\"anchor\" href=\"#对象的新方法\">#</a> 对象的新方法</h2>\n<h3 id=\"objectassigntarget-source_1\"><a class=\"anchor\" href=\"#objectassigntarget-source_1\">#</a> Object.assign(target, source_1, ···)</h3>\n<p>用于将源对象的所有可枚举属性复制到目标对象中。</p>\n<p><strong>基本用法</strong></p>\n<pre><code>let target = &#123;a: 1&#125;;\nlet object2 = &#123;b: 2&#125;;\nlet object3 = &#123;c: 3&#125;;\nObject.assign(target,object2,object3);  \n// 第一个参数是目标对象，后面的参数是源对象\ntarget;  // &#123;a: 1, b: 2, c: 3\n</code></pre>\n<ul>\n<li>\n<p>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>\n</li>\n<li>\n<p>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</p>\n<pre><code>Object.assign(3);         // Number &#123;3&#125;\ntypeof Object.assign(3);  // &quot;object&quot;\n</code></pre>\n</li>\n</ul>\n<p>因为 null 和 undefined 不能转化为对象，所以会报错</p>\n<pre><code>Object.assign(null);       // TypeError: Cannot convert undefined or null to object\nObject.assign(undefined);  // TypeError: Cannot convert undefined or null to object\n当参数不止一个时，null 和 undefined 不放第一个，即不为目标对象时，会跳过 null 和 undefined ，不报错\nObject.assign(1,undefined);  // Number &#123;1&#125;\nObject.assign(&#123;a: 1&#125;,null);  // &#123;a: 1&#125;\n \nObject.assign(undefined,&#123;a: 1&#125;);  // TypeError: Cannot convert undefined or null to object\n</code></pre>\n<p><strong>注意点</strong></p>\n<p>assign 的属性拷贝是浅拷贝:</p>\n<pre><code>let sourceObj = &#123; a: &#123; b: 1&#125;&#125;;\nlet targetObj = &#123;c: 3&#125;;\nObject.assign(targetObj, sourceObj);\ntargetObj.a.b = 2;\nsourceObj.a.b;  // 2\n</code></pre>\n<p>同名属性替换</p>\n<pre><code>targetObj = &#123; a: &#123; b: 1, c:2&#125;&#125;;\nsourceObj = &#123; a: &#123; b: &quot;hh&quot;&#125;&#125;;\nObject.assign(targetObj, sourceObj);\ntargetObj;  // &#123;a: &#123;b: &quot;hh&quot;&#125;&#125;\n</code></pre>\n<p>数组的处理</p>\n<pre><code>Object.assign([2,3], [5]);  // [5,3]\n</code></pre>\n<p>会将数组处理成对象，所以先将 [2,3] 转为 {0:2,1:3} ，然后再进行属性复制，所以源对象的 0 号属性覆盖了目标对象的 0。</p>\n<h3 id=\"objectis\"><a class=\"anchor\" href=\"#objectis\">#</a> <span class=\"exturl\" data-url=\"aHR0cDovL09iamVjdC5pcw==\">Object.is</span>(value1, value2)</h3>\n<p>用来比较两个值是否严格相等，与（===）基本类似。</p>\n<p><strong>基本用法</strong></p>\n<pre><code>Object.is(&quot;q&quot;,&quot;q&quot;);      // true\nObject.is(1,1);          // true\nObject.is([1],[1]);      // false\nObject.is(&#123;q:1&#125;,&#123;q:1&#125;);  // false\n</code></pre>\n<p>与（===）的区别</p>\n<pre><code>//一是+0不等于-0\nObject.is(+0,-0);  //false\n+0 === -0  //true\n//二是NaN等于本身\nObject.is(NaN,NaN); //true\nNaN === NaN  //false\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E5%80%BC/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E5%80%BC/",
            "title": "",
            "date_published": "2022-05-26T02:43:04.362Z",
            "content_html": "<h2 id=\"数值的表示\"><a class=\"anchor\" href=\"#数值的表示\">#</a> 数值的表示</h2>\n<p>二进制表示法新写法：前缀 0b 或 0B 。</p>\n<pre><code>console.log(0b11 === 3); // true\nconsole.log(0B11 === 3); // true\n</code></pre>\n<p>八进制表示法新写法：前缀 0o 或 0O 。</p>\n<pre><code>console.log(0o11 === 9); // true\nconsole.log(0O11 === 9); // true\n</code></pre>\n<h3 id=\"常量\"><a class=\"anchor\" href=\"#常量\">#</a> 常量</h3>\n<pre><code>Number.EPSILON\n</code></pre>\n<p>Number.EPSILON 属性表示 1 与大于 1 的最小浮点数之间的差。</p>\n<p>它的值接近于 2.2204460492503130808472633361816E-16，或者 2-52。</p>\n<p>测试数值是否在误差范围内:</p>\n<pre><code>0.1 + 0.2 === 0.3; // false\n// 在误差范围内即视为相等\nequal = (Math.abs(0.1 - 0.3 + 0.2) &lt; Number.EPSILON); // true\n</code></pre>\n<h3 id=\"属性特性\"><a class=\"anchor\" href=\"#属性特性\">#</a> 属性特性</h3>\n<pre><code>writable：false\nenumerable：false\nconfigurable：false\n</code></pre>\n<h3 id=\"最大最小安全整数\"><a class=\"anchor\" href=\"#最大最小安全整数\">#</a> 最大 / 最小安全整数</h3>\n<p><strong>安全整数</strong></p>\n<p>安全整数表示在 JavaScript 中能够精确表示的整数，安全整数的范围在 2 的 -53 次方到 2 的 53 次方之间（不包括两个端点），超过这个范围的整数无法精确表示。</p>\n<p><strong>最大安全整数</strong></p>\n<p>安全整数范围的上限，即 2 的 53 次方减 1 。</p>\n<pre><code>Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true\nNumber.MAX_SAFE_INTEGER === Number.MAX_SAFE_INTEGER + 1;     // false\nNumber.MAX_SAFE_INTEGER - 1 === Number.MAX_SAFE_INTEGER - 2; // false\n</code></pre>\n<p><strong>最小安全整数</strong></p>\n<p>安全整数范围的下限，即 2 的 53 次方减 1 的负数。</p>\n<pre><code>Number.MIN_SAFE_INTEGER + 1 === Number.MIN_SAFE_INTEGER + 2; // false\nNumber.MIN_SAFE_INTEGER === Number.MIN_SAFE_INTEGER - 1;     // false\nNumber.MIN_SAFE_INTEGER - 1 === Number.MIN_SAFE_INTEGER - 2; // true\n</code></pre>\n<p><strong>属性特性</strong></p>\n<pre><code>writable：false\nenumerable：false\nconfigurable：false\n</code></pre>\n<h3 id=\"方法\"><a class=\"anchor\" href=\"#方法\">#</a> 方法</h3>\n<p><strong>Number 对象新方法</strong></p>\n<pre><code>Number.isFinite()\n</code></pre>\n<p>用于检查一个数值是否为有限的（ finite ），即不是 Infinity</p>\n<pre><code>console.log( Number.isFinite(1));   // true\nconsole.log( Number.isFinite(0.1)); // true\n \n// NaN 不是有限的\nconsole.log( Number.isFinite(NaN)); // false\n \nconsole.log( Number.isFinite(Infinity));  // false\nconsole.log( Number.isFinite(-Infinity)); // false\n \n// Number.isFinate 没有隐式的 Number() 类型转换，所有非数值都返回 false\nconsole.log( Number.isFinite('foo')); // false\nconsole.log( Number.isFinite('15'));  // false\nconsole.log( Number.isFinite(true));  // false\nNumber.isNaN()\n用于检查一个值是否为 NaN 。\nconsole.log(Number.isNaN(NaN));      // true\nconsole.log(Number.isNaN('true'/0)); // true\n \n// 在全局的 isNaN() 中，以下皆返回 true，因为在判断前会将非数值向数值转换\n// 而 Number.isNaN() 不存在隐式的 Number() 类型转换，非 NaN 全部返回 false\nNumber.isNaN(&quot;NaN&quot;);      // false\nNumber.isNaN(undefined);  // false\nNumber.isNaN(&#123;&#125;);         // false\nNumber.isNaN(&quot;true&quot;);     // false\n</code></pre>\n<p><strong>从全局移植到 Number 对象的方法</strong></p>\n<p>逐步减少全局方法，用于全局变量的模块化。</p>\n<p>方法的行为没有发生改变。</p>\n<pre><code>Number.parseInt()\n</code></pre>\n<p>用于将给定字符串转化为指定进制的整数</p>\n<pre><code>// 不指定进制时默认为 10 进制\nNumber.parseInt('12.34'); // 12\nNumber.parseInt(12.34);   // 12\n \n// 指定进制\nNumber.parseInt('0011',2); // 3\n \n// 与全局的 parseInt() 函数是同一个函数\nNumber.parseInt === parseInt; // true\nNumber.parseFloat()\n用于把一个字符串解析成浮点数。\nNumber.parseFloat('123.45')    // 123.45\nNumber.parseFloat('123.45abc') // 123.45\n \n// 无法被解析成浮点数，则返回 NaN\nNumber.parseFloat('abc') // NaN\n \n// 与全局的 parseFloat() 方法是同一个方法\nNumber.parseFloat === parseFloat // true\nNumber.isInteger()\n用于判断给定的参数是否为整数。\nNumber.isInteger(value)\nNumber.isInteger(0); // true\n// JavaScript 内部，整数和浮点数采用的是同样的储存方法,因此 1 与 1.0 被视为相同的值\nNumber.isInteger(1);   // true\nNumber.isInteger(1.0); // true\n \nNumber.isInteger(1.1);     // false\nNumber.isInteger(Math.PI); // false\n \n// NaN 和正负 Infinity 不是整数\nNumber.isInteger(NaN);       // false\nNumber.isInteger(Infinity);  // false\nNumber.isInteger(-Infinity); // false\n \nNumber.isInteger(&quot;10&quot;);  // false\nNumber.isInteger(true);  // false\nNumber.isInteger(false); // false\nNumber.isInteger([1]);   // false\n \n// 数值的精度超过 53 个二进制位时，由于第 54 位及后面的位被丢弃，会产生误判\nNumber.isInteger(1.0000000000000001) // true\n \n// 一个数值的绝对值小于 Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨\n// 的最小值，会被自动转为 0，也会产生误判\nNumber.isInteger(5E-324); // false\nNumber.isInteger(5E-325); // true\nNumber.isSafeInteger()\n用于判断数值是否在安全范围内。\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1); // false\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1); // false\n</code></pre>\n<h2 id=\"math-对象的扩展\"><a class=\"anchor\" href=\"#math-对象的扩展\">#</a> Math 对象的扩展</h2>\n<p>ES6 在 Math 对象上新增了 17 个数学相关的静态方法，这些方法只能在 Math 中调用。</p>\n<p><strong>普通计算</strong></p>\n<pre><code>Math.cbrt\n</code></pre>\n<p>用于计算一个数的立方根。</p>\n<pre><code>Math.cbrt(1);  // 1\nMath.cbrt(0);  // 0\nMath.cbrt(-1); // -1\n// 会对非数值进行转换\nMath.cbrt('1'); // 1\n \n// 非数值且无法转换为数值时返回 NaN\nMath.cbrt('hhh'); // NaN\n</code></pre>\n<pre><code>Math.imul\n</code></pre>\n<p>两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>\n<pre><code>// 大多数情况下，结果与 a * b 相同 \nMath.imul(1, 2);   // 2\n \n// 用于正确返回大数乘法结果中的低位数值\nMath.imul(0x7fffffff, 0x7fffffff); // 1\n</code></pre>\n<pre><code>Math.hypot\n</code></pre>\n<p>用于计算所有参数的平方和的平方根。</p>\n<pre><code>Math.hypot(3, 4); // 5\n \n// 非数值会先被转换为数值后进行计算\nMath.hypot(1, 2, '3'); // 3.741657386773941\nMath.hypot(true);      // 1\nMath.hypot(false);     // 0\n \n// 空值会被转换为 0\nMath.hypot();   // 0\nMath.hypot([]); // 0\n \n// 参数为 Infinity 或 -Infinity 返回 Infinity\nMath.hypot(Infinity); // Infinity\nMath.hypot(-Infinity); // Infinity\n \n// 参数中存在无法转换为数值的参数时返回 NaN\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, 'foo'); // NaN\nMath.hypot(&#123;&#125;);          // NaN\n</code></pre>\n<pre><code>Math.clz32\n</code></pre>\n<p>用于返回数字的 32 位无符号整数形式的前导 0 的个数。</p>\n<pre><code>Math.clz32(0); // 32\nMath.clz32(1); // 31\nMath.clz32(0b01000000000100000000000000000000); // 1\n \n// 当参数为小数时，只考虑整数部分\nMath.clz32(0.5); // 32\n \n// 对于空值或非数值，会转化为数值再进行计算\nMath.clz32('1');       // 31\nMath.clz32();          // 32\nMath.clz32([]);        // 32\nMath.clz32(&#123;&#125;);        // 32\nMath.clz32(NaN);       // 32\nMath.clz32(Infinity);  // 32\nMath.clz32(-Infinity); // 32\nMath.clz32(undefined); // 32\nMath.clz32('hhh');     // 32\n</code></pre>\n<h3 id=\"数字处理\"><a class=\"anchor\" href=\"#数字处理\">#</a> 数字处理</h3>\n<pre><code>Math.trunc\n</code></pre>\n<p>用于返回数字的整数部分。</p>\n<pre><code>Math.trunc(12.3); // 12\nMath.trunc(12);   // 12\n \n// 整数部分为 0 时也会判断符号\nMath.trunc(-0.5); // -0\nMath.trunc(0.5);  // 0\n \n// Math.trunc 会将非数值转为数值再进行处理\nMath.trunc(&quot;12.3&quot;); // 12\n \n// 空值或无法转化为数值时时返回 NaN\nMath.trunc();           // NaN\nMath.trunc(NaN);        // NaN\nMath.trunc(&quot;hhh&quot;);      // NaN\nMath.trunc(&quot;123.2hhh&quot;); // NaN\n</code></pre>\n<pre><code>Math.fround\n</code></pre>\n<p>用于获取数字的 32 位单精度浮点数形式。</p>\n<pre><code>// 对于 2 的 24 次方取负至 2 的 24 次方之间的整数（不含两个端点），返回结果与参数本身一致\nMath.fround(-(2**24)+1);  // -16777215\nMath.fround(2 ** 24 - 1); // 16777215\n \n// 用于将 64 位双精度浮点数转为 32 位单精度浮点数\nMath.fround(1.234) // 1.125\n// 当小数的精度超过 24 个二进制位，会丢失精度\nMath.fround(0.3); // 0.30000001192092896\n// 参数为 NaN 或 Infinity 时返回本身\nMath.fround(NaN)      // NaN\nMath.fround(Infinity) // Infinity\n \n// 参数为其他非数值类型时会将参数进行转换 \nMath.fround('5');  // 5\nMath.fround(true); // 1\nMath.fround(null); // 0\nMath.fround([]);   // 0\nMath.fround(&#123;&#125;);   // NaN\n</code></pre>\n<h3 id=\"判断\"><a class=\"anchor\" href=\"#判断\">#</a> 判断</h3>\n<pre><code>Math.sign\n</code></pre>\n<p>判断数字的符号（正、负、0）。</p>\n<pre><code>Math.sign(1);  // 1\nMath.sign(-1); // -1\n \n// 参数为 0 时，不同符号的返回不同\nMath.sign(0);  // 0\nMath.sign(-0); // -0\n \n// 判断前会对非数值进行转换\nMath.sign('1');  // 1\nMath.sign('-1'); // -1  \n \n// 参数为非数值（无法转换为数值）时返回 NaN\nMath.sign(NaN);   // NaN \nMath.sign('hhh'); // NaN\n</code></pre>\n<h3 id=\"对数方法\"><a class=\"anchor\" href=\"#对数方法\">#</a> 对数方法</h3>\n<pre><code>Math.expm1()\n</code></pre>\n<p>用于计算 e 的 x 次方减 1 的结果，即 Math.exp (x) - 1 。</p>\n<pre><code>Math.expm1(1);  // 1.718281828459045\nMath.expm1(0);  // 0\nMath.expm1(-1); // -0.6321205588285577\n// 会对非数值进行转换\nMath.expm1('0'); //0\n \n// 参数不为数值且无法转换为数值时返回 NaN\nMath.expm1(NaN); // NaN\n</code></pre>\n<pre><code>Math.log1p(x)\n</code></pre>\n<p>用于计算 1 + x 的自然对数，即 Math.log (1 + x) 。</p>\n<pre><code>Math.log1p(1);  // 0.6931471805599453\nMath.log1p(0);  // 0\nMath.log1p(-1); // -Infinity\n \n// 参数小于 -1 时返回 NaN\nMath.log1p(-2); // NaN\n</code></pre>\n<pre><code>Math.log10(x)\n</code></pre>\n<p>用于计算以 10 为底的 x 的对数。</p>\n<pre><code>Math.log10(1);   // 0\n// 计算前对非数值进行转换\nMath.log10('1'); // 0\n// 参数为0时返回 -Infinity\nMath.log10(0);   // -Infinity\n// 参数小于0或参数不为数值（且无法转换为数值）时返回 NaN\nMath.log10(-1);  // NaN\n</code></pre>\n<pre><code>Math.log2()\n</code></pre>\n<p>用于计算 2 为底的 x 的对数。</p>\n<pre><code>Math.log2(1);   // 0\n// 计算前对非数值进行转换\nMath.log2('1'); // 0\n// 参数为0时返回 -Infinity\nMath.log2(0);   // -Infinity\n// 参数小于0或参数不为数值（且无法转换为数值）时返回 NaN\nMath.log2(-1);  // NaN\n</code></pre>\n<h3 id=\"双曲函数方法\"><a class=\"anchor\" href=\"#双曲函数方法\">#</a> 双曲函数方法</h3>\n<ul>\n<li>Math.sinh (x): 用于计算双曲正弦。</li>\n<li>Math.cosh (x): 用于计算双曲余弦。</li>\n<li>Math.tanh (x): 用于计算双曲正切。</li>\n<li>Math.asinh (x): 用于计算反双曲正弦。</li>\n<li>Math.acosh (x): 用于计算反双曲余弦。</li>\n<li>Math.atanh (x): 用于计算反双曲正切。</li>\n</ul>\n<h3 id=\"指数运算符\"><a class=\"anchor\" href=\"#指数运算符\">#</a> 指数运算符</h3>\n<pre><code>1 ** 2; // 1\n// 右结合，从右至左计算\n2 ** 2 ** 3; // 256\n// **=\nlet exam = 2;\nexam ** = 2; // 4\n</code></pre>\n",
            "tags": []
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "",
            "date_published": "2022-05-26T02:42:57.822Z",
            "content_html": "<h3 id=\"拓展的方法\"><a class=\"anchor\" href=\"#拓展的方法\">#</a> 拓展的方法</h3>\n<h3 id=\"子串的识别\"><a class=\"anchor\" href=\"#子串的识别\">#</a> 子串的识别</h3>\n<p>ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。</p>\n<ul>\n<li><strong>includes()</strong>：返回布尔值，判断是否找到参数字符串。</li>\n<li><strong>startsWith()</strong>：返回布尔值，判断参数字符串是否在原字符串的头部。</li>\n<li><strong>endsWith()</strong>：返回布尔值，判断参数字符串是否在原字符串的尾部。</li>\n</ul>\n<p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p>\n<pre><code>let string = &quot;apple,banana,orange&quot;;\nstring.includes(&quot;banana&quot;);     // true\nstring.startsWith(&quot;apple&quot;);    // true\nstring.endsWith(&quot;apple&quot;);      // false\nstring.startsWith(&quot;banana&quot;,6)  // true\n</code></pre>\n<p><strong>注意点：</strong></p>\n<ul>\n<li>这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。</li>\n<li>这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。</li>\n</ul>\n<h3 id=\"字符串重复\"><a class=\"anchor\" href=\"#字符串重复\">#</a> 字符串重复</h3>\n<p>repeat ()：返回新的字符串，表示将字符串重复指定次数返回。</p>\n<h3 id=\"字符串重复-2\"><a class=\"anchor\" href=\"#字符串重复-2\">#</a> 字符串重复</h3>\n<p>repeat ()：返回新的字符串，表示将字符串重复指定次数返回。</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(2));  // &quot;Hello,Hello,&quot;\n</code></pre>\n<p>如果参数是小数，向下取整</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(3.2));  // &quot;Hello,Hello,Hello,&quot;\n</code></pre>\n<p>如果参数是 0 至 -1 之间的小数，会进行取整运算，0 至 -1 之间的小数取整得到 -0 ，等同于 repeat 零次</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(-0.5));  // &quot;&quot; \n</code></pre>\n<p>如果参数是 NaN，等同于 repeat 零次</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(NaN));  // &quot;&quot; \n</code></pre>\n<p>如果参数是负数或者 Infinity ，会报错:</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(-1));  \n// RangeError: Invalid count value\n\nconsole.log(&quot;Hello,&quot;.repeat(Infinity));  \n// RangeError: Invalid count value\n</code></pre>\n<p>如果传入的参数是字符串，则会先将字符串转化为数字</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(&quot;hh&quot;)); // &quot;&quot;\nconsole.log(&quot;Hello,&quot;.repeat(&quot;2&quot;));  // &quot;Hello,Hello,&quot;\n</code></pre>\n<h3 id=\"字符串补全\"><a class=\"anchor\" href=\"#字符串补全\">#</a> 字符串补全</h3>\n<ul>\n<li><strong>padStart</strong>：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</li>\n<li><strong>padEnd</strong>：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。</li>\n</ul>\n<p>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</p>\n<pre><code>console.log(&quot;h&quot;.padStart(5,&quot;o&quot;));  // &quot;ooooh&quot;\nconsole.log(&quot;h&quot;.padEnd(5,&quot;o&quot;));    // &quot;hoooo&quot;\nconsole.log(&quot;h&quot;.padStart(5));      // &quot;    h&quot;\n</code></pre>\n<p>如果指定的长度小于或者等于原字符串的长度，则返回原字符串:</p>\n<pre><code>console.log(&quot;hello&quot;.padStart(5,&quot;A&quot;));  // &quot;hello&quot;\n</code></pre>\n<p>如果原字符串加上补全字符串长度大于指定长度，则截去超出位数的补全字符串:</p>\n<pre><code>console.log(&quot;hello&quot;.padEnd(10,&quot;,world!&quot;));  // &quot;hello,worl&quot;\n</code></pre>\n<p>常用于补全位数：</p>\n<pre><code>console.log(&quot;123&quot;.padStart(10,&quot;0&quot;));  // &quot;0000000123&quot;\n</code></pre>\n<h3 id=\"模板字符串\"><a class=\"anchor\" href=\"#模板字符串\">#</a> 模板字符串</h3>\n<p>模板字符串相当于加强版的字符串，用反引号 <strong>`</strong>, 除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。</p>\n<p><strong>基本用法</strong></p>\n<p>普通字符串</p>\n<pre><code>let string = `Hello'\\n'world`;\nconsole.log(string); \n// &quot;Hello'\n// 'world&quot;\n</code></pre>\n<p>多行字符串:</p>\n<pre><code>let string1 =  `Hey,\ncan you stop angry now?`;\nconsole.log(string1);\n// Hey,\n// can you stop angry now?\n</code></pre>\n<p>字符串插入变量和表达式。</p>\n<p>变量名写在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow></mrow><mtext>中，</mtext></mrow><annotation encoding=\"application/x-tex\">{} 中，</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"></span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">，</span></span></span></span>{} 中可以放入 JavaScript 表达式。</p>\n<pre><code>let name = &quot;Mike&quot;;\nlet age = 27;\nlet info = `My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`\nconsole.log(info);\n// My Name is Mike,I am 28 years old next year.\n</code></pre>\n<p>字符串中调用函数：</p>\n<pre><code>function f()&#123;\n  return &quot;have fun!&quot;;\n&#125;\nlet string2= `Game start,$&#123;f()&#125;`;\nconsole.log(string2);  // Game start,have fun!\n</code></pre>\n<p><strong>注意要点</strong></p>\n<p>模板字符串中的换行和空格都是会被保留的</p>\n<pre><code>innerHtml = `&lt;ul&gt;\n  &lt;li&gt;menu&lt;/li&gt;\n  &lt;li&gt;mine&lt;/li&gt;\n&lt;/ul&gt;\n`;\nconsole.log(innerHtml);\n// 输出\n&lt;ul&gt;\n &lt;li&gt;menu&lt;/li&gt;\n &lt;li&gt;mine&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h3 id=\"标签模板\"><a class=\"anchor\" href=\"#标签模板\">#</a> 标签模板</h3>\n<p>标签模板，是一个函数的调用，其中调用的参数是模板字符串</p>\n<pre><code>alert`Hello world!`;\n// 等价于\nalert('Hello world!');\n</code></pre>\n<p>当模板字符串中带有变量，会将模板字符串参数处理成多个参数</p>\n<pre><code>function f(stringArr,...values)&#123;\n let result = &quot;&quot;;\n for(let i=0;i&lt;stringArr.length;i++)&#123;\n  result += stringArr[i];\n  if(values[i])&#123;\n   result += values[i];\n        &#125;\n    &#125;\n return result;\n&#125;\nlet name = 'Mike';\nlet age = 27;\nf`My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`;\n// &quot;My Name is Mike,I am 28 years old next year.&quot;\n \nf`My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`;\n// 等价于\nf(['My Name is',',I am ',' years old next year.'],'Mike',28);\n</code></pre>\n<p><strong>应用</strong></p>\n<p>过滤 HTML 字符串，防止用户输入恶意内容</p>\n<pre><code>function f(stringArr,...values)&#123;\n let result = &quot;&quot;;\n for(let i=0;i&lt;stringArr.length;i++)&#123;\n  result += stringArr[i];\n   if(values[i])&#123;\n     result += String(values[i]).replace(/&amp;/g, &quot;&amp;amp;&quot;)\n               .replace(/&lt;/g, &quot;&amp;lt;&quot;)\n               .replace(/&gt;/g, &quot;&amp;gt;&quot;);\n    &#125;\n &#125;\n return result;\n&#125;\nname = '&lt;Amy&amp;MIke&gt;';\nf`&lt;p&gt;Hi, $&#123;name&#125;.I would like send you some message.&lt;/p&gt;`;\n// &lt;p&gt;Hi, &amp;lt;Amy&amp;amp;MIke&amp;gt;.I would like send you some message.&lt;/p&gt;\n</code></pre>\n<p><strong>国际化处理（转化多国语言）</strong></p>\n<pre><code>i18n`Hello $&#123;name&#125;, you are visitor number $&#123;visitorNumber&#125;.`;  \n// 你好**，你是第**位访问者\n</code></pre>\n",
            "tags": []
        }
    ]
}