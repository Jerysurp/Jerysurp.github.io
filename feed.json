{
    "version": "https://jsonfeed.org/version/1",
    "title": "熵白之痕",
    "subtitle": "以前进为目标吧",
    "icon": "https://entropywhite.com/images/favicon.ico",
    "description": "欢迎来到熵白的博客",
    "home_page_url": "https://entropywhite.com",
    "items": [
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Symbol/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Symbol/",
            "title": "Symbol",
            "date_published": "2022-06-30T14:25:00.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名</p>\n<p>ES6 数据类型除了 Number 、 String 、 Boolean 、 Object、 null 和 undefined ，还新增了 Symbol</p>\n<hr>\n<h2 id=\"基本用法\"><a class=\"anchor\" href=\"#基本用法\">#</a> 基本用法</h2>\n<p>Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的 Symbol 提供描述，用来显示在控制台或者作为字符串的时候使用，便于区分</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>let sy = Symbol(\"KK\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>console.log(sy);   // Symbol(KK)</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>typeof(sy);        // \"symbol\"</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>// 相同参数 Symbol() 返回的值不相等</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>let sy1 = Symbol(\"kk\"); </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>sy === sy1;       // false</pre></td></tr></table></figure><h2 id=\"使用场景\"><a class=\"anchor\" href=\"#使用场景\">#</a> 使用场景</h2>\n<h3 id=\"作为属性名\"><a class=\"anchor\" href=\"#作为属性名\">#</a> 作为属性名</h3>\n<p><strong>用法</strong></p>\n<p>由于每一个 Symbol 的值都是不相等的，所以 Symbol 作为对象的属性名，可以保证属性不重名</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>let sy = Symbol(\"key1\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre> </pre></td></tr><tr><td data-num=\"3\"></td><td><pre>// 写法1</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>let syObject = &#123;&#125;;</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>syObject[sy] = \"kk\";</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>console.log(syObject);    // &#123;Symbol(key1): \"kk\"&#125;</pre></td></tr><tr><td data-num=\"7\"></td><td><pre> </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>// 写法2</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>let syObject = &#123;</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>  [sy]: \"kk\"</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>&#125;;</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>console.log(syObject);    // &#123;Symbol(key1): \"kk\"&#125;</pre></td></tr><tr><td data-num=\"13\"></td><td><pre> </pre></td></tr><tr><td data-num=\"14\"></td><td><pre>// 写法3</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>let syObject = &#123;&#125;;</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>Object.defineProperty(syObject, sy, &#123;value: \"kk\"&#125;);</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>console.log(syObject);   // &#123;Symbol(key1): \"kk\"&#125;</pre></td></tr></table></figure><p>Symbol 作为对象属性名时不能用。运算符，要用方括号。因为。运算符后面是字符串，所以取到的是字符串 sy 属性，而不是 Symbol 值 sy 属性</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>let syObject = &#123;&#125;;</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>syObject[sy] = \"kk\";</pre></td></tr><tr><td data-num=\"3\"></td><td><pre> </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>syObject[sy];  // \"kk\"</pre></td></tr><tr><td data-num=\"5\"></td><td><pre>syObject.sy;   // undefined</pre></td></tr></table></figure><h3 id=\"注意点\"><a class=\"anchor\" href=\"#注意点\">#</a> 注意点</h3>\n<p>Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问。但是不会出现在 for...in 、 for...of 的循环中，也不会被 Object.keys () 、 Object.getOwnPropertyNames () 返回。如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols () 和 Reflect.ownKeys () 取到</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>let syObject = &#123;&#125;;</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>syObject[sy] = \"kk\";</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>console.log(syObject);</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>for (let i in syObject) &#123;</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>  console.log(i);</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>&#125;    // 无输出</pre></td></tr><tr><td data-num=\"8\"></td><td><pre> </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>Object.keys(syObject);                     // []</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>Object.getOwnPropertySymbols(syObject);    // [Symbol(key1)]</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>Reflect.ownKeys(syObject);                 // [Symbol(key1)]</pre></td></tr></table></figure><h3 id=\"定义常量\"><a class=\"anchor\" href=\"#定义常量\">#</a> 定义常量</h3>\n<p>在 ES5 使用字符串表示常量。例如：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>const COLOR_RED = \"red\";</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>const COLOR_YELLOW = \"yellow\";</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>const COLOR_BLUE = \"blue\";</pre></td></tr></table></figure><p>但是用字符串不能保证常量是独特的，这样会引起一些问题：</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>const COLOR_RED = \"red\";</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>const COLOR_YELLOW = \"yellow\";</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>const COLOR_BLUE = \"blue\";</pre></td></tr><tr><td data-num=\"4\"></td><td><pre>const MY_BLUE = \"blue\";</pre></td></tr><tr><td data-num=\"5\"></td><td><pre></pre></td></tr><tr><td data-num=\"6\"></td><td><pre>function ColorException(message) &#123;</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   this.message = message;</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>   this.name = \"ColorException\";</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>&#125;</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>function getConstantName(color) &#123;</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    switch (color) &#123;</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>        case COLOR_RED :</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>            return \"COLOR_RED\";</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>        case COLOR_YELLOW :</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>            return \"COLOR_YELLOW \";</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>        case COLOR_BLUE:</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>            return \"COLOR_BLUE\";</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>        case MY_BLUE:</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>            return \"MY_BLUE\";         </pre></td></tr><tr><td data-num=\"20\"></td><td><pre>        default:</pre></td></tr><tr><td data-num=\"21\"></td><td><pre>            throw new ColorException(\"Can't find this color\");</pre></td></tr><tr><td data-num=\"22\"></td><td><pre>    &#125;</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>&#125;</pre></td></tr><tr><td data-num=\"24\"></td><td><pre>try &#123;</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>   var color = \"green\"; // green 引发异常</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>   var colorName = getConstantName(color);</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>&#125; catch (e) &#123;</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>   var colorName = \"unknown\";</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>   console.log(e.message, e.name); // 传递异常对象到错误处理</pre></td></tr><tr><td data-num=\"30\"></td><td><pre>&#125;</pre></td></tr></table></figure><p>但是使用 Symbol 定义常量，这样就可以保证这一组常量的值都不相等。用 Symbol 来修改上面的例子</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>const COLOR_RED = Symbol(\"red\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>const COLOR_YELLOW = Symbol(\"yellow\");</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>const COLOR_BLUE = Symbol(\"blue\");</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>function ColorException(message) &#123;</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>   this.message = message;</pre></td></tr><tr><td data-num=\"7\"></td><td><pre>   this.name = \"ColorException\";</pre></td></tr><tr><td data-num=\"8\"></td><td><pre>&#125;</pre></td></tr><tr><td data-num=\"9\"></td><td><pre>function getConstantName(color) &#123;</pre></td></tr><tr><td data-num=\"10\"></td><td><pre>    switch (color) &#123;</pre></td></tr><tr><td data-num=\"11\"></td><td><pre>        case COLOR_RED :</pre></td></tr><tr><td data-num=\"12\"></td><td><pre>            return \"COLOR_RED\";</pre></td></tr><tr><td data-num=\"13\"></td><td><pre>        case COLOR_YELLOW :</pre></td></tr><tr><td data-num=\"14\"></td><td><pre>            return \"COLOR_YELLOW \";</pre></td></tr><tr><td data-num=\"15\"></td><td><pre>        case COLOR_BLUE:</pre></td></tr><tr><td data-num=\"16\"></td><td><pre>            return \"COLOR_BLUE\";</pre></td></tr><tr><td data-num=\"17\"></td><td><pre>        default:</pre></td></tr><tr><td data-num=\"18\"></td><td><pre>            throw new ColorException(\"Can't find this color\");</pre></td></tr><tr><td data-num=\"19\"></td><td><pre>    &#125;</pre></td></tr><tr><td data-num=\"20\"></td><td><pre>&#125;</pre></td></tr><tr><td data-num=\"21\"></td><td><pre> </pre></td></tr><tr><td data-num=\"22\"></td><td><pre>try &#123;</pre></td></tr><tr><td data-num=\"23\"></td><td><pre>   </pre></td></tr><tr><td data-num=\"24\"></td><td><pre>   var color = \"green\"; // green 引发异常</pre></td></tr><tr><td data-num=\"25\"></td><td><pre>   var colorName = getConstantName(color);</pre></td></tr><tr><td data-num=\"26\"></td><td><pre>&#125; catch (e) &#123;</pre></td></tr><tr><td data-num=\"27\"></td><td><pre>   var colorName = \"unknown\";</pre></td></tr><tr><td data-num=\"28\"></td><td><pre>   console.log(e.message, e.name); // 传递异常对象到错误处理</pre></td></tr><tr><td data-num=\"29\"></td><td><pre>&#125;</pre></td></tr></table></figure><p>Symbol 的值是唯一的，所以不会出现相同值得常量，即可以保证 switch 按照代码预想的方式执行</p>\n<h3 id=\"symbolfor\"><a class=\"anchor\" href=\"#symbolfor\">#</a> Symbol.for()</h3>\n<p>Symbol.for () 类似单例模式，首先会在全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>let yellow = Symbol(\"Yellow\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>let yellow1 = Symbol.for(\"Yellow\");</pre></td></tr><tr><td data-num=\"3\"></td><td><pre>yellow === yellow1;      // false</pre></td></tr><tr><td data-num=\"4\"></td><td><pre> </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>let yellow2 = Symbol.for(\"Yellow\");</pre></td></tr><tr><td data-num=\"6\"></td><td><pre>yellow1 === yellow2;     // true</pre></td></tr></table></figure><h3 id=\"symbolkeyfor\"><a class=\"anchor\" href=\"#symbolkeyfor\">#</a> Symbol.keyFor()</h3>\n<p>Symbol.keyFor () 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记</p>\n<figure class=\"highlight text\"><figcaption data-lang=\"text\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>let yellow1 = Symbol.for(\"Yellow\");</pre></td></tr><tr><td data-num=\"2\"></td><td><pre>Symbol.keyFor(yellow1);    // \"Yellow\"</pre></td></tr></table></figure>",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Reflect%E4%B8%8EProxy/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Reflect%E4%B8%8EProxy/",
            "title": "Reflect与Proxy",
            "date_published": "2022-06-30T14:22:00.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。</p>\n<p>Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。</p>\n<p>Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。</p>\n<hr>\n<h2 id=\"基本用法\"><a class=\"anchor\" href=\"#基本用法\">#</a> 基本用法</h2>\n<h3 id=\"proxy\"><a class=\"anchor\" href=\"#proxy\">#</a> Proxy</h3>\n<p>一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p>\n<pre><code>let target = &#123;\n    name: 'Tom',\n    age: 24\n&#125;\nlet handler = &#123;\n    get: function(target, key) &#123;\n        console.log('getting '+key);\n        return target[key]; // 不是target.key\n    &#125;,\n    set: function(target, key, value) &#123;\n        console.log('setting '+key);\n        target[key] = value;\n    &#125;\n&#125;\nlet proxy = new Proxy(target, handler)\nproxy.name     // 实际执行 handler.get\nproxy.age = 25 // 实际执行 handler.set\n// getting name\n// setting age\n// 25\n \n// target 可以为空对象\nlet targetEpt = &#123;&#125;\nlet proxyEpt = new Proxy(targetEpt, handler)\n// 调用 get 方法，此时目标对象为空，没有 name 属性\nproxyEpt.name // getting name\n// 调用 set 方法，向目标对象中添加了 name 属性\nproxyEpt.name = 'Tom'\n// setting name\n// &quot;Tom&quot;\n// 再次调用 get ，此时已经存在 name 属性\nproxyEpt.name\n// getting name\n// &quot;Tom&quot;\n \n// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相\n// 影响\ntargetEpt\n// &#123;name: &quot;Tom&quot;&#125;\n \n// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象\nlet targetEmpty = &#123;&#125;\nlet proxyEmpty = new Proxy(targetEmpty,&#123;&#125;)\nproxyEmpty.name = &quot;Tom&quot;\ntargetEmpty // &#123;name: &quot;Tom&quot;&#125;\n</code></pre>\n<h3 id=\"实例方法\"><a class=\"anchor\" href=\"#实例方法\">#</a> 实例方法</h3>\n<pre><code>get(target, propKey, receiver)\n</code></pre>\n<p>用于 target 对象上 propKey 读取操作</p>\n<pre><code>let exam =&#123;\n    name: &quot;Tom&quot;,\n    age: 24\n&#125;\nlet proxy = new Proxy(exam, &#123;\n  get(target, propKey, receiver) &#123;\n    console.log('Getting ' + propKey);\n    return target[propKey];\n  &#125;\n&#125;)\nproxy.name \n// Getting name\n// &quot;Tom&quot;\n</code></pre>\n<p>get () 方法可以继承</p>\n<pre><code>let proxy = new Proxy(&#123;&#125;, &#123;\n  get(target, propKey, receiver) &#123;\n      // 实现私有属性读取保护\n      if(propKey[0] === '_')&#123;\n          throw new Erro(`Invalid attempt to get private     &quot;$&#123;propKey&#125;&quot;`);\n      &#125;\n      console.log('Getting ' + propKey);\n      return target[propKey];\n  &#125;\n&#125;);\n \nlet obj = Object.create(proxy);\nobj.name\n// Getting name\n</code></pre>\n<pre><code>set(target,propKey,value,receiver)\n</code></pre>\n<p>用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么 set 方法不起作用</p>\n<pre><code>let validator = &#123;\n    set: function(obj, prop, value) &#123;\n        if (prop === 'age') &#123;\n            if (!Number.isInteger(value)) &#123;\n                throw new TypeError('The age is not an integer');\n            &#125;\n            if (value &gt; 200) &#123;\n                throw new RangeError('The age seems invalid');\n            &#125;\n        &#125;\n        // 对于满足条件的 age 属性以及其他属性，直接保存\n        obj[prop] = value;\n    &#125;\n&#125;;\nlet proxy= new Proxy(&#123;&#125;, validator)\nproxy.age = 100;\nproxy.age           // 100\nproxy.age = 'oppps' // 报错\nproxy.age = 300     // 报错\n</code></pre>\n<p>第四个参数 receiver 表示原始操作行为所在对象，一般是 Proxy 实例本身</p>\n<pre><code>const handler = &#123;\n    set: function(obj, prop, value, receiver) &#123;\n        obj[prop] = receiver;\n    &#125;\n&#125;;\nconst proxy = new Proxy(&#123;&#125;, handler);\nproxy.name= 'Tom';\nproxy.name=== proxy // true\n \nconst exam = &#123;&#125;\nObject.setPrototypeOf(exam, proxy)\nexam.name = &quot;Tom&quot;\nexam.name === exam // true\n</code></pre>\n<p>注意，严格模式下，set 代理如果没有返回 true，就会报错</p>\n<h3 id=\"applytarget-ctx-args\"><a class=\"anchor\" href=\"#applytarget-ctx-args\">#</a> apply(target, ctx, args)</h3>\n<p>用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组</p>\n<pre><code>function sub(a, b)&#123;\n    return a - b;\n&#125;\nlet handler = &#123;\n    apply: function(target, ctx, args)&#123;\n        console.log('handle apply');\n        return Reflect.apply(...arguments);\n    &#125;\n&#125;\nlet proxy = new Proxy(sub, handler)\nproxy(2, 1) \n// handle apply\n// 1\n</code></pre>\n<pre><code>has(target, propKey)\n</code></pre>\n<p>用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性</p>\n<pre><code>let  handler = &#123;\n    has: function(target, propKey)&#123;\n        console.log(&quot;handle has&quot;);\n        return propKey in target;\n    &#125;\n&#125;\nlet exam = &#123;name: &quot;Tom&quot;&#125;\nlet proxy = new Proxy(exam, handler)\n'name' in proxy\n// handle has\n// true\n</code></pre>\n<p>注意：此方法不拦截 for ... in 循环。</p>\n<pre><code>construct(target, args)\n</code></pre>\n<p>用于拦截 new 命令。返回值必须为对象</p>\n<pre><code>let handler = &#123;\n    construct: function (target, args, newTarget) &#123;\n        console.log('handle construct')\n        return Reflect.construct(target, args, newTarget)  \n    &#125;\n&#125;\nclass Exam &#123; \n    constructor (name) &#123;  \n        this.name = name \n    &#125;\n&#125;\nlet ExamProxy = new Proxy(Exam, handler)\nlet proxyObj = new ExamProxy('Tom')\nconsole.log(proxyObj)\n// handle construct\n// exam &#123;name: &quot;Tom&quot;&#125;\n</code></pre>\n<pre><code>deleteProperty(target, propKey)\n</code></pre>\n<p>用于拦截 delete 操作，如果这个方法抛出错误或者返回 false ，propKey 属性就无法被 delete 命令删除。</p>\n<pre><code>defineProperty(target, propKey, propDesc)\n</code></pre>\n<p>用于拦截 Object.definePro 若目标对象不可扩展，增加目标对象上不存在的属性会报错；若属性不可写或不可配置，则不能改变这些属性。</p>\n<pre><code>let handler = &#123;\n    defineProperty: function(target, propKey, propDesc)&#123;\n        console.log(&quot;handle defineProperty&quot;);\n        return true;\n    &#125;\n&#125;\nlet target = &#123;&#125;\nlet proxy = new Proxy(target, handler)\nproxy.name = &quot;Tom&quot;\n// handle defineProperty\ntarget\n// &#123;name: &quot;Tom&quot;&#125;\n \n// defineProperty 返回值为false，添加属性操作无效\nlet handler1 = &#123;\n    defineProperty: function(target, propKey, propDesc)&#123;\n        console.log(&quot;handle defineProperty&quot;);\n        return false;\n    &#125;\n&#125;\nlet target1 = &#123;&#125;\nlet proxy1 = new Proxy(target1, handler1)\nproxy1.name = &quot;Jerry&quot;\ntarget1\n// &#123;&#125;\n</code></pre>\n<p><strong>erty 操作</strong></p>\n<pre><code>getOwnPropertyDescriptor(target, propKey)\n</code></pre>\n<p>用于拦截 Object.getOwnPropertyD () 返回值为属性描述对象或者 undefined</p>\n<pre><code>let handler = &#123;\n    getOwnPropertyDescriptor: function(target, propKey)&#123;\n        return Object.getOwnPropertyDescriptor(target, propKey);\n    &#125;\n&#125;\nlet target = &#123;name: &quot;Tom&quot;&#125;\nlet proxy = new Proxy(target, handler)\nObject.getOwnPropertyDescriptor(proxy, 'name')\n// &#123;value: &quot;Tom&quot;, writable: true, enumerable: true, configurable: \n// true&#125;\n</code></pre>\n<p><strong>ptor 属性</strong></p>\n<pre><code>getPrototypeOf(target)\n</code></pre>\n<p>主要用于拦截获取对象原型的操作。包括以下操作：</p>\n<pre><code>- Object.prototype._proto_\n- Object.prototype.isPrototypeOf()\n- Object.getPrototypeOf()\n- Reflect.getPrototypeOf()\n- instanceof\n</code></pre>\n<pre><code>let exam = &#123;&#125;\nlet proxy = new Proxy(&#123;&#125;,&#123;\n    getPrototypeOf: function(target)&#123;\n        return exam;\n    &#125;\n&#125;)\nObject.getPrototypeOf(proxy) // &#123;&#125;\n</code></pre>\n<p>注意，返回值必须是对象或者 null ，否则报错。另外，如果目标对象不可扩展（non-extensible），getPrototypeOf 方法必须返回目标对象的原型对象。</p>\n<pre><code>let proxy = new Proxy(&#123;&#125;,&#123;\n    getPrototypeOf: function(target)&#123;\n        return true;\n    &#125;\n&#125;)\nObject.getPrototypeOf(proxy)\n// TypeError: 'getPrototypeOf' on proxy: trap returned neither object // nor null\n</code></pre>\n<pre><code>isExtensible(target)\n</code></pre>\n<p>用于拦截 Object.isExtensible 操作。</p>\n<p>该方法只能返回布尔值，否则返回值会被自动转为布尔值。</p>\n<pre><code>let proxy = new Proxy(&#123;&#125;,&#123;\n    isExtensible:function(target)&#123;\n        return true;\n    &#125;\n&#125;)\nObject.isExtensible(proxy) // true\n</code></pre>\n<p>注意：它的返回值必须与目标对象的 isExtensible 属性保持一致，否则会抛出错误</p>\n<pre><code>let proxy = new Proxy(&#123;&#125;,&#123;\n    isExtensible:function(target)&#123;\n        return false;\n    &#125;\n&#125;)\nObject.isExtensible(proxy)\n// TypeError: 'isExtensible' on proxy: trap result does not reflect \n// extensibility of proxy target (which is 'true')\n</code></pre>\n<pre><code>ownKeys(target)\n</code></pre>\n<p>用于拦截对象自身属性的读取操作。主要包括以下操作：</p>\n<pre><code>- Object.getOwnPropertyNames()\n- Object.getOwnPropertySymbols()\n- Object.keys()\n- or...in\n</code></pre>\n<p>方法返回的数组成员，只能是字符串或 Symbol 值，否则会报错。</p>\n<p>若目标对象中含有不可配置的属性，则必须将这些属性在结果中返回，否则就会报错。</p>\n<p>若目标对象不可扩展，则必须全部返回且只能返回目标对象包含的所有属性，不能包含不存在的属性，否则也会报错。</p>\n<pre><code>let proxy = new Proxy( &#123;\n  name: &quot;Tom&quot;,\n  age: 24\n&#125;, &#123;\n    ownKeys(target) &#123;\n        return ['name'];\n    &#125;\n&#125;);\nObject.keys(proxy)\n// [ 'name' ]f返回结果中，三类属性会被过滤：\n//          - 目标对象上没有的属性\n//          - 属性名为 Symbol 值的属性\n//          - 不可遍历的属性\n \nlet target = &#123;\n  name: &quot;Tom&quot;,\n  [Symbol.for('age')]: 24,\n&#125;;\n// 添加不可遍历属性 'gender'\nObject.defineProperty(target, 'gender', &#123;\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: 'male'\n&#125;);\nlet handler = &#123;\n    ownKeys(target) &#123;\n        return ['name', 'parent', Symbol.for('age'), 'gender'];\n    &#125;\n&#125;;\nlet proxy = new Proxy(target, handler);\nObject.keys(proxy)\n// ['name']\n</code></pre>\n<pre><code>preventExtensions(target)\n</code></pre>\n<p>拦截 Object.preventExtensions 操作。</p>\n<p>该方法必须返回一个布尔值，否则会自动转为布尔值。</p>\n<pre><code>// 只有目标对象不可扩展时（即 Object.isExtensible(proxy) 为 false ），\n// proxy.preventExtensions 才能返回 true ，否则会报错\nvar proxy = new Proxy(&#123;&#125;, &#123;\n  preventExtensions: function(target) &#123;\n    return true;\n  &#125;\n&#125;);\n// 由于 proxy.preventExtensions 返回 true，此处也会返回 true，因此会报错\nObject.preventExtensions(proxy) 被// TypeError: 'preventExtensions' on proxy: trap returned truish but // the proxy target is extensible\n \n// 解决方案\n var proxy = new Proxy(&#123;&#125;, &#123;\n  preventExtensions: function(target) &#123;\n    // 返回前先调用 Object.preventExtensions\n    Object.preventExtensions(target);\n    return true;\n  &#125;\n&#125;);\nObject.preventExtensions(proxy)\n// Proxy &#123;&#125;\n</code></pre>\n<pre><code>setPrototypeOf\n</code></pre>\n<p>主要用来拦截 Object.setPrototypeOf 方法。</p>\n<p>返回值必须为布尔值，否则会被自动转为布尔值。</p>\n<p>若目标对象不可扩展，setPrototypeOf 方法不得改变目标对象的原型。</p>\n<pre><code>let proto = &#123;&#125;\nlet proxy = new Proxy(function () &#123;&#125;, &#123;\n    setPrototypeOf: function(target, proto) &#123;\n        console.log(&quot;setPrototypeOf&quot;);\n        return true;\n    &#125;\n&#125;\n);\nObject.setPrototypeOf(proxy, proto);\n// setPrototypeOf\n</code></pre>\n<pre><code>Proxy.revocable()\n</code></pre>\n<p>用于返回一个可取消的 Proxy 实例</p>\n<pre><code>let &#123;proxy, revoke&#125; = Proxy.revocable(&#123;&#125;, &#123;&#125;);\nproxy.name = &quot;Tom&quot;;\nrevoke();\nproxy.name \n// TypeError: Cannot perform 'get' on a proxy that has been revoked\n</code></pre>\n<h3 id=\"reflect\"><a class=\"anchor\" href=\"#reflect\">#</a> Reflect</h3>\n<p>ES6 中将 Object 的一些明显属于语言内部的方法移植到了 Reflect 对象上（当前某些方法会同时存在于 Object 和 Reflect 对象上），未来的新方法会只部署在 Reflect 对象上。</p>\n<p>Reflect 对象对某些方法的返回结果进行了修改，使其更合理。</p>\n<p>Reflect 对象使用函数的方式实现了 Object 的命令式操作。</p>\n<p><strong>静态方法</strong></p>\n<pre><code>Reflect.get(target, name, receiver)\n</code></pre>\n<p>查找并返回 target 对象的 name 属性。</p>\n<pre><code>let exam = &#123;\n    name: &quot;Tom&quot;,\n    age: 24,\n    get info()&#123;\n        return this.name + this.age;\n    &#125;\n&#125;\nReflect.get(exam, 'name'); // &quot;Tom&quot;\n \n// 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiver\nlet receiver = &#123;\n    name: &quot;Jerry&quot;,\n    age: 20\n&#125;\nReflect.get(exam, 'info', receiver); // Jerry20\n \n// 当 name 为不存在于 target 对象的属性时，返回 undefined\nReflect.get(exam, 'birth'); // undefined\n \n// 当 target 不是对象时，会报错\nReflect.get(1, 'name'); // TypeError\n</code></pre>\n<pre><code>Reflect.set(target, name, value, receiver)\n</code></pre>\n<p>将 target 的 name 属性设置为 value。返回值为 boolean ，true 表示修改成功，false 表示失败。当 target 为不存在的对象时，会报错</p>\n<pre><code>let exam = &#123;\n    name: &quot;Tom&quot;,\n    age: 24,\n    set info(value)&#123;\n        return this.age = value;\n    &#125;\n&#125;\nexam.age; // 24\nReflect.set(exam, 'age', 25); // true\nexam.age; // 25\n \n// value 为空时会将 name 属性清除\nReflect.set(exam, 'age', ); // true\nexam.age; // undefined\n \n// 当 target 对象中存在 name 属性 setter 方法时，setter 方法中的 this 会绑定 // receiver , 所以修改的实际上是 receiver 的属性,\nlet receiver = &#123;\n    age: 18\n&#125;\nReflect.set(exam, 'info', 1, receiver); // true\nreceiver.age; // 1\n \nlet receiver1 = &#123;\n    name: 'oppps'\n&#125;\nReflect.set(exam, 'info', 1, receiver1);\nreceiver1.age; // 1\n</code></pre>\n<pre><code>Reflect.has(obj, name)\n</code></pre>\n<p>是 name in obj 指令的函数化，用于查找 name 属性在 obj 对象中是否存在。返回值为 boolean。如果 obj 不是对象则会报错 TypeError</p>\n<pre><code>let exam = &#123;\n    name: &quot;Tom&quot;,\n    age: 24\n&#125;\nReflect.has(exam, 'name'); // true\n</code></pre>\n<pre><code>Reflect.deleteProperty(obj, property)\n</code></pre>\n<p>是 delete obj [property] 的函数化，用于删除 obj 对象的 property 属性，返回值为 boolean。如果 obj 不是对象则会报错 TypeError</p>\n<pre><code>let exam = &#123;\n    name: &quot;Tom&quot;,\n    age: 24\n&#125;\nReflect.deleteProperty(exam , 'name'); // true\nexam // &#123;age: 24&#125; \n// property 不存在时，也会返回 true\nReflect.deleteProperty(exam , 'name'); // true\n</code></pre>\n<pre><code>Reflect.construct(obj, args)\n</code></pre>\n<p>等同于 new target (...args)</p>\n<pre><code>function exam(name)&#123;\n    this.name = name;\n&#125;\nReflect.construct(exam, ['Tom']); // exam &#123;name: &quot;Tom&quot;&#125;\n</code></pre>\n<pre><code>Reflect.getPrototypeOf(obj)\n</code></pre>\n<p>用于读取 obj 的 <em>proto</em> 属性。在 obj 不是对象时不会像 Object 一样把 obj 转为对象，而是会报错</p>\n<pre><code>class Exam&#123;&#125;\nlet obj = new Exam()\nReflect.getPrototypeOf(obj) === Exam.prototype // true\n</code></pre>\n<pre><code>Reflect.setPrototypeOf(obj, newProto)\n</code></pre>\n<p>用于设置目标对象的 prototype。</p>\n<pre><code>let obj =&#123;&#125;\nReflect.setPrototypeOf(obj, Array.prototype); // true\n</code></pre>\n<pre><code>Reflect.apply(func, thisArg, args)\n</code></pre>\n<p>等同于 Function.prototype.apply.call (func, thisArg, args) 。func 表示目标函数；thisArg 表示目标函数绑定的 this 对象；args 表示目标函数调用时传入的参数列表，可以是数组或类似数组的对象。若目标函数无法调用，会抛出 TypeError</p>\n<pre><code>Reflect.apply(Math.max, Math, [1, 3, 5, 3, 1]); // 5\n</code></pre>\n<pre><code>Reflect.defineProperty(target, propertyKey, attributes)\n</code></pre>\n<p>用于为目标对象定义属性。如果 target 不是对象，会抛出错误</p>\n<pre><code>let myDate= &#123;&#125;\nReflect.defineProperty(MyDate, 'now', &#123;\n  value: () =&gt; Date.now()\n&#125;); // true\n \nconst student = &#123;&#125;;\nReflect.defineProperty(student, &quot;name&quot;, &#123;value: &quot;Mike&quot;&#125;); // true\nstudent.name; // &quot;Mike&quot;\n</code></pre>\n<pre><code>Reflect.getOwnPropertyDescriptor(target, propertyKey)\n</code></pre>\n<p>用于得到 target 对象的 propertyKey 属性的描述对象。在 target 不是对象时，会抛出错误表示参数非法，不会将非对象转换为对象</p>\n<pre><code>var exam = &#123;&#125;\nReflect.defineProperty(exam, 'name', &#123;\n  value: true,\n  enumerable: false,\n&#125;)\nReflect.getOwnPropertyDescriptor(exam, 'name')\n// &#123; configurable: false, enumerable: false, value: true, writable:\n// false&#125;\n \n \n// propertyKey 属性在 target 对象中不存在时，返回 undefined\nReflect.getOwnPropertyDescriptor(exam, 'age') // undefined\n</code></pre>\n<pre><code>Reflect.isExtensible(target)\n</code></pre>\n<p>用于判断 target 对象是否可扩展。返回值为 boolean 。如果 target 参数不是对象，会抛出错误</p>\n<pre><code>let exam = &#123;&#125;\nReflect.isExtensible(exam) // true\n</code></pre>\n<pre><code>Reflect.preventExtensions(target)\n</code></pre>\n<p>用于让 target 对象变为不可扩展。如果 target 参数不是对象，会抛出错</p>\n<pre><code>let exam = &#123;&#125;\nReflect.preventExtensions(exam) // true\n</code></pre>\n<pre><code>Reflect.ownKeys(target)\n</code></pre>\n<p>用于返回 target 对象的所有属性，等同于 Object.getOwnPropertyNames 与 Object.getOwnPropertySymbols 之和</p>\n<pre><code>var exam = &#123;\n  name: 1,\n  [Symbol.for('age')]: 4\n&#125;\nReflect.ownKeys(exam) // [&quot;name&quot;, Symbol(age)]\n</code></pre>\n<h2 id=\"组合使用\"><a class=\"anchor\" href=\"#组合使用\">#</a> 组合使用</h2>\n<p>Reflect 对象的方法与 Proxy 对象的方法是一一对应的。所以 Proxy 对象的方法可以通过调用 Reflect 对象的方法获取默认行为，然后进行额外操作</p>\n<pre><code>let exam = &#123;\n    name: &quot;Tom&quot;,\n    age: 24\n&#125;\nlet handler = &#123;\n    get: function(target, key)&#123;\n        console.log(&quot;getting &quot;+key);\n        return Reflect.get(target,key);\n    &#125;,\n    set: function(target, key, value)&#123;\n        console.log(&quot;setting &quot;+key+&quot; to &quot;+value)\n        Reflect.set(target, key, value);\n    &#125;\n&#125;\nlet proxy = new Proxy(exam, handler)\nproxy.name = &quot;Jerry&quot;\nproxy.name\n// setting name to Jerry\n// getting name\n// &quot;Jerry&quot;\n</code></pre>\n<h3 id=\"使用场景拓展\"><a class=\"anchor\" href=\"#使用场景拓展\">#</a> 使用场景拓展</h3>\n<p><strong>实现观察者模式</strong></p>\n<pre><code>// 定义 Set 集合\nconst queuedObservers = new Set();\n// 把观察者函数都放入 Set 集合中\nconst observe = fn =&gt; queuedObservers.add(fn);\n// observable 返回原始对象的代理，拦截赋值操作\nconst observable = obj =&gt; new Proxy(obj, &#123;set&#125;);\nfunction set(target, key, value, receiver) &#123;\n  // 获取对象的赋值操作\n  const result = Reflect.set(target, key, value, receiver);\n  // 执行所有观察者\n  queuedObservers.forEach(observer =&gt; observer());\n  // 执行赋值操作\n  return result;\n&#125;\n</code></pre>\n<pre><code>fn =&gt; queuedObservers.add(fn)\n</code></pre>\n<p>等于：</p>\n<pre><code>function(fn)&#123; \n    return queuedObservers.add(fn) ;\n&#125;;\nobj =&gt; new Proxy(obj, &#123;set&#125;)\n</code></pre>\n<p>等于：</p>\n<pre><code>function(obj)&#123;\n    return new Proxy(obj, &#123;set&#125;);\n&#125;\nobserver =&gt; observer()\n</code></pre>\n<p>等于：</p>\n<pre><code>function(observer )&#123;\n    return observer()\n&#125;\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/JS-Promise%E5%AF%B9%E8%B1%A1/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/JS-Promise%E5%AF%B9%E8%B1%A1/",
            "title": "JS-Promise对象",
            "date_published": "2022-06-30T14:21:00.000Z",
            "content_html": "<p>ECMAscript 6 原生提供了 Promise 对象。</p>\n<p>Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p>\n<h3 id=\"promise-对象有以下两个特点\"><a class=\"anchor\" href=\"#promise-对象有以下两个特点\">#</a> Promise 对象有以下两个特点:</h3>\n<p>1、对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：</p>\n<ul>\n<li>pending: 初始状态，不是成功或失败状态。</li>\n<li>fulfilled: 意味着操作成功完成。</li>\n<li>rejected: 意味着操作失败。</li>\n</ul>\n<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。</p>\n<p>2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<h3 id=\"promise-优缺点\"><a class=\"anchor\" href=\"#promise-优缺点\">#</a> Promise 优缺点</h3>\n<p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p>Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<h3 id=\"promise-创建\"><a class=\"anchor\" href=\"#promise-创建\">#</a> Promise 创建</h3>\n<p>要想创建一个 promise 对象、可以使用 new 来调用 Promise 的构造器来进行实例化。</p>\n<p>下面是创建 promise 的步骤：</p>\n<pre><code>var promise = new Promise(function(resolve, reject) &#123;\n    // 异步处理\n    // 处理结束后、调用resolve 或 reject\n&#125;);\n</code></pre>\n<p>Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用 reject。</p>\n<pre><code>var myFirstPromise = new Promise(function(resolve, reject)&#123;\n    //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)\n    //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.\n    setTimeout(function()&#123;\n        resolve(&quot;成功!&quot;); //代码正常执行！\n    &#125;, 250);\n&#125;);\n \nmyFirstPromise.then(function(successMessage)&#123;\n    //successMessage的值是上面调用resolve(...)方法传入的值.\n    //successMessage参数不一定非要是字符串类型，这里只是举个例子\n    document.write(&quot;Yay! &quot; + successMessage);\n&#125;);\n</code></pre>\n<p>对于已经实例化过的 promise 对象可以调用 promise.then () 方法，传递 resolve 和 reject 方法作为回调。</p>\n<p>promise.then () 是 promise 最为常用的方法。</p>\n<pre><code>promise.then(onFulfilled, onRejected)\n</code></pre>\n<p>promise 简化了对 error 的处理，上面的代码我们也可以这样写：</p>\n<pre><code>promise.then(onFulfilled).catch(onRejected)\n</code></pre>\n<hr>\n<h2 id=\"promise-ajax\"><a class=\"anchor\" href=\"#promise-ajax\">#</a> Promise Ajax</h2>\n<p>下面是一个用 Promise 对象实现的 Ajax 操作的例子。</p>\n<pre><code>function ajax(URL) &#123;\n    return new Promise(function (resolve, reject) &#123;\n        var req = new XMLHttpRequest(); \n        req.open('GET', URL, true);\n        req.onload = function () &#123;\n        if (req.status === 200) &#123; \n                resolve(req.responseText);\n            &#125; else &#123;\n                reject(new Error(req.statusText));\n            &#125; \n        &#125;;\n        req.onerror = function () &#123;\n            reject(new Error(req.statusText));\n        &#125;;\n        req.send(); \n    &#125;);\n&#125;\nvar URL = &quot;/try/ajax/testpromise.php&quot;; \najax(URL).then(function onFulfilled(value)&#123;\n    document.write('内容是：' + value); \n&#125;).catch(function onRejected(error)&#123;\n    document.write('错误：' + error); \n&#125;);\n</code></pre>\n<p>上面代码中，resolve 方法和 reject 方法调用时，都带有参数。它们的参数会被传递给回调函数。reject 方法的参数通常是 Error 对象的实例，而 resolve 方法的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。</p>\n<pre><code>var p1 = new Promise(function(resolve, reject)&#123;\n  // ... some code\n&#125;);\n \nvar p2 = new Promise(function(resolve, reject)&#123;\n  // ... some code\n  resolve(p1);\n&#125;)\n</code></pre>\n<p>上面代码中，p1 和 p2 都是 Promise 的实例，但是 p2 的 resolve 方法将 p1 作为参数，这时 p1 的状态就会传递给 p2。如果调用的时候，p1 的状态是 pending，那么 p2 的回调函数就会等待 p1 的状态改变；如果 p1 的状态已经是 fulfilled 或者 rejected，那么 p2 的回调函数将会立刻执行。</p>\n<hr>\n<h2 id=\"promiseprototypethen方法链式操作\"><a class=\"anchor\" href=\"#promiseprototypethen方法链式操作\">#</a> Promise.prototype.then 方法：链式操作</h2>\n<p>Promise.prototype.then 方法返回的是一个新的 Promise 对象，因此可以采用链式写法。</p>\n<pre><code>getJSON(&quot;/posts.json&quot;).then(function(json) &#123;\n  return json.post;\n&#125;).then(function(post) &#123;\n  // proceed\n&#125;);\n</code></pre>\n<p>上面的代码使用 then 方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>如果前一个回调函数返回的是 Promise 对象，这时后一个回调函数就会等待该 Promise 对象有了运行结果，才会进一步调用。</p>\n<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;\n  return getJSON(post.commentURL);\n&#125;).then(function(comments) &#123;\n  // 对comments进行处理\n&#125;);\n</code></pre>\n<p>这种设计使得嵌套的异步操作，可以被很容易得改写，从回调函数的 &quot;横向发展&quot; 改为 &quot;向下发展&quot;。</p>\n<hr>\n<h2 id=\"promiseprototypecatch方法捕捉错误\"><a class=\"anchor\" href=\"#promiseprototypecatch方法捕捉错误\">#</a> Promise.prototype.catch 方法：捕捉错误</h2>\n<p>Promise.prototype.catch 方法是 Promise.prototype.then (null, rejection) 的别名，用于指定发生错误时的回调函数。</p>\n<pre><code>getJSON(&quot;/posts.json&quot;).then(function(posts) &#123;\n  // some code\n&#125;).catch(function(error) &#123;\n  // 处理前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n&#125;);\n</code></pre>\n<p>Promise 对象的错误具有 &quot;冒泡&quot; 性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个 catch 语句捕获</p>\n<pre><code>getJSON(&quot;/post/1.json&quot;).then(function(post) &#123;\n  return getJSON(post.commentURL);\n&#125;).then(function(comments) &#123;\n  // some code\n&#125;).catch(function(error) &#123;\n  // 处理前两个回调函数的错误\n&#125;);\n</code></pre>\n<h2 id=\"promiseall方法promiserace方法\"><a class=\"anchor\" href=\"#promiseall方法promiserace方法\">#</a> Promise.all 方法，Promise.race 方法</h2>\n<p>Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<pre><code>var p = Promise.all([p1,p2,p3]);\n</code></pre>\n<p>上面代码中，Promise.all 方法接受一个数组作为参数，p1、p2、p3 都是 Promise 对象的实例。（Promise.all 方法的参数不一定是数组，但是必须具有 iterator 接口，且返回的每个成员都是 Promise 实例。）</p>\n<p>p 的状态由 p1、p2、p3 决定，分成两种情况。</p>\n<ul>\n<li>（1）只有 p1、p2、p3 的状态都变成 fulfilled，p 的状态才会变成 fulfilled，此时 p1、p2、p3 的返回值组成一个数组，传递给 p 的回调函数。</li>\n<li>（2）只要 p1、p2、p3 之中有一个被 rejected，p 的状态就变成 rejected，此时第一个被 reject 的实例的返回值，会传递给 p 的回调函数。</li>\n</ul>\n<p>下面是一个具体的例子。</p>\n<pre><code>// 生成一个Promise对象的数组\nvar promises = [2, 3, 5, 7, 11, 13].map(function(id)&#123;\n  return getJSON(&quot;/post/&quot; + id + &quot;.json&quot;);\n&#125;);\n \nPromise.all(promises).then(function(posts) &#123;\n  // ...  \n&#125;).catch(function(reason)&#123;\n  // ...\n&#125;);\n</code></pre>\n<p>Promise.race 方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p>\n<pre><code>var p = Promise.race([p1,p2,p3]);\n</code></pre>\n<p>上面代码中，只要 p1、p2、p3 之中有一个实例率先改变状态，p 的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给 p 的返回值。</p>\n<p>如果 Promise.all 方法和 Promise.race 方法的参数，不是 Promise 实例，就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。</p>\n<hr>\n<h2 id=\"promiseresolve-方法promisereject-方法\"><a class=\"anchor\" href=\"#promiseresolve-方法promisereject-方法\">#</a> Promise.resolve 方法，Promise.reject 方法</h2>\n<p>有时需要将现有对象转为 Promise 对象，Promise.resolve 方法就起到这个作用。</p>\n<pre><code>var jsPromise = Promise.resolve($.ajax('/whatever.json'));\n</code></pre>\n<p>上面代码将 jQuery 生成 deferred 对象，转为一个新的 ES6 的 Promise 对象。</p>\n<p>如果 Promise.resolve 方法的参数，不是具有 then 方法的对象（又称 thenable 对象），则返回一个新的 Promise 对象，且它的状态为 fulfilled。</p>\n<pre><code>var p = Promise.resolve('Hello');\n \np.then(function (s)&#123;\n  console.log(s)\n&#125;);\n// Hello\n</code></pre>\n<p>上面代码生成一个新的 Promise 对象的实例 p，它的状态为 fulfilled，所以回调函数会立即执行，Promise.resolve 方法的参数就是回调函数的参数。</p>\n<p>如果 Promise.resolve 方法的参数是一个 Promise 对象的实例，则会被原封不动地返回。</p>\n<p>Promise.reject (reason) 方法也会返回一个新的 Promise 实例，该实例的状态为 rejected。Promise.reject 方法的参数 reason，会被传递给实例的回调函数。</p>\n<pre><code>var p = Promise.reject('出错了');\n \np.then(null, function (s)&#123;\n  console.log(s)\n&#125;);\n// 出错了\n</code></pre>\n<p>上面代码生成一个 Promise 对象的实例，状态为 rejected，回调函数会立即执行</p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Map%E4%B8%8ESet/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Map%E4%B8%8ESet/",
            "title": "Map与Set",
            "date_published": "2022-06-30T14:21:00.000Z",
            "content_html": "<h2 id=\"map-对象\"><a class=\"anchor\" href=\"#map-对象\">#</a> Map 对象</h2>\n<p>Map 对象保存键值对。任何值 (对象或者原始值) 都可以作为一个键或一个值。</p>\n<h2 id=\"maps-和-objects-的区别\"><a class=\"anchor\" href=\"#maps-和-objects-的区别\">#</a> Maps 和 Objects 的区别</h2>\n<ul>\n<li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li>\n<li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li>\n<li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li>\n<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>\n</ul>\n<h3 id=\"map-中的-key\"><a class=\"anchor\" href=\"#map-中的-key\">#</a> Map 中的 key</h3>\n<p><strong>key 是字符串</strong></p>\n<pre><code>var myMap = new Map();\nvar keyString = &quot;a string&quot;; \n \nmyMap.set(keyString, &quot;和键'a string'关联的值&quot;);\n \nmyMap.get(keyString);    // &quot;和键'a string'关联的值&quot;\nmyMap.get(&quot;a string&quot;);   // &quot;和键'a string'关联的值&quot;\n                         // 因为 keyString === 'a string'\n</code></pre>\n<p><strong>key 是对象</strong></p>\n<pre><code>var myMap = new Map();\nvar keyObj = &#123;&#125;, \n \nmyMap.set(keyObj, &quot;和键 keyObj 关联的值&quot;);\n\nmyMap.get(keyObj); // &quot;和键 keyObj 关联的值&quot;\nmyMap.get(&#123;&#125;); // undefined, 因为 keyObj !== &#123;&#125;\n</code></pre>\n<p><strong>key 是函数</strong></p>\n<pre><code>var myMap = new Map();\nvar keyFunc = function () &#123;&#125;, // 函数\n \nmyMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);\n \nmyMap.get(keyFunc); // &quot;和键 keyFunc 关联的值&quot;\nmyMap.get(function() &#123;&#125;) // undefined, 因为 keyFunc !== function () &#123;&#125;\n</code></pre>\n<p><strong>key 是 NaN</strong></p>\n<pre><code>var myMap = new Map();\nmyMap.set(NaN, &quot;not a number&quot;);\n \nmyMap.get(NaN); // &quot;not a number&quot;\n \nvar otherNaN = Number(&quot;foo&quot;);\nmyMap.get(otherNaN); // &quot;not a number&quot;\n</code></pre>\n<h3 id=\"map-的迭代\"><a class=\"anchor\" href=\"#map-的迭代\">#</a> Map 的迭代</h3>\n<p>对 Map 进行遍历，以下两个最高级。</p>\n<h3 id=\"forof\"><a class=\"anchor\" href=\"#forof\">#</a> for...of</h3>\n<pre><code>var myMap = new Map();\nmyMap.set(0, &quot;zero&quot;);\nmyMap.set(1, &quot;one&quot;);\n \n// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;\nfor (var [key, value] of myMap) &#123;\n  console.log(key + &quot; = &quot; + value);\n&#125;\nfor (var [key, value] of myMap.entries()) &#123;\n  console.log(key + &quot; = &quot; + value);\n&#125;\n/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */\n \n// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;\nfor (var key of myMap.keys()) &#123;\n  console.log(key);\n&#125;\n/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */\n \n// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;\nfor (var value of myMap.values()) &#123;\n  console.log(value);\n&#125;\n/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */\n</code></pre>\n<h3 id=\"foreach\"><a class=\"anchor\" href=\"#foreach\">#</a> forEach()</h3>\n<pre><code>var myMap = new Map();\nmyMap.set(0, &quot;zero&quot;);\nmyMap.set(1, &quot;one&quot;);\n \n// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;\nmyMap.forEach(function(value, key) &#123;\n  console.log(key + &quot; = &quot; + value);\n&#125;, myMap)\n</code></pre>\n<h3 id=\"map-对象的操作\"><a class=\"anchor\" href=\"#map-对象的操作\">#</a> Map 对象的操作</h3>\n<p><strong>Map 与 Array 的转换</strong></p>\n<pre><code>var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];\n \n// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象\nvar myMap = new Map(kvArray);\n \n// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组\nvar outArray = Array.from(myMap);\n</code></pre>\n<p><strong>Map 的克隆</strong></p>\n<pre><code>var myMap1 = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);\nvar myMap2 = new Map(myMap1);\n \nconsole.log(original === clone); \n// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。\n</code></pre>\n<p><strong>Map 的合并</strong></p>\n<pre><code>var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]);\nvar second = new Map([[1, 'uno'], [2, 'dos']]);\n \n// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three\nvar merged = new Map([...first, ...second]);\n</code></pre>\n<hr>\n<h2 id=\"set-对象\"><a class=\"anchor\" href=\"#set-对象\">#</a> Set 对象</h2>\n<p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p>\n<h3 id=\"set-中的特殊值\"><a class=\"anchor\" href=\"#set-中的特殊值\">#</a> Set 中的特殊值</h3>\n<p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</p>\n<ul>\n<li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</li>\n<li>undefined 与 undefined 是恒等的，所以不重复；</li>\n<li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。</li>\n</ul>\n<p><strong>代码</strong></p>\n<pre><code>let mySet = new Set();\n \nmySet.add(1); // Set(1) &#123;1&#125;\nmySet.add(5); // Set(2) &#123;1, 5&#125;\nmySet.add(5); // Set(2) &#123;1, 5&#125; 这里体现了值的唯一性\nmySet.add(&quot;some text&quot;); \n// Set(3) &#123;1, 5, &quot;some text&quot;&#125; 这里体现了类型的多样性\nvar o = &#123;a: 1, b: 2&#125;; \nmySet.add(o);\nmySet.add(&#123;a: 1, b: 2&#125;); \n// Set(5) &#123;1, 5, &quot;some text&quot;, &#123;…&#125;, &#123;…&#125;&#125; \n// 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储\n</code></pre>\n<h3 id=\"类型转换\"><a class=\"anchor\" href=\"#类型转换\">#</a> 类型转换</h3>\n<p><strong>Array</strong></p>\n<pre><code>// Array 转 Set\nvar mySet = new Set([&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;]);\n// 用...操作符，将 Set 转 Array\nvar myArray = [...mySet];\nString\n// String 转 Set\nvar mySet = new Set('hello');  // Set(4) &#123;&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;&#125;\n// 注：Set 中 toString 方法是不能将 Set 转换成 String\n</code></pre>\n<h3 id=\"set-对象作用\"><a class=\"anchor\" href=\"#set-对象作用\">#</a> Set 对象作用</h3>\n<p><strong>数组去重</strong></p>\n<pre><code>var mySet = new Set([1, 2, 3, 4, 4]); [...mySet]; // [1, 2, 3, 4]\n</code></pre>\n<p><strong>并集</strong></p>\n<pre><code>var a = new Set([1, 2, 3]); \nvar b = new Set([4, 3, 2]); \nvar union = new Set([...a, ...b]); // &#123;1, 2, 3, 4&#125;\n</code></pre>\n<p><strong>交集</strong></p>\n<pre><code>var a = new Set([1, 2, 3]); \nvar b = new Set([4, 3, 2]); \nvar intersect = new Set([...a].filter(x =&gt; b.has(x))); // &#123;2, 3&#125;\n</code></pre>\n<p><strong>差集</strong></p>\n<pre><code>var a = new Set([1, 2, 3]); \nvar b = new Set([4, 3, 2]); \nvar difference = new Set([...a].filter(x =&gt; !b.has(x))); // &#123;1&#125;\nvar difference =new Set([...[...a].filter(x =&gt; !b.has(x)),...[...b].filter(x =&gt; !a.has(x))]); // &#123;1,4&#125;\n</code></pre>\n<p><strong>1、[...a]</strong></p>\n<p>[...a] 就是将 set 转换成 array。以后需要将 set 转换成 array 基本都使用这种方法。</p>\n<p><strong>2、[...a].filter()</strong></p>\n<p>Array.filter (function (x)) 把传入的函数 function (x) 依次作用于每个元素，x 为元素的值，然后根据返回值是 true 还是 false 决定保留还是丢弃该元素。</p>\n<p>意思就是遍历当前数组，当遍历到某个元素时，返回值为 false 就将该元素从数组中剔除。</p>\n<p>filter () 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>\n<p><strong>3、 =&gt; 则是一种简写方法。</strong></p>\n<pre><code>x =&gt; x * x \n</code></pre>\n<p>相当于：</p>\n<pre><code>function(x)&#123;return x*x&#125;\n</code></pre>\n<p>所以 <strong>x =&gt; b.has(x)</strong> 本质是一个函数相当于 <strong>function(x){return b.has（x)}</strong>。</p>\n<p><strong>4、b.has(x)</strong></p>\n<p>Set.has (x) 是 set 中的一个方法。即判断当前 set 中是否含有 x，如果有返回 true，没有返回 false。</p>\n<p>所以这段程序也可以写成：</p>\n<pre><code>var a = new Set([1, 2, 3]); \nvar b = new Set([4, 3, 2]); \nvar arr = [...a];            //将a转换成数组\nvar fArr = arr.filter(function(x)&#123;    //使用filter过滤数组，并将新数组返回到fArr\n    return b.has(x);        //判断b中是否含有a中的元素，没有则返回false\n&#125;)\nvar intersect = new Set(fArr);          //将fArr转换成set\nconsole.log(fArr);\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Promise%E5%AF%B9%E8%B1%A1/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Promise%E5%AF%B9%E8%B1%A1/",
            "title": "Promise对象",
            "date_published": "2022-06-30T14:21:00.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>是异步编程的一种解决方案。</p>\n<p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。</p>\n<h2 id=\"promise-状态\"><a class=\"anchor\" href=\"#promise-状态\">#</a> Promise 状态</h2>\n<h3 id=\"状态的特点\"><a class=\"anchor\" href=\"#状态的特点\">#</a> 状态的特点</h3>\n<p>Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。</p>\n<p>Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。</p>\n<pre><code>const p1 = new Promise(function(resolve,reject)&#123;\n    resolve('success1');\n    resolve('success2');\n&#125;); \nconst p2 = new Promise(function(resolve,reject)&#123;  \n    resolve('success3'); \n    reject('reject');\n&#125;);\np1.then(function(value)&#123;  \n    console.log(value); // success1\n&#125;);\np2.then(function(value)&#123; \n    console.log(value); // success3\n&#125;);\n</code></pre>\n<h3 id=\"状态的缺点\"><a class=\"anchor\" href=\"#状态的缺点\">#</a> 状态的缺点</h3>\n<p>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</p>\n<p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p>\n<p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<h2 id=\"then-方法\"><a class=\"anchor\" href=\"#then-方法\">#</a> then 方法</h2>\n<p>then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。</p>\n<h3 id=\"then-方法的特点\"><a class=\"anchor\" href=\"#then-方法的特点\">#</a> then 方法的特点</h3>\n<p>在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用</p>\n<pre><code>const p = new Promise(function(resolve,reject)&#123;\n  resolve('success');\n&#125;);\n \np.then(function(value)&#123;\n  console.log(value);\n&#125;);\n \nconsole.log('first');\n// first\n// success\n</code></pre>\n<p>通过 <strong>.then</strong> 形式添加的回调函数，不论什么时候，都会被调用。</p>\n<p>通过多次调用</p>\n<p>.then</p>\n<p>，可以添加多个回调函数，它们会按照插入顺序并且独立运行。</p>\n<pre><code>const p = new Promise(function(resolve,reject)&#123;\n  resolve(1);\n&#125;).then(function(value)&#123; // 第一个then // 1\n  console.log(value);\n  return value * 2;\n&#125;).then(function(value)&#123; // 第二个then // 2\n  console.log(value);\n&#125;).then(function(value)&#123; // 第三个then // undefined\n  console.log(value);\n  return Promise.resolve('resolve'); \n&#125;).then(function(value)&#123; // 第四个then // resolve\n  console.log(value);\n  return Promise.reject('reject'); \n&#125;).then(function(value)&#123; // 第五个then //reject:reject\n  console.log('resolve:' + value);\n&#125;, function(err) &#123;\n  console.log('reject:' + err);\n&#125;);\n</code></pre>\n<p>then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。</p>\n<h3 id=\"then-方法注意点\"><a class=\"anchor\" href=\"#then-方法注意点\">#</a> then 方法注意点</h3>\n<p>简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。</p>\n<p>注意总是返回或终止 Promise 链。</p>\n<pre><code>const p1 = new Promise(function(resolve,reject)&#123;\n  resolve(1);\n&#125;).then(function(result) &#123;\n  p2(result).then(newResult =&gt; p3(newResult));\n&#125;).then(() =&gt; p4());\n</code></pre>\n<p>创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。</p>\n<p>大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 <strong>.catch(error =&gt; console.log(error));</strong></p>\n<h2 id=\"更多文章\"><a class=\"anchor\" href=\"#更多文章\">#</a> 更多文章</h2>\n<p><a href=\"JS-Promise%E5%AF%B9%E8%B1%A1\">JS-Promise 对象</a></p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/let%E5%92%8Cconst/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/let%E5%92%8Cconst/",
            "title": "let和const",
            "date_published": "2022-06-30T14:21:00.000Z",
            "content_html": "<p>ES2015 (ES6) 新增加了两个重要的 JavaScript 关键字: <strong>let</strong> 和 <strong>const</strong>。</p>\n<p>let 声明的变量只在 let 命令所在的代码块内有效。</p>\n<p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p>\n<hr>\n<h2 id=\"let-命令\"><a class=\"anchor\" href=\"#let-命令\">#</a> let 命令</h2>\n<p>基本用法:</p>\n<p>{let a = 0;  a   // 0} a   // 报错 ReferenceError: a is not defined</p>\n<p><strong>代码块内有效</strong></p>\n<p>let 是在代码块内有效，var 是在全局范围内有效:</p>\n<p>{  let a = 0;  var b = 1; } a  // ReferenceError: a is not defined b  // 1</p>\n<p><strong>不能重复声明</strong></p>\n<p>let 只能声明一次 var 可以声明多次:</p>\n<p>let a = 1; let a = 2; var b = 3; var b = 4; a  // Identifier 'a' has already been declared b  // 4</p>\n<p>for 循环计数器很适合用 let</p>\n<p>for (var i = 0; i &lt; 10; i++) {  setTimeout (function (){    console.log (i);  }) } // 输出十个 10 for (let j = 0; j &lt; 10; j++) {  setTimeout (function (){    console.log (j);  }) } // 输出 0123456789</p>\n<p>变量 i 是用 var 声明的，在全局范围内有效，所以全局中只有一个变量 i, 每次循环时，setTimeout 定时器里面的 i 指的是全局变量 i ，而循环里的十个 setTimeout 是在循环结束后才执行，所以此时的 i 都是 10。</p>\n<p>变量 j 是用 let 声明的，当前的 j 只在本轮循环中有效，每次循环的 j 其实都是一个新的变量，所以 setTimeout 定时器里面的 j 其实是不同的变量，即最后输出 12345。（若每次循环的变量 j 都是重新声明的，如何知道前一个循环的值？这是因为 JavaScript 引擎内部会记住前一个循环的值）。</p>\n<h3 id=\"不存在变量提升\"><a class=\"anchor\" href=\"#不存在变量提升\">#</a> 不存在变量提升</h3>\n<p>let 不存在变量提升，var 会变量提升:</p>\n<p>console.log(a);  //ReferenceError: a is not defined let a = &quot;apple&quot;;  console.log(b);  //undefined var b = &quot;banana&quot;;</p>\n<p>变量 b 用 var 声明存在变量提升，所以当脚本开始运行的时候，b 已经存在了，但是还没有赋值，所以会输出 undefined。</p>\n<p>变量 a 用 let 声明不存在变量提升，在声明变量 a 之前，a 不存在，所以会报错。</p>\n<hr>\n<h2 id=\"const-命令\"><a class=\"anchor\" href=\"#const-命令\">#</a> const 命令</h2>\n<p>const 声明一个只读变量，声明之后不允许改变。意味着，一旦声明必须初始化，否则会报错。</p>\n<p>基本用法:</p>\n<pre><code>const PI = &quot;3.1415926&quot;;\nPI  // 3.1415926\n\nconst MY_AGE;  // SyntaxError: Missing initializer in const declaration    \n</code></pre>\n<p>暂时性死区:</p>\n<pre><code>var PI = &quot;a&quot;;\nif(true)&#123;\n  console.log(PI);  // ReferenceError: PI is not defined\n  const PI = &quot;3.1415926&quot;;\n&#125;\n</code></pre>\n<p>ES6 明确规定，代码块内如果存在 let 或者 const，代码块会对这些命令声明的变量从块的开始就形成一个封闭作用域。代码块内，在声明变量 PI 之前使用它会报错。</p>\n<h3 id=\"注意要点\"><a class=\"anchor\" href=\"#注意要点\">#</a> 注意要点</h3>\n<p>const 如何做到变量在声明初始化之后不允许改变的？其实 const 其实保证的不是变量的值不变，而是保证变量指向的内存地址所保存的数据不允许改动。此时，你可能已经想到，简单类型和复合类型保存值的方式是不同的。是的，对于简单类型（数值 number、字符串 string 、布尔值 boolean）, 值就保存在变量指向的那个内存地址，因此 const 声明的简单类型变量等同于常量。而复杂类型（对象 object，数组 array，函数 function），变量指向的内存地址其实是保存了一个指向实际数据的指针，所以 const 只能保证指针是固定的，至于指针指向的数据结构变不变就无法控制了，所以使用 const 声明复杂类型对象时要慎重。</p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Class%E7%B1%BB/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Class%E7%B1%BB/",
            "title": "Class类",
            "date_published": "2022-06-30T14:20:00.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>在 ES6 中，class (类) 作为对象的模板被引入，可以通过 class 关键字定义类。</p>\n<p>class 的本质是 function。</p>\n<p>它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。</p>\n<h2 id=\"基础用法\"><a class=\"anchor\" href=\"#基础用法\">#</a> 基础用法</h2>\n<h3 id=\"类定义\"><a class=\"anchor\" href=\"#类定义\">#</a> 类定义</h3>\n<p>类表达式可以为匿名或命名。</p>\n<pre><code>// 匿名类\nlet Example = class &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\n// 命名类\nlet Example = class Example &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"类声明\"><a class=\"anchor\" href=\"#类声明\">#</a> 类声明</h3>\n<pre><code>class Example &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\n</code></pre>\n<p>注意要点：不可重复声明</p>\n<pre><code>class Example&#123;&#125;\nclass Example&#123;&#125;\n// Uncaught SyntaxError: Identifier 'Example' has already been \n// declared\n \nlet Example1 = class&#123;&#125;\nclass Example&#123;&#125;\n// Uncaught SyntaxError: Identifier 'Example' has already been \n// declared\n</code></pre>\n<h3 id=\"注意要点\"><a class=\"anchor\" href=\"#注意要点\">#</a> 注意要点</h3>\n<p>类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。</p>\n<p>类中方法不需要 function 关键字。</p>\n<p>方法间不能加分号</p>\n<pre><code>new Example(); \nclass Example &#123;&#125;\n</code></pre>\n<h3 id=\"类的主体\"><a class=\"anchor\" href=\"#类的主体\">#</a> 类的主体</h3>\n<p><strong>属性</strong></p>\n<p>prototype</p>\n<p>ES6 中，prototype 仍旧存在，虽然可以直接自类中定义方法，但是其实方法还是定义在 prototype 上的。 覆盖方法 / 初始化时添加方法</p>\n<pre><code>Example.prototype=&#123;\n    //methods\n&#125;\n</code></pre>\n<p>添加方法</p>\n<pre><code>Object.assign(Example.prototype,&#123;\n    //methods\n&#125;)\n</code></pre>\n<p>静态属性</p>\n<p>静态属性：class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。</p>\n<pre><code>class Example &#123;\n// 新提案\n    static a = 2;\n&#125;\n// 目前可行写法\nExample.b = 2;\n</code></pre>\n<p>公共属性</p>\n<pre><code>class Example&#123;&#125;\nExample.prototype.a = 2;\n</code></pre>\n<p>实例属性</p>\n<p>实例属性：定义在实例对象（ this ）上的属性。</p>\n<pre><code>class Example &#123;\n    a = 2;\n    constructor () &#123;\n        console.log(this.a);\n    &#125;\n&#125;\n</code></pre>\n<p>name 属性</p>\n<p>返回跟在 class 后的类名 (存在时)。</p>\n<pre><code>let Example=class Exam &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\nconsole.log(Example.name); // Exam\n \nlet Example=class &#123;\n    constructor(a) &#123;\n        this.a = a;\n    &#125;\n&#125;\nconsole.log(Example.name); // Example\n</code></pre>\n<p><strong>方法</strong></p>\n<p>constructor 方法</p>\n<p>constructor 方法是类的默认方法，创建类的实例化对象时被调用。</p>\n<pre><code>class Example&#123;\n    constructor()&#123;\n      console.log('我是constructor');\n    &#125;\n&#125;\nnew Example(); // 我是constructor\n</code></pre>\n<p>返回对象</p>\n<pre><code>class Test &#123;\n    constructor()&#123;\n        // 默认返回实例对象 this\n    &#125;\n&#125;\nconsole.log(new Test() instanceof Test); // true\n \nclass Example &#123;\n    constructor()&#123;\n        // 指定返回对象\n        return new Test();\n    &#125;\n&#125;\nconsole.log(new Example() instanceof Example); // false\n</code></pre>\n<p>静态方法</p>\n<pre><code>class Example&#123;\n    static sum(a, b) &#123;\n        console.log(a+b);\n    &#125;\n&#125;\nExample.sum(1, 2); // 3\n</code></pre>\n<p>原型方法</p>\n<pre><code>class Example &#123;\n    sum(a, b) &#123;\n        console.log(a + b);\n    &#125;\n&#125;\nlet exam = new Example();\nexam.sum(1, 2); // 3\n</code></pre>\n<p>实例方法</p>\n<pre><code>class Example &#123;\n    constructor() &#123;\n        this.sum = (a, b) =&gt; &#123;\n            console.log(a + b);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"类的实例化\"><a class=\"anchor\" href=\"#类的实例化\">#</a> 类的实例化</h3>\n<p><strong>new</strong></p>\n<p>class 的实例化必须通过 new 关键字</p>\n<pre><code>class Example &#123;&#125;\n \nlet exam1 = Example(); \n// Class constructor Example cannot be invoked without 'new'\n</code></pre>\n<p><strong>实例化对象</strong></p>\n<p>共享原型对象</p>\n<pre><code>class Example &#123;\n    constructor(a, b) &#123;\n        this.a = a;\n        this.b = b;\n        console.log('Example');\n    &#125;\n    sum() &#123;\n        return this.a + this.b;\n    &#125;\n&#125;\nlet exam1 = new Example(2, 1);\nlet exam2 = new Example(3, 1);\n \n// __proto__ 已废弃，不建议使用\n// console.log(exam1.__proto__ == exam2.__proto__); \n \nconsole.log(Object.getPrototypeOf(exam1) === Object.getPrototypeOf(exam2));// true\n \nObject.getPrototypeOf(exam1).sub = function() &#123;\n    return this.a - this.b;\n&#125;\nconsole.log(exam1.sub()); // 1\nconsole.log(exam2.sub()); // 2\n</code></pre>\n<h2 id=\"decorator\"><a class=\"anchor\" href=\"#decorator\">#</a> decorator</h2>\n<p>decorator 是一个函数，用来修改类的行为，在代码编译时产生作用。</p>\n<h3 id=\"类修饰\"><a class=\"anchor\" href=\"#类修饰\">#</a> 类修饰</h3>\n<p>一个参数</p>\n<p>第一个参数 target，指向类本身</p>\n<pre><code>function testable(target) &#123;\n    target.isTestable = true;\n&#125;\n@testable\nclass Example &#123;&#125;\nExample.isTestable; // true\n</code></pre>\n<p>多个参数 —— 嵌套实现</p>\n<pre><code>function testable(isTestable) &#123;\n    return function(target) &#123;\n        target.isTestable=isTestable;\n    &#125;\n&#125;\n@testable(true)\nclass Example &#123;&#125;\nExample.isTestable; // true\n</code></pre>\n<p>实例属性</p>\n<p>上面两个例子添加的是静态属性，若要添加实例属性，在类的 prototype 上操作即可。</p>\n<h3 id=\"方法修饰\"><a class=\"anchor\" href=\"#方法修饰\">#</a> 方法修饰</h3>\n<p>3 个参数：target（类的原型对象）、name（修饰的属性名）、descriptor（该属性的描述对象）</p>\n<pre><code>class Example &#123;\n    @writable\n    sum(a, b) &#123;\n        return a + b;\n    &#125;\n&#125;\nfunction writable(target, name, descriptor) &#123;\n    descriptor.writable = false;\n    return descriptor; // 必须返回\n&#125;\n</code></pre>\n<p>修饰器执行顺序</p>\n<p>由外向内进入，由内向外执行</p>\n<pre><code>class Example &#123;\n    @logMethod(1)\n    @logMethod(2)\n    sum(a, b)&#123;\n        return a + b;\n    &#125;\n&#125;\nfunction logMethod(id) &#123;\n    console.log('evaluated logMethod'+id);\n    return (target, name, desctiptor) =&gt; console.log('excuted         logMethod '+id);\n&#125;\n// evaluated logMethod 1\n// evaluated logMethod 2\n// excuted logMethod 2\n// excuted logMethod 1\n</code></pre>\n<h2 id=\"封装与继承\"><a class=\"anchor\" href=\"#封装与继承\">#</a> 封装与继承</h2>\n<h3 id=\"getter-setter\"><a class=\"anchor\" href=\"#getter-setter\">#</a> getter / setter</h3>\n<p>定义</p>\n<pre><code>class Example&#123;\n    constructor(a, b) &#123;\n        this.a = a; // 实例化时调用 set 方法\n        this.b = b;\n    &#125;\n    get a()&#123;\n        console.log('getter');\n        return this.a;\n    &#125;\n    set a(a)&#123;\n        console.log('setter');\n        this.a = a; // 自身递归调用\n    &#125;\n&#125;\nlet exam = new Example(1,2); // 不断输出 setter ，最终导致 RangeError\nclass Example1&#123;\n    constructor(a, b) &#123;\n        this.a = a;\n        this.b = b;\n    &#125;\n    get a()&#123;\n        console.log('getter');\n        return this._a;\n    &#125;\n    set a(a)&#123;\n        console.log('setter');\n        this._a = a;\n    &#125;\n&#125;\nlet exam1 = new Example1(1,2); // 只输出 setter , 不会调用 getter 方法\nconsole.log(exam1._a); // 1, 可以直接访问\n</code></pre>\n<p>getter 不可单独出现</p>\n<pre><code>class Example &#123;\n    constructor(a) &#123;\n        this.a = a; \n    &#125;\n    get a() &#123;\n        return this.a;\n    &#125;\n&#125;\nlet exam = new Example(1); // Uncaught TypeError: Cannot set property // a of #&lt;Example&gt; which has only a getter\n</code></pre>\n<p>getter 与 setter 必须同级出现</p>\n<pre><code>class Father &#123;\n    constructor()&#123;&#125;\n    get a() &#123;\n        return this._a;\n    &#125;\n&#125;\nclass Child extends Father &#123;\n    constructor()&#123;\n        super();\n    &#125;\n    set a(a) &#123;\n        this._a = a;\n    &#125;\n&#125;\nlet test = new Child();\ntest.a = 2;\nconsole.log(test.a); // undefined\n \nclass Father1 &#123;\n    constructor()&#123;&#125;\n    // 或者都放在子类中\n    get a() &#123;\n        return this._a;\n    &#125;\n    set a(a) &#123;\n        this._a = a;\n    &#125;\n&#125;\nclass Child1 extends Father1 &#123;\n    constructor()&#123;\n        super();\n    &#125;\n&#125;\nlet test1 = new Child1();\ntest1.a = 2;\nconsole.log(test1.a); // 2\n</code></pre>\n<h3 id=\"extends\"><a class=\"anchor\" href=\"#extends\">#</a> extends</h3>\n<p>通过 extends 实现类的继承</p>\n<pre><code>class Child extends Father &#123; ... &#125;\n</code></pre>\n<h3 id=\"super\"><a class=\"anchor\" href=\"#super\">#</a> super</h3>\n<p>子类 constructor 方法中必须有 super ，且必须出现在 this 之前</p>\n<pre><code>class Father &#123;\n    constructor() &#123;&#125;\n&#125;\nclass Child extends Father &#123;\n    constructor() &#123;&#125;\n    // or \n    // constructor(a) &#123;\n        // this.a = a;\n        // super();\n    // &#125;\n&#125;\nlet test = new Child(); // Uncaught ReferenceError: Must call super \n// constructor in derived class before accessing 'this' or returning \n// from derived constructor\n</code></pre>\n<p>调用父类构造函数，只能出现在子类的构造函数</p>\n<pre><code>class Father &#123;\n    test()&#123;\n        return 0;\n    &#125;\n    static test1()&#123;\n        return 1;\n    &#125;\n&#125;\nclass Child extends Father &#123;\n    constructor()&#123;\n        super();\n    &#125;\n&#125;\nclass Child1 extends Father &#123;\n    test2() &#123;\n        super(); // Uncaught SyntaxError: 'super' keyword unexpected     \n        // here\n    &#125;\n&#125;\n</code></pre>\n<p>调用父类方法，super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类</p>\n<pre><code>class Child2 extends Father &#123;\n    constructor()&#123;\n        super();\n        // 调用父类普通方法\n        console.log(super.test()); // 0\n    &#125;\n    static test3()&#123;\n        // 调用父类静态方法\n        return super.test1+2;\n    &#125;\n&#125;\nChild2.test3(); // 3\n</code></pre>\n<h3 id=\"注意要点-2\"><a class=\"anchor\" href=\"#注意要点-2\">#</a> 注意要点</h3>\n<p>不可继承常规对象</p>\n<pre><code>var Father = &#123;\n    // ...\n&#125;\nclass Child extends Father &#123;\n     // ...\n&#125;\n// Uncaught TypeError: Class extends value #&lt;Object&gt; is not a constructor or null\n \n// 解决方案\nObject.setPrototypeOf(Child.prototype, Father);\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Generator%E5%87%BD%E6%95%B0/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/Generator%E5%87%BD%E6%95%B0/",
            "title": "Generator函数",
            "date_published": "2022-06-30T14:20:00.000Z",
            "content_html": "<p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法</p>\n<h3 id=\"generator-函数组成\"><a class=\"anchor\" href=\"#generator-函数组成\">#</a> Generator 函数组成</h3>\n<p>Generator 有两个区分于普通函数的部分：</p>\n<ul>\n<li>一是在 function 后面，函数名之前有个 * ；</li>\n<li>函数内部有 yield 表达式。</li>\n</ul>\n<p>其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。</p>\n<pre><code>function* func()&#123;\n console.log(&quot;one&quot;);\n yield '1';\n console.log(&quot;two&quot;);\n yield '2'; \n console.log(&quot;three&quot;);\n return '3';\n&#125;\n</code></pre>\n<h3 id=\"执行机制\"><a class=\"anchor\" href=\"#执行机制\">#</a> 执行机制</h3>\n<p>调用 Generator 函数和调用普通函数一样，在函数名后面加上 () 即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象 Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行</p>\n<pre><code>f.next();\n// one\n// &#123;value: &quot;1&quot;, done: false&#125;\n \nf.next();\n// two\n// &#123;value: &quot;2&quot;, done: false&#125;\n \nf.next();\n// three\n// &#123;value: &quot;3&quot;, done: true&#125;\n \nf.next();\n// &#123;value: undefined, done: true&#125;\n</code></pre>\n<p>第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one , 执行到 yield 就停下来，并将 yield 后边表达式的值 '1'，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。</p>\n<p>第二次调用 next 方法时，同上步 。</p>\n<p>第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为 true 。</p>\n<p>第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。</p>\n<h3 id=\"函数返回的遍历器对象的方法\"><a class=\"anchor\" href=\"#函数返回的遍历器对象的方法\">#</a> 函数返回的遍历器对象的方法</h3>\n<p><strong>next 方法</strong></p>\n<p>一般情况下，next 方法不传入参数的时候，yield 表达式的返回值是 undefined 。当 next 传入参数的时候，该参数会作为上一步 yield 的返回值。</p>\n<pre><code>function* sendParameter()&#123;\n    console.log(&quot;start&quot;);\n    var x = yield '2';\n    console.log(&quot;one:&quot; + x);\n    var y = yield '3';\n    console.log(&quot;two:&quot; + y);\n    console.log(&quot;total:&quot; + (x + y));\n&#125;\n</code></pre>\n<p>next 不传参</p>\n<pre><code>var sendp1 = sendParameter();\nsendp1.next();\n// start\n// &#123;value: &quot;2&quot;, done: false&#125;\nsendp1.next();\n// one:undefined\n// &#123;value: &quot;3&quot;, done: false&#125;\nsendp1.next();\n// two:undefined\n// total:NaN\n// &#123;value: undefined, done: true&#125;\nnext传参\nvar sendp2 = sendParameter();\nsendp2.next(10);\n// start\n// &#123;value: &quot;2&quot;, done: false&#125;\nsendp2.next(20);\n// one:20\n// &#123;value: &quot;3&quot;, done: false&#125;\nsendp2.next(30);\n// two:30\n// total:50\n// &#123;value: undefined, done: true&#125;\n</code></pre>\n<p>除了使用 next ，还可以使用 for... of 循环遍历 Generator 函数生产的 Iterator 对象。</p>\n<p><strong>return 方法</strong></p>\n<p>return 方法返回给定值，并结束遍历 Generator 函数。</p>\n<p>return 方法提供参数时，返回该参数；不提供参数时，返回 undefined 。</p>\n<pre><code>function* foo()&#123;\n    yield 1;\n    yield 2;\n    yield 3;\n&#125;\nvar f = foo();\nf.next();\n// &#123;value: 1, done: false&#125;\nf.return(&quot;foo&quot;);\n// &#123;value: &quot;foo&quot;, done: true&#125;\nf.next();\n// &#123;value: undefined, done: true&#125;\nthrow 方法\nthrow 方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获。\nvar g = function* () &#123;\n  try &#123;\n    yield;\n  &#125; catch (e) &#123;\n    console.log('catch inner', e);\n  &#125;\n&#125;;\n \nvar i = g();\ni.next();\n \ntry &#123;\n  i.throw('a');\n  i.throw('b');\n&#125; catch (e) &#123;\n  console.log('catch outside', e);\n&#125;\n// catch inner a\n// catch outside b\n</code></pre>\n<p>遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，第二个因为函数体内部的 catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。</p>\n<p><strong>yield* 表达式</strong></p>\n<p>yield* 表达式表示 yield 返回一个遍历器对象，用于在 Generator 函数内部，调用另一个 Generator 函数。</p>\n<pre><code>function* callee() &#123;\n    console.log('callee: ' + (yield));\n&#125;\nfunction* caller() &#123;\n    while (true) &#123;\n        yield* callee();\n    &#125;\n&#125;\nconst callerObj = caller();\ncallerObj.next();\n// &#123;value: undefined, done: false&#125;\ncallerObj.next(&quot;a&quot;);\n// callee: a\n// &#123;value: undefined, done: false&#125;\ncallerObj.next(&quot;b&quot;);\n// callee: b\n// &#123;value: undefined, done: false&#125;\n \n// 等同于\nfunction* caller() &#123;\n    while (true) &#123;\n        for (var value of callee) &#123;\n          yield value;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"使用场景\"><a class=\"anchor\" href=\"#使用场景\">#</a> 使用场景</h3>\n<p><strong>实现 Iterator</strong></p>\n<p>为不具备 Iterator 接口的对象提供遍历方法。</p>\n<pre><code>function* objectEntries(obj) &#123;\n    const propKeys = Reflect.ownKeys(obj);\n    for (const propKey of propKeys) &#123;\n        yield [propKey, obj[propKey]];\n    &#125;\n&#125;\n \nconst jane = &#123; first: 'Jane', last: 'Doe' &#125;;\nfor (const [key,value] of objectEntries(jane)) &#123;\n    console.log(`$&#123;key&#125;: $&#123;value&#125;`);\n&#125;\n// first: Jane\n// last: Doe\n</code></pre>\n<p>Reflect.ownKeys () 返回对象所有的属性，不管属性是否可枚举，包括 Symbol。</p>\n<p>jane 原生是不具备 Iterator 接口无法通过 for... of 遍历。这边用了 Generator 函数加上了 Iterator 接口，所以就可以遍历 jane 对象了。</p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/async%E5%87%BD%E6%95%B0/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/async%E5%87%BD%E6%95%B0/",
            "title": "async函数",
            "date_published": "2022-06-30T14:20:00.000Z",
            "content_html": "<h2 id=\"async\"><a class=\"anchor\" href=\"#async\">#</a> async</h2>\n<p>async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。</p>\n<h3 id=\"语法\"><a class=\"anchor\" href=\"#语法\">#</a> 语法</h3>\n<pre><code>async function name([param[, param[, ... param]]]) &#123; statements &#125;\n</code></pre>\n<ul>\n<li>name: 函数名称。</li>\n<li>param: 要传递给函数的参数的名称。</li>\n<li>statements: 函数体语句。</li>\n</ul>\n<h3 id=\"返回值\"><a class=\"anchor\" href=\"#返回值\">#</a> 返回值</h3>\n<p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数</p>\n<pre><code>async function helloAsync()&#123;\n    return &quot;helloAsync&quot;;\n  &#125;\n  \nconsole.log(helloAsync())  // Promise &#123;&lt;resolved&gt;: &quot;helloAsync&quot;&#125;\n \nhelloAsync().then(v=&gt;&#123;\n   console.log(v);         // helloAsync\n&#125;)\n</code></pre>\n<p>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</p>\n<p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p>\n<pre><code>function testAwait()&#123;\n   return new Promise((resolve) =&gt; &#123;\n       setTimeout(function()&#123;\n          console.log(&quot;testAwait&quot;);\n          resolve();\n       &#125;, 1000);\n   &#125;);\n&#125;\n \nasync function helloAsync()&#123;\n   await testAwait();\n   console.log(&quot;helloAsync&quot;);\n &#125;\nhelloAsync();\n// testAwait\n// helloAsync\n</code></pre>\n<h2 id=\"await\"><a class=\"anchor\" href=\"#await\">#</a> await</h2>\n<p>await 操作符用于等待一个 Promise 对象，它只能在异步函数 async function 内部使用。</p>\n<h3 id=\"语法-2\"><a class=\"anchor\" href=\"#语法-2\">#</a> 语法</h3>\n<pre><code>[return_value] = await expression;\n</code></pre>\n<ul>\n<li>expression: 一个 Promise 对象或者任何要等待的值。</li>\n</ul>\n<h3 id=\"返回值-2\"><a class=\"anchor\" href=\"#返回值-2\">#</a> 返回值</h3>\n<p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</p>\n<p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</p>\n<pre><code>function testAwait (x) &#123;\n  return new Promise(resolve =&gt; &#123;\n    setTimeout(() =&gt; &#123;\n      resolve(x);\n    &#125;, 2000);\n  &#125;);\n&#125;\n \nasync function helloAsync() &#123;\n  var x = await testAwait (&quot;hello world&quot;);\n  console.log(x); \n&#125;\nhelloAsync ();\n// hello world\n</code></pre>\n<p>正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。</p>\n<pre><code>function testAwait()&#123;\n   console.log(&quot;testAwait&quot;);\n&#125;\nasync function helloAsync()&#123;\n   await testAwait();\n   console.log(&quot;helloAsync&quot;);\n&#125;\nhelloAsync();\n// testAwait\n// helloAsync\n</code></pre>\n<p>await 针对所跟不同表达式的处理方式：</p>\n<ul>\n<li>Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。</li>\n<li>非 Promise 对象：直接返回对应的值。</li>\n</ul>\n<pre><code>async function a()&#123;  \n  console.log(&quot;1&quot;)  \n   console.log(&quot;2&quot;)\n&#125;\na()\nconsole.log(&quot;3&quot;)\n//打印： 1 2 3 \n</code></pre>\n<p>使用 await 测试：</p>\n<pre><code>async function a()&#123;  \n  await 1  \n  console.log(&quot;1&quot;)  \n  console.log(&quot;2&quot;)\n&#125;\na()\nconsole.log(&quot;3&quot;)\n//打印： 3 1 2\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2/",
            "title": "ES6字符串",
            "date_published": "2022-06-30T14:20:00.000Z",
            "content_html": "<h3 id=\"拓展的方法\"><a class=\"anchor\" href=\"#拓展的方法\">#</a> 拓展的方法</h3>\n<h3 id=\"子串的识别\"><a class=\"anchor\" href=\"#子串的识别\">#</a> 子串的识别</h3>\n<p>ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。</p>\n<ul>\n<li><strong>includes()</strong>：返回布尔值，判断是否找到参数字符串。</li>\n<li><strong>startsWith()</strong>：返回布尔值，判断参数字符串是否在原字符串的头部。</li>\n<li><strong>endsWith()</strong>：返回布尔值，判断参数字符串是否在原字符串的尾部。</li>\n</ul>\n<p>以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。</p>\n<pre><code>let string = &quot;apple,banana,orange&quot;;\nstring.includes(&quot;banana&quot;);     // true\nstring.startsWith(&quot;apple&quot;);    // true\nstring.endsWith(&quot;apple&quot;);      // false\nstring.startsWith(&quot;banana&quot;,6)  // true\n</code></pre>\n<p><strong>注意点：</strong></p>\n<ul>\n<li>这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。</li>\n<li>这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。</li>\n</ul>\n<h3 id=\"字符串重复\"><a class=\"anchor\" href=\"#字符串重复\">#</a> 字符串重复</h3>\n<p>repeat ()：返回新的字符串，表示将字符串重复指定次数返回。</p>\n<h3 id=\"字符串重复-2\"><a class=\"anchor\" href=\"#字符串重复-2\">#</a> 字符串重复</h3>\n<p>repeat ()：返回新的字符串，表示将字符串重复指定次数返回。</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(2));  // &quot;Hello,Hello,&quot;\n</code></pre>\n<p>如果参数是小数，向下取整</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(3.2));  // &quot;Hello,Hello,Hello,&quot;\n</code></pre>\n<p>如果参数是 0 至 -1 之间的小数，会进行取整运算，0 至 -1 之间的小数取整得到 -0 ，等同于 repeat 零次</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(-0.5));  // &quot;&quot; \n</code></pre>\n<p>如果参数是 NaN，等同于 repeat 零次</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(NaN));  // &quot;&quot; \n</code></pre>\n<p>如果参数是负数或者 Infinity ，会报错:</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(-1));  \n// RangeError: Invalid count value\n\nconsole.log(&quot;Hello,&quot;.repeat(Infinity));  \n// RangeError: Invalid count value\n</code></pre>\n<p>如果传入的参数是字符串，则会先将字符串转化为数字</p>\n<pre><code>console.log(&quot;Hello,&quot;.repeat(&quot;hh&quot;)); // &quot;&quot;\nconsole.log(&quot;Hello,&quot;.repeat(&quot;2&quot;));  // &quot;Hello,Hello,&quot;\n</code></pre>\n<h3 id=\"字符串补全\"><a class=\"anchor\" href=\"#字符串补全\">#</a> 字符串补全</h3>\n<ul>\n<li><strong>padStart</strong>：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。</li>\n<li><strong>padEnd</strong>：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。</li>\n</ul>\n<p>以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。</p>\n<pre><code>console.log(&quot;h&quot;.padStart(5,&quot;o&quot;));  // &quot;ooooh&quot;\nconsole.log(&quot;h&quot;.padEnd(5,&quot;o&quot;));    // &quot;hoooo&quot;\nconsole.log(&quot;h&quot;.padStart(5));      // &quot;    h&quot;\n</code></pre>\n<p>如果指定的长度小于或者等于原字符串的长度，则返回原字符串:</p>\n<pre><code>console.log(&quot;hello&quot;.padStart(5,&quot;A&quot;));  // &quot;hello&quot;\n</code></pre>\n<p>如果原字符串加上补全字符串长度大于指定长度，则截去超出位数的补全字符串:</p>\n<pre><code>console.log(&quot;hello&quot;.padEnd(10,&quot;,world!&quot;));  // &quot;hello,worl&quot;\n</code></pre>\n<p>常用于补全位数：</p>\n<pre><code>console.log(&quot;123&quot;.padStart(10,&quot;0&quot;));  // &quot;0000000123&quot;\n</code></pre>\n<h3 id=\"模板字符串\"><a class=\"anchor\" href=\"#模板字符串\">#</a> 模板字符串</h3>\n<p>模板字符串相当于加强版的字符串，用反引号 <strong>`</strong>, 除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。</p>\n<p><strong>基本用法</strong></p>\n<p>普通字符串</p>\n<pre><code>let string = `Hello'\\n'world`;\nconsole.log(string); \n// &quot;Hello'\n// 'world&quot;\n</code></pre>\n<p>多行字符串:</p>\n<pre><code>let string1 =  `Hey,\ncan you stop angry now?`;\nconsole.log(string1);\n// Hey,\n// can you stop angry now?\n</code></pre>\n<p>字符串插入变量和表达式。</p>\n<p>变量名写在 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mrow></mrow><mtext>中，</mtext></mrow><annotation encoding=\"application/x-tex\">{} 中，</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord\"></span><span class=\"mord cjk_fallback\">中</span><span class=\"mord cjk_fallback\">，</span></span></span></span>{} 中可以放入 JavaScript 表达式。</p>\n<pre><code>let name = &quot;Mike&quot;;\nlet age = 27;\nlet info = `My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`\nconsole.log(info);\n// My Name is Mike,I am 28 years old next year.\n</code></pre>\n<p>字符串中调用函数：</p>\n<pre><code>function f()&#123;\n  return &quot;have fun!&quot;;\n&#125;\nlet string2= `Game start,$&#123;f()&#125;`;\nconsole.log(string2);  // Game start,have fun!\n</code></pre>\n<p><strong>注意要点</strong></p>\n<p>模板字符串中的换行和空格都是会被保留的</p>\n<pre><code>innerHtml = `&lt;ul&gt;\n  &lt;li&gt;menu&lt;/li&gt;\n  &lt;li&gt;mine&lt;/li&gt;\n&lt;/ul&gt;\n`;\nconsole.log(innerHtml);\n// 输出\n&lt;ul&gt;\n &lt;li&gt;menu&lt;/li&gt;\n &lt;li&gt;mine&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n<h3 id=\"标签模板\"><a class=\"anchor\" href=\"#标签模板\">#</a> 标签模板</h3>\n<p>标签模板，是一个函数的调用，其中调用的参数是模板字符串</p>\n<pre><code>alert`Hello world!`;\n// 等价于\nalert('Hello world!');\n</code></pre>\n<p>当模板字符串中带有变量，会将模板字符串参数处理成多个参数</p>\n<pre><code>function f(stringArr,...values)&#123;\n let result = &quot;&quot;;\n for(let i=0;i&lt;stringArr.length;i++)&#123;\n  result += stringArr[i];\n  if(values[i])&#123;\n   result += values[i];\n        &#125;\n    &#125;\n return result;\n&#125;\nlet name = 'Mike';\nlet age = 27;\nf`My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`;\n// &quot;My Name is Mike,I am 28 years old next year.&quot;\n \nf`My Name is $&#123;name&#125;,I am $&#123;age+1&#125; years old next year.`;\n// 等价于\nf(['My Name is',',I am ',' years old next year.'],'Mike',28);\n</code></pre>\n<p><strong>应用</strong></p>\n<p>过滤 HTML 字符串，防止用户输入恶意内容</p>\n<pre><code>function f(stringArr,...values)&#123;\n let result = &quot;&quot;;\n for(let i=0;i&lt;stringArr.length;i++)&#123;\n  result += stringArr[i];\n   if(values[i])&#123;\n     result += String(values[i]).replace(/&amp;/g, &quot;&amp;amp;&quot;)\n               .replace(/&lt;/g, &quot;&amp;lt;&quot;)\n               .replace(/&gt;/g, &quot;&amp;gt;&quot;);\n    &#125;\n &#125;\n return result;\n&#125;\nname = '&lt;Amy&amp;MIke&gt;';\nf`&lt;p&gt;Hi, $&#123;name&#125;.I would like send you some message.&lt;/p&gt;`;\n// &lt;p&gt;Hi, &amp;lt;Amy&amp;amp;MIke&amp;gt;.I would like send you some message.&lt;/p&gt;\n</code></pre>\n<p><strong>国际化处理（转化多国语言）</strong></p>\n<pre><code>i18n`Hello $&#123;name&#125;, you are visitor number $&#123;visitorNumber&#125;.`;  \n// 你好**，你是第**位访问者\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E7%BB%84/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E7%BB%84/",
            "title": "ES6数组",
            "date_published": "2022-06-30T13:37:00.000Z",
            "content_html": "<h2 id=\"数组创建\"><a class=\"anchor\" href=\"#数组创建\">#</a> 数组创建</h2>\n<h3 id=\"arrayof\"><a class=\"anchor\" href=\"#arrayof\">#</a> Array.of()</h3>\n<p>将参数中所有值作为元素形成数组</p>\n<pre><code>console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]\n \n// 参数值可为不同类型\nconsole.log(Array.of(1, '2', true)); // [1, '2', true]\n \n// 参数为空时返回空数组\nconsole.log(Array.of()); // []\n</code></pre>\n<h3 id=\"arrayfrom\"><a class=\"anchor\" href=\"#arrayfrom\">#</a> Array.from()</h3>\n<p>将类数组对象或可迭代对象转化为数组。</p>\n<pre><code>// 参数为数组,返回与原数组一样的数组\nconsole.log(Array.from([1, 2])); // [1, 2]\n \n// 参数含空位\nconsole.log(Array.from([1, , 3])); // [1, undefined, 3]\n</code></pre>\n<p><strong>参数</strong></p>\n<pre><code>Array.from(arrayLike[, mapFn[, thisArg]])\n</code></pre>\n<p>返回值为转换后的数组。</p>\n<p><strong>arrayLike</strong></p>\n<p>想要转换的类数组对象或可迭代对象。</p>\n<pre><code>console.log(Array.from([1, 2, 3])); // [1, 2, 3]\n</code></pre>\n<p><strong>mapFn</strong></p>\n<p>可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素。</p>\n<pre><code>console.log(Array.from([1, 2, 3], (n) =&gt; n * 2)); // [2, 4, 6]\n</code></pre>\n<p><strong>thisArg</strong></p>\n<p>可选，用于指定 map 函数执行时的 this 对象。</p>\n<pre><code>let map = &#123;\n    do: function(n) &#123;\n        return n * 2;\n    &#125;\n&#125;\nlet arrayLike = [1, 2, 3];\nconsole.log(Array.from(arrayLike, function (n)&#123;\n    return this.do(n);\n&#125;, map)); // [2, 4, 6]\n</code></pre>\n<h3 id=\"类数组对象\"><a class=\"anchor\" href=\"#类数组对象\">#</a> 类数组对象</h3>\n<p>一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符</p>\n<pre><code>let arr = Array.from(&#123;\n  0: '1',\n  1: '2',\n  2: 3,\n  length: 3\n&#125;);\nconsole.log(arr); // ['1', '2', 3]\n \n// 没有 length 属性,则返回空数组\nlet array = Array.from(&#123;\n  0: '1',\n  1: '2',\n  2: 3,\n&#125;);\nconsole.log(array); // []\n \n// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  \nlet array1 = Array.from(&#123;\n  a: 1,\n  b: 2,\n  length: 2\n&#125;);\nconsole.log(array1); // [undefined, undefined]\n</code></pre>\n<h3 id=\"转换可迭代对象\"><a class=\"anchor\" href=\"#转换可迭代对象\">#</a> 转换可迭代对象</h3>\n<p><strong>转换 map</strong></p>\n<pre><code>let map = new Map();\nmap.set('key0', 'value0');\nmap.set('key1', 'value1');\nconsole.log(Array.from(map)); // [['key0', 'value0'],['key1',\n// 'value1']]\n</code></pre>\n<p><strong>转换 set</strong></p>\n<pre><code>let arr = [1, 2, 3];\nlet set = new Set(arr);\nconsole.log(Array.from(set)); // [1, 2, 3]\n</code></pre>\n<p><strong>转换字符串</strong></p>\n<pre><code>let str = 'abc';\nconsole.log(Array.from(str)); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n</code></pre>\n<h2 id=\"扩展的方法\"><a class=\"anchor\" href=\"#扩展的方法\">#</a> 扩展的方法</h2>\n<h3 id=\"查找\"><a class=\"anchor\" href=\"#查找\">#</a> 查找</h3>\n<p><strong>find()</strong></p>\n<p>查找数组中符合条件的元素，若有多个符合条件的元素，则返回第一个元素。</p>\n<pre><code>let arr = Array.of(1, 2, 3, 4);\nconsole.log(arr.find(item =&gt; item &gt; 2)); // 3\n \n// 数组空位处理为 undefined\nconsole.log([, 1].find(n =&gt; true)); // undefined\n</code></pre>\n<p><strong>findIndex()</strong></p>\n<p>查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。</p>\n<pre><code>let arr = Array.of(1, 2, 1, 3);\n// 参数1：回调函数\n// 参数2(可选)：指定回调函数中的 this 值\nconsole.log(arr.findIndex(item =&gt; item == 2)); // 1\n \n// 数组空位处理为 undefined\nconsole.log([, 1].findIndex(n =&gt; true)); //0\n</code></pre>\n<h3 id=\"填充\"><a class=\"anchor\" href=\"#填充\">#</a> 填充</h3>\n<p><strong>fill()</strong></p>\n<p>将一定范围索引的数组元素内容填充为单个指定的值。</p>\n<pre><code>let arr = Array.of(1, 2, 3, 4);\n// 参数1：用来填充的值\n// 参数2：被填充的起始索引\n// 参数3(可选)：被填充的结束索引，默认为数组末尾\nconsole.log(arr.fill(0,1,2)); // [1, 0, 3, 4]\n</code></pre>\n<p><strong>copyWithin()</strong></p>\n<p>将一定范围索引的数组元素修改为此数组另一指定范围索引的元素。</p>\n<pre><code>// 参数1：被修改的起始索引\n// 参数2：被用来覆盖的数据的起始索引\n// 参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾\nconsole.log([1, 2, 3, 4].copyWithin(0,2,4)); // [3, 4, 3, 4]\n \n// 参数1为负数表示倒数\nconsole.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1, 2, 1, 2]\n \nconsole.log([1, 2, ,4].copyWithin(0, 2, 4)); // [, 4, , 4]\n</code></pre>\n<h3 id=\"遍历\"><a class=\"anchor\" href=\"#遍历\">#</a> 遍历</h3>\n<p><strong>entries()</strong></p>\n<p>遍历键值对</p>\n<pre><code>for(let [key, value] of ['a', 'b'].entries())&#123;\n    console.log(key, value);\n&#125;\n// 0 &quot;a&quot;\n// 1 &quot;b&quot;\n \n// 不使用 for... of 循环\nlet entries = ['a', 'b'].entries();\nconsole.log(entries.next().value); // [0, &quot;a&quot;]\nconsole.log(entries.next().value); // [1, &quot;b&quot;]\n \n// 数组含空位\nconsole.log([...[,'a'].entries()]); // [[0, undefined], [1, &quot;a&quot;]]\n</code></pre>\n<p><strong>keys()</strong></p>\n<p>遍历键名。</p>\n<pre><code>for(let key of ['a', 'b'].keys())&#123;\n    console.log(key);\n&#125;\n// 0\n// 1\n \n// 数组含空位\nconsole.log([...[,'a'].keys()]); // [0, 1]\n</code></pre>\n<p><strong>values()</strong></p>\n<p>遍历键值。</p>\n<pre><code>for(let value of ['a', 'b'].values())&#123;\n    console.log(value);\n&#125;\n// &quot;a&quot;\n// &quot;b&quot;\n \n// 数组含空位\nconsole.log([...[,'a'].values()]); // [undefined, &quot;a&quot;]\n</code></pre>\n<h3 id=\"包含\"><a class=\"anchor\" href=\"#包含\">#</a> 包含</h3>\n<p><strong>includes()</strong></p>\n<p>数组是否包含指定值。</p>\n<p>注意：与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值；Map 的 has 方法用于查找键名</p>\n<pre><code>// 参数1：包含的指定值\n[1, 2, 3].includes(1);    // true\n \n// 参数2：可选，搜索的起始索引，默认为0\n[1, 2, 3].includes(1, 2); // false\n \n// NaN 的包含判断\n[1, NaN, 3].includes(NaN); // true\n</code></pre>\n<h3 id=\"嵌套数组转一维数组\"><a class=\"anchor\" href=\"#嵌套数组转一维数组\">#</a> 嵌套数组转一维数组</h3>\n<p><strong>flat()</strong></p>\n<pre><code>console.log([1 ,[2, 3]].flat()); // [1, 2, 3]\n \n// 指定转换的嵌套层数\nconsole.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]]\n \n// 不管嵌套多少层\nconsole.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]\n \n// 自动跳过空位\nconsole.log([1, [2, , 3]].flat());&lt;p&gt; // [1, 2, 3]\n</code></pre>\n<p><strong>flatMap()</strong></p>\n<p>先对数组中每个元素进行了的处理，再对数组执行 flat () 方法</p>\n<pre><code>// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组\n// 参数2：指定遍历函数中 this 的指向\nconsole.log([1, 2, 3].flatMap(n =&gt; [n * 2])); // [2, 4, 6]\n</code></pre>\n<h2 id=\"数组缓冲区\"><a class=\"anchor\" href=\"#数组缓冲区\">#</a> 数组缓冲区</h2>\n<p>数组缓冲区是内存中的一段地址。</p>\n<p>定型数组的基础。</p>\n<p>实际字节数在创建时确定，之后只可修改其中的数据，不可修改大小。</p>\n<h3 id=\"创建数组缓冲区\"><a class=\"anchor\" href=\"#创建数组缓冲区\">#</a> 创建数组缓冲区</h3>\n<p>通过构造函数创建:</p>\n<pre><code>let buffer = new ArrayBuffer(10);\nconsole.log(buffer.byteLength); // 10\n分割已有数组缓冲区\nlet buffer = new ArrayBuffer(10);\nlet buffer1 = buffer.slice(1, 3);\nconsole.log(buffer1.byteLength); // 2\n</code></pre>\n<h3 id=\"视图\"><a class=\"anchor\" href=\"#视图\">#</a> 视图</h3>\n<p>视图是用来操作内存的接口。</p>\n<p>视图可以操作数组缓冲区或缓冲区字节的子集，并按照其中一种数值数据类型来读取和写入数据。</p>\n<p>DataView 类型是一种通用的数组缓冲区视图，其支持所有 8 种数值型数据类型。</p>\n<p>创建:</p>\n<pre><code>// 默认 DataView 可操作数组缓冲区全部内容\nlet buffer = new ArrayBuffer(10);\n    dataView = new DataView(buffer); \ndataView.setInt8(0,1);\nconsole.log(dataView.getInt8(0)); // 1\n \n// 通过设定偏移量(参数2)与长度(参数3)指定 DataView 可操作的字节范围\nlet buffer1 = new ArrayBuffer(10);\n    dataView1 = new DataView(buffer1, 0, 3);\ndataView1.setInt8(5,1); // RangeError\n</code></pre>\n<h2 id=\"定型数组\"><a class=\"anchor\" href=\"#定型数组\">#</a> 定型数组</h2>\n<p>数组缓冲区的特定类型的视图。</p>\n<p>可以强制使用特定的数据类型，而不是使用通用的 DataView 对象来操作数组缓冲区。</p>\n<h3 id=\"创建\"><a class=\"anchor\" href=\"#创建\">#</a> 创建</h3>\n<p>通过数组缓冲区生成</p>\n<pre><code>let buffer = new ArrayBuffer(10),\n    view = new Int8Array(buffer);\nconsole.log(view.byteLength); // 10\n</code></pre>\n<p>通过构造函数</p>\n<pre><code>let view = new Int32Array(10);\nconsole.log(view.byteLength); // 40\nconsole.log(view.length);     // 10\n \n// 不传参则默认长度为0\n// 在这种情况下数组缓冲区分配不到空间，创建的定型数组不能用来保存数据\nlet view1 = new Int32Array();\nconsole.log(view1.byteLength); // 0\nconsole.log(view1.length);     // 0\n \n// 可接受参数包括定型数组、可迭代对象、数组、类数组对象\nlet arr = Array.from(&#123;\n  0: '1',\n  1: '2',\n  2: 3,\n  length: 3\n&#125;);\nlet view2 = new Int16Array([1, 2]),\n    view3 = new Int32Array(view2),\n    view4 = new Int16Array(new Set([1, 2, 3])),\n    view5 = new Int16Array([1, 2, 3]),\n    view6 = new Int16Array(arr);\nconsole.log(view2 .buffer === view3.buffer); // false\nconsole.log(view4.byteLength); // 6\nconsole.log(view5.byteLength); // 6\nconsole.log(view6.byteLength); // 6\n</code></pre>\n<h3 id=\"注意要点\"><a class=\"anchor\" href=\"#注意要点\">#</a> 注意要点</h3>\n<p>length 属性不可写，如果尝试修改这个值，在非严格模式下会直接忽略该操作，在严格模式下会抛出错误</p>\n<pre><code>let view = new Int16Array([1, 2]);\nview.length = 3;\nconsole.log(view.length); // 2\n</code></pre>\n<p>定型数组可使用 entries ()、keys ()、values () 进行迭代</p>\n<pre><code>let view = new Int16Array([1, 2]);\nfor(let [k, v] of view.entries())&#123;\n    console.log(k, v);\n&#125;\n// 0 1\n// 1 2\n</code></pre>\n<p>find () 等方法也可用于定型数组，但是定型数组中的方法会额外检查数值类型是否安全，也会通过 Symbol.species 确认方法的返回值是定型数组而非普通数组。concat () 方法由于两个定型数组合并结果不确定，故不能用于定型数组；另外，由于定型数组的尺寸不可更改，可以改变数组的尺寸的方法，例如 splice () ，不适用于定型数组。</p>\n<pre><code>let view = new Int16Array([1, 2]);\nview.find((n) &gt; 1); // 2\n</code></pre>\n<p>所有定型数组都含有静态 of () 方法和 from () 方法，运行效果分别与 Array.of () 方法和 Array.from () 方法相似，区别是定型数组的方法返回定型数组，而普通数组的方法返回普通数组。</p>\n<pre><code>let view = Int16Array.of(1, 2);\nconsole.log(view instanceof Int16Array); // true\n</code></pre>\n<p>定型数组不是普通数组，不继承自 Array</p>\n<pre><code>let view = new Int16Array([1, 2]);\nconsole.log(Array.isArray(view)); // false\n</code></pre>\n<p>定型数组中增加了 set () 与 subarray () 方法。 set () 方法用于将其他数组复制到已有定型数组，subarray () 用于提取已有定型数组的一部分形成新的定型数组。</p>\n<pre><code>// set 方法\n// 参数1：一个定型数组或普通数组\n// 参数2：可选，偏移量，开始插入数据的位置，默认为0\nlet view= new Int16Array(4);\nview.set([1, 2]);\nview.set([3, 4], 2);\nconsole.log(view); // [1, 2, 3, 4]\n \n// subarray 方法\n// 参数1：可选，开始位置\n// 参数2：可选，结束位置(不包含结束位置)\nlet view= new Int16Array([1, 2, 3, 4]), \n    subview1 = view.subarray(), \n    subview2 = view.subarray(1), \n    subview3 = view.subarray(1, 3);\nconsole.log(subview1); // [1, 2, 3, 4]\nconsole.log(subview2); // [2, 3, 4]\nconsole.log(subview3); // [2, 3]\n</code></pre>\n<h2 id=\"扩展运算符\"><a class=\"anchor\" href=\"#扩展运算符\">#</a> 扩展运算符</h2>\n<h3 id=\"复制数组\"><a class=\"anchor\" href=\"#复制数组\">#</a> 复制数组</h3>\n<pre><code>let arr = [1, 2],\n    arr1 = [...arr];\nconsole.log(arr1); // [1, 2]\n \n// 数组含空位\nlet arr2 = [1, , 3],\n    arr3 = [...arr2];\nconsole.log(arr3); [1, undefined, 3]\n</code></pre>\n<p>合并数组</p>\n<pre><code>console.log([...[1, 2],...[3, 4]]); // [1, 2, 3, 4]\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/",
            "title": "ES6解构赋值",
            "date_published": "2022-06-30T13:37:00.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>解构赋值是对赋值运算符的扩展。</p>\n<p>他是一种针对数组或者对象进行模式匹配，然后对其中的变量进行赋值。</p>\n<p>在代码书写上简洁且易读，语义更加清晰明了；也方便了复杂对象中数据字段获取。</p>\n<hr>\n<h2 id=\"解构模型\"><a class=\"anchor\" href=\"#解构模型\">#</a> 解构模型</h2>\n<p>在解构中，有下面两部分参与：</p>\n<p>解构的源，解构赋值表达式的右边部分。解构的目标，解构赋值表达式的左边部分。</p>\n<hr>\n<h2 id=\"数组模型的解构array\"><a class=\"anchor\" href=\"#数组模型的解构array\">#</a> 数组模型的解构（Array）</h2>\n<p><strong>基本</strong></p>\n<pre><code>let [a, b, c] = [1, 2, 3]; // a = 1 // b = 2 // c = 3\n</code></pre>\n<p><strong>可嵌套</strong></p>\n<pre><code>let [a, [[b], c]] = [1, [[2], 3]]; // a = 1 // b = 2 // c = 3\n</code></pre>\n<p><strong>可忽略</strong></p>\n<pre><code>let [a, , b] = [1, 2, 3]; // a = 1 // b = 3\n</code></pre>\n<p><strong>不完全解构</strong></p>\n<pre><code>let [a = 1, b] = []; // a = 1, b = undefined\n</code></pre>\n<p><strong>剩余运算符</strong></p>\n<pre><code>let [a, ...b] = [1, 2, 3]; //a = 1 //b = [2, 3]\n</code></pre>\n<p><strong>字符串等</strong></p>\n<p>在数组的解构中，解构的目标若为可遍历对象，皆可进行解构赋值。可遍历对象即实现 Iterator 接口的数据。</p>\n<pre><code>let [a, b, c, d, e] = 'hello'; // a = 'h' // b = 'e' // c = 'l' // d = 'l' // e = 'o'\n</code></pre>\n<p><strong>解构默认值</strong></p>\n<pre><code>let [a = 2] = [undefined]; // a = 2\n</code></pre>\n<p>当解构模式有匹配结果，且匹配结果是 undefined 时，会触发默认值作为返回结果。</p>\n<pre><code>let [a = 3, b = a] = [];     // a = 3, b = 3 \nlet [a = 3, b = a] = [1];    // a = 1, b = 1 \nlet [a = 3, b = a] = [1, 2]; // a = 1, b = 2\n</code></pre>\n<ul>\n<li>a 与 b 匹配结果为 undefined ，触发默认值：<strong>a = 3; b = a =3</strong></li>\n<li>a 正常解构赋值，匹配结果：a = 1，b 匹配结果 undefined ，触发默认值：<strong>b = a =1</strong></li>\n<li>a 与 b 正常解构赋值，匹配结果：<strong>a = 1，b = 2</strong></li>\n</ul>\n<hr>\n<h2 id=\"对象模型的解构object\"><a class=\"anchor\" href=\"#对象模型的解构object\">#</a> 对象模型的解构（Object）</h2>\n<p><strong>基本</strong></p>\n<pre><code>let &#123; foo, bar &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;; // foo = 'aaa' // bar = 'bbb'  let &#123; baz : foo &#125; = &#123; baz : 'ddd' &#125;; // foo = 'ddd'\n</code></pre>\n<p><strong>可嵌套可忽略</strong></p>\n<pre><code>let obj = &#123;p: ['hello', &#123;y: 'world'&#125;] &#125;; \nlet &#123;p: [x, &#123; y &#125;] &#125; = obj; // x = 'hello' // y = 'world' \nlet obj = &#123;p: ['hello', &#123;y: 'world'&#125;] &#125;; \nlet &#123;p: [x, &#123;  &#125;] &#125; = obj; // x = 'hello'\n</code></pre>\n<p><strong>不完全解构</strong></p>\n<pre><code>let obj = &#123;p: [&#123;y: 'world'&#125;] &#125;; \nlet &#123;p: [&#123; y &#125;, x ] &#125; = obj; // x = undefined // y = 'world'\n</code></pre>\n<p><strong>剩余运算符</strong></p>\n<pre><code>let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;; // a = 10 // b = 20 // rest = &#123;c: 30, d: 40&#125;\n</code></pre>\n<p><strong>解构默认值</strong></p>\n<pre><code>let &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;; // a = 3; b = 5; \nlet &#123;a: aa = 10, b: bb = 5&#125; = &#123;a: 3&#125;; // aa = 3; bb = 5;\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E5%80%BC/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E5%80%BC/",
            "title": "ES6数值",
            "date_published": "2022-06-30T13:37:00.000Z",
            "content_html": "<h2 id=\"数值的表示\"><a class=\"anchor\" href=\"#数值的表示\">#</a> 数值的表示</h2>\n<p>二进制表示法新写法：前缀 0b 或 0B 。</p>\n<pre><code>console.log(0b11 === 3); // true\nconsole.log(0B11 === 3); // true\n</code></pre>\n<p>八进制表示法新写法：前缀 0o 或 0O 。</p>\n<pre><code>console.log(0o11 === 9); // true\nconsole.log(0O11 === 9); // true\n</code></pre>\n<h3 id=\"常量\"><a class=\"anchor\" href=\"#常量\">#</a> 常量</h3>\n<pre><code>Number.EPSILON\n</code></pre>\n<p>Number.EPSILON 属性表示 1 与大于 1 的最小浮点数之间的差。</p>\n<p>它的值接近于 2.2204460492503130808472633361816E-16，或者 2-52。</p>\n<p>测试数值是否在误差范围内:</p>\n<pre><code>0.1 + 0.2 === 0.3; // false\n// 在误差范围内即视为相等\nequal = (Math.abs(0.1 - 0.3 + 0.2) &lt; Number.EPSILON); // true\n</code></pre>\n<h3 id=\"属性特性\"><a class=\"anchor\" href=\"#属性特性\">#</a> 属性特性</h3>\n<pre><code>writable：false\nenumerable：false\nconfigurable：false\n</code></pre>\n<h3 id=\"最大最小安全整数\"><a class=\"anchor\" href=\"#最大最小安全整数\">#</a> 最大 / 最小安全整数</h3>\n<p><strong>安全整数</strong></p>\n<p>安全整数表示在 JavaScript 中能够精确表示的整数，安全整数的范围在 2 的 -53 次方到 2 的 53 次方之间（不包括两个端点），超过这个范围的整数无法精确表示。</p>\n<p><strong>最大安全整数</strong></p>\n<p>安全整数范围的上限，即 2 的 53 次方减 1 。</p>\n<pre><code>Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true\nNumber.MAX_SAFE_INTEGER === Number.MAX_SAFE_INTEGER + 1;     // false\nNumber.MAX_SAFE_INTEGER - 1 === Number.MAX_SAFE_INTEGER - 2; // false\n</code></pre>\n<p><strong>最小安全整数</strong></p>\n<p>安全整数范围的下限，即 2 的 53 次方减 1 的负数。</p>\n<pre><code>Number.MIN_SAFE_INTEGER + 1 === Number.MIN_SAFE_INTEGER + 2; // false\nNumber.MIN_SAFE_INTEGER === Number.MIN_SAFE_INTEGER - 1;     // false\nNumber.MIN_SAFE_INTEGER - 1 === Number.MIN_SAFE_INTEGER - 2; // true\n</code></pre>\n<p><strong>属性特性</strong></p>\n<pre><code>writable：false\nenumerable：false\nconfigurable：false\n</code></pre>\n<h3 id=\"方法\"><a class=\"anchor\" href=\"#方法\">#</a> 方法</h3>\n<p><strong>Number 对象新方法</strong></p>\n<pre><code>Number.isFinite()\n</code></pre>\n<p>用于检查一个数值是否为有限的（ finite ），即不是 Infinity</p>\n<pre><code>console.log( Number.isFinite(1));   // true\nconsole.log( Number.isFinite(0.1)); // true\n \n// NaN 不是有限的\nconsole.log( Number.isFinite(NaN)); // false\n \nconsole.log( Number.isFinite(Infinity));  // false\nconsole.log( Number.isFinite(-Infinity)); // false\n \n// Number.isFinate 没有隐式的 Number() 类型转换，所有非数值都返回 false\nconsole.log( Number.isFinite('foo')); // false\nconsole.log( Number.isFinite('15'));  // false\nconsole.log( Number.isFinite(true));  // false\nNumber.isNaN()\n用于检查一个值是否为 NaN 。\nconsole.log(Number.isNaN(NaN));      // true\nconsole.log(Number.isNaN('true'/0)); // true\n \n// 在全局的 isNaN() 中，以下皆返回 true，因为在判断前会将非数值向数值转换\n// 而 Number.isNaN() 不存在隐式的 Number() 类型转换，非 NaN 全部返回 false\nNumber.isNaN(&quot;NaN&quot;);      // false\nNumber.isNaN(undefined);  // false\nNumber.isNaN(&#123;&#125;);         // false\nNumber.isNaN(&quot;true&quot;);     // false\n</code></pre>\n<p><strong>从全局移植到 Number 对象的方法</strong></p>\n<p>逐步减少全局方法，用于全局变量的模块化。</p>\n<p>方法的行为没有发生改变。</p>\n<pre><code>Number.parseInt()\n</code></pre>\n<p>用于将给定字符串转化为指定进制的整数</p>\n<pre><code>// 不指定进制时默认为 10 进制\nNumber.parseInt('12.34'); // 12\nNumber.parseInt(12.34);   // 12\n \n// 指定进制\nNumber.parseInt('0011',2); // 3\n \n// 与全局的 parseInt() 函数是同一个函数\nNumber.parseInt === parseInt; // true\nNumber.parseFloat()\n用于把一个字符串解析成浮点数。\nNumber.parseFloat('123.45')    // 123.45\nNumber.parseFloat('123.45abc') // 123.45\n \n// 无法被解析成浮点数，则返回 NaN\nNumber.parseFloat('abc') // NaN\n \n// 与全局的 parseFloat() 方法是同一个方法\nNumber.parseFloat === parseFloat // true\nNumber.isInteger()\n用于判断给定的参数是否为整数。\nNumber.isInteger(value)\nNumber.isInteger(0); // true\n// JavaScript 内部，整数和浮点数采用的是同样的储存方法,因此 1 与 1.0 被视为相同的值\nNumber.isInteger(1);   // true\nNumber.isInteger(1.0); // true\n \nNumber.isInteger(1.1);     // false\nNumber.isInteger(Math.PI); // false\n \n// NaN 和正负 Infinity 不是整数\nNumber.isInteger(NaN);       // false\nNumber.isInteger(Infinity);  // false\nNumber.isInteger(-Infinity); // false\n \nNumber.isInteger(&quot;10&quot;);  // false\nNumber.isInteger(true);  // false\nNumber.isInteger(false); // false\nNumber.isInteger([1]);   // false\n \n// 数值的精度超过 53 个二进制位时，由于第 54 位及后面的位被丢弃，会产生误判\nNumber.isInteger(1.0000000000000001) // true\n \n// 一个数值的绝对值小于 Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨\n// 的最小值，会被自动转为 0，也会产生误判\nNumber.isInteger(5E-324); // false\nNumber.isInteger(5E-325); // true\nNumber.isSafeInteger()\n用于判断数值是否在安全范围内。\nNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1); // false\nNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1); // false\n</code></pre>\n<h2 id=\"math-对象的扩展\"><a class=\"anchor\" href=\"#math-对象的扩展\">#</a> Math 对象的扩展</h2>\n<p>ES6 在 Math 对象上新增了 17 个数学相关的静态方法，这些方法只能在 Math 中调用。</p>\n<p><strong>普通计算</strong></p>\n<pre><code>Math.cbrt\n</code></pre>\n<p>用于计算一个数的立方根。</p>\n<pre><code>Math.cbrt(1);  // 1\nMath.cbrt(0);  // 0\nMath.cbrt(-1); // -1\n// 会对非数值进行转换\nMath.cbrt('1'); // 1\n \n// 非数值且无法转换为数值时返回 NaN\nMath.cbrt('hhh'); // NaN\n</code></pre>\n<pre><code>Math.imul\n</code></pre>\n<p>两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>\n<pre><code>// 大多数情况下，结果与 a * b 相同 \nMath.imul(1, 2);   // 2\n \n// 用于正确返回大数乘法结果中的低位数值\nMath.imul(0x7fffffff, 0x7fffffff); // 1\n</code></pre>\n<pre><code>Math.hypot\n</code></pre>\n<p>用于计算所有参数的平方和的平方根。</p>\n<pre><code>Math.hypot(3, 4); // 5\n \n// 非数值会先被转换为数值后进行计算\nMath.hypot(1, 2, '3'); // 3.741657386773941\nMath.hypot(true);      // 1\nMath.hypot(false);     // 0\n \n// 空值会被转换为 0\nMath.hypot();   // 0\nMath.hypot([]); // 0\n \n// 参数为 Infinity 或 -Infinity 返回 Infinity\nMath.hypot(Infinity); // Infinity\nMath.hypot(-Infinity); // Infinity\n \n// 参数中存在无法转换为数值的参数时返回 NaN\nMath.hypot(NaN);         // NaN\nMath.hypot(3, 4, 'foo'); // NaN\nMath.hypot(&#123;&#125;);          // NaN\n</code></pre>\n<pre><code>Math.clz32\n</code></pre>\n<p>用于返回数字的 32 位无符号整数形式的前导 0 的个数。</p>\n<pre><code>Math.clz32(0); // 32\nMath.clz32(1); // 31\nMath.clz32(0b01000000000100000000000000000000); // 1\n \n// 当参数为小数时，只考虑整数部分\nMath.clz32(0.5); // 32\n \n// 对于空值或非数值，会转化为数值再进行计算\nMath.clz32('1');       // 31\nMath.clz32();          // 32\nMath.clz32([]);        // 32\nMath.clz32(&#123;&#125;);        // 32\nMath.clz32(NaN);       // 32\nMath.clz32(Infinity);  // 32\nMath.clz32(-Infinity); // 32\nMath.clz32(undefined); // 32\nMath.clz32('hhh');     // 32\n</code></pre>\n<h3 id=\"数字处理\"><a class=\"anchor\" href=\"#数字处理\">#</a> 数字处理</h3>\n<pre><code>Math.trunc\n</code></pre>\n<p>用于返回数字的整数部分。</p>\n<pre><code>Math.trunc(12.3); // 12\nMath.trunc(12);   // 12\n \n// 整数部分为 0 时也会判断符号\nMath.trunc(-0.5); // -0\nMath.trunc(0.5);  // 0\n \n// Math.trunc 会将非数值转为数值再进行处理\nMath.trunc(&quot;12.3&quot;); // 12\n \n// 空值或无法转化为数值时时返回 NaN\nMath.trunc();           // NaN\nMath.trunc(NaN);        // NaN\nMath.trunc(&quot;hhh&quot;);      // NaN\nMath.trunc(&quot;123.2hhh&quot;); // NaN\n</code></pre>\n<pre><code>Math.fround\n</code></pre>\n<p>用于获取数字的 32 位单精度浮点数形式。</p>\n<pre><code>// 对于 2 的 24 次方取负至 2 的 24 次方之间的整数（不含两个端点），返回结果与参数本身一致\nMath.fround(-(2**24)+1);  // -16777215\nMath.fround(2 ** 24 - 1); // 16777215\n \n// 用于将 64 位双精度浮点数转为 32 位单精度浮点数\nMath.fround(1.234) // 1.125\n// 当小数的精度超过 24 个二进制位，会丢失精度\nMath.fround(0.3); // 0.30000001192092896\n// 参数为 NaN 或 Infinity 时返回本身\nMath.fround(NaN)      // NaN\nMath.fround(Infinity) // Infinity\n \n// 参数为其他非数值类型时会将参数进行转换 \nMath.fround('5');  // 5\nMath.fround(true); // 1\nMath.fround(null); // 0\nMath.fround([]);   // 0\nMath.fround(&#123;&#125;);   // NaN\n</code></pre>\n<h3 id=\"判断\"><a class=\"anchor\" href=\"#判断\">#</a> 判断</h3>\n<pre><code>Math.sign\n</code></pre>\n<p>判断数字的符号（正、负、0）。</p>\n<pre><code>Math.sign(1);  // 1\nMath.sign(-1); // -1\n \n// 参数为 0 时，不同符号的返回不同\nMath.sign(0);  // 0\nMath.sign(-0); // -0\n \n// 判断前会对非数值进行转换\nMath.sign('1');  // 1\nMath.sign('-1'); // -1  \n \n// 参数为非数值（无法转换为数值）时返回 NaN\nMath.sign(NaN);   // NaN \nMath.sign('hhh'); // NaN\n</code></pre>\n<h3 id=\"对数方法\"><a class=\"anchor\" href=\"#对数方法\">#</a> 对数方法</h3>\n<pre><code>Math.expm1()\n</code></pre>\n<p>用于计算 e 的 x 次方减 1 的结果，即 Math.exp (x) - 1 。</p>\n<pre><code>Math.expm1(1);  // 1.718281828459045\nMath.expm1(0);  // 0\nMath.expm1(-1); // -0.6321205588285577\n// 会对非数值进行转换\nMath.expm1('0'); //0\n \n// 参数不为数值且无法转换为数值时返回 NaN\nMath.expm1(NaN); // NaN\n</code></pre>\n<pre><code>Math.log1p(x)\n</code></pre>\n<p>用于计算 1 + x 的自然对数，即 Math.log (1 + x) 。</p>\n<pre><code>Math.log1p(1);  // 0.6931471805599453\nMath.log1p(0);  // 0\nMath.log1p(-1); // -Infinity\n \n// 参数小于 -1 时返回 NaN\nMath.log1p(-2); // NaN\n</code></pre>\n<pre><code>Math.log10(x)\n</code></pre>\n<p>用于计算以 10 为底的 x 的对数。</p>\n<pre><code>Math.log10(1);   // 0\n// 计算前对非数值进行转换\nMath.log10('1'); // 0\n// 参数为0时返回 -Infinity\nMath.log10(0);   // -Infinity\n// 参数小于0或参数不为数值（且无法转换为数值）时返回 NaN\nMath.log10(-1);  // NaN\n</code></pre>\n<pre><code>Math.log2()\n</code></pre>\n<p>用于计算 2 为底的 x 的对数。</p>\n<pre><code>Math.log2(1);   // 0\n// 计算前对非数值进行转换\nMath.log2('1'); // 0\n// 参数为0时返回 -Infinity\nMath.log2(0);   // -Infinity\n// 参数小于0或参数不为数值（且无法转换为数值）时返回 NaN\nMath.log2(-1);  // NaN\n</code></pre>\n<h3 id=\"双曲函数方法\"><a class=\"anchor\" href=\"#双曲函数方法\">#</a> 双曲函数方法</h3>\n<ul>\n<li>Math.sinh (x): 用于计算双曲正弦。</li>\n<li>Math.cosh (x): 用于计算双曲余弦。</li>\n<li>Math.tanh (x): 用于计算双曲正切。</li>\n<li>Math.asinh (x): 用于计算反双曲正弦。</li>\n<li>Math.acosh (x): 用于计算反双曲余弦。</li>\n<li>Math.atanh (x): 用于计算反双曲正切。</li>\n</ul>\n<h3 id=\"指数运算符\"><a class=\"anchor\" href=\"#指数运算符\">#</a> 指数运算符</h3>\n<pre><code>1 ** 2; // 1\n// 右结合，从右至左计算\n2 ** 2 ** 3; // 256\n// **=\nlet exam = 2;\nexam ** = 2; // 4\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%A8%A1%E5%9D%97/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%A8%A1%E5%9D%97/",
            "title": "ES6模块",
            "date_published": "2022-06-30T13:37:00.000Z",
            "content_html": "<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。</p>\n<p>ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>\n<p>ES6 的模块化分为导出（export） @与导入（import）两个模块。</p>\n<h2 id=\"特点\"><a class=\"anchor\" href=\"#特点\">#</a> 特点</h2>\n<p>ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 <strong>use strict;</strong>。</p>\n<p>模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。</p>\n<p>每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。</p>\n<p>每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。</p>\n<h2 id=\"export-与-import\"><a class=\"anchor\" href=\"#export-与-import\">#</a> export 与 import</h2>\n<h3 id=\"基本用法\"><a class=\"anchor\" href=\"#基本用法\">#</a> 基本用法</h3>\n<p>模块导入导出各种类型的变量，如字符串，数值，函数，类。</p>\n<ul>\n<li>导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。</li>\n<li>不仅能导出声明还能导出引用（例如函数）。</li>\n<li>export 命令可以出现在模块的任何位置，但必需处于模块顶层。</li>\n<li>import 命令会提升到整个模块的头部，首先执行。</li>\n</ul>\n<pre><code>/*-----export [test.js]-----*/\nlet myName = &quot;Tom&quot;;\nlet myAge = 20;\nlet myfn = function()&#123;\n    return &quot;My name is&quot; + myName + &quot;! I'm '&quot; + myAge + &quot;years old.&quot;\n&#125;\nlet myClass =  class myClass &#123;\n    static a = &quot;yeah!&quot;;\n&#125;\nexport &#123; myName, myAge, myfn, myClass &#125;\n \n/*-----import [xxx.js]-----*/\nimport &#123; myName, myAge, myfn, myClass &#125; from &quot;./test.js&quot;;\nconsole.log(myfn());// My name is Tom! I'm 20 years old.\nconsole.log(myAge);// 20\nconsole.log(myName);// Tom\nconsole.log(myClass.a );// yeah!\n</code></pre>\n<p>建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。</p>\n<p>函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。</p>\n<h3 id=\"as-的用法\"><a class=\"anchor\" href=\"#as-的用法\">#</a> as 的用法</h3>\n<p>export 命令导出的接口名称，须和模块内部的变量有一一对应关系。</p>\n<p>导入的变量名，须和导出的接口名称相同，即顺序可以不一致。</p>\n<pre><code>/*-----export [test.js]-----*/\nlet myName = &quot;Tom&quot;;\nexport &#123; myName as exportName &#125;\n \n/*-----import [xxx.js]-----*/\nimport &#123; exportName &#125; from &quot;./test.js&quot;;\nconsole.log(exportName);// Tom\n使用 as 重新定义导出的接口名称，隐藏模块内部的变量\n/*-----export [test1.js]-----*/\nlet myName = &quot;Tom&quot;;\nexport &#123; myName &#125;\n/*-----export [test2.js]-----*/\nlet myName = &quot;Jerry&quot;;\nexport &#123; myName &#125;\n/*-----import [xxx.js]-----*/\nimport &#123; myName as name1 &#125; from &quot;./test1.js&quot;;\nimport &#123; myName as name2 &#125; from &quot;./test2.js&quot;;\nconsole.log(name1);// Tom\nconsole.log(name2);// Jerry\n</code></pre>\n<p>不同模块导出接口名称命名重复， 使用 as 重新定义变量名。</p>\n<h3 id=\"import-命令的特点\"><a class=\"anchor\" href=\"#import-命令的特点\">#</a> import 命令的特点</h3>\n<p><strong>只读属性</strong>：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。</p>\n<pre><code>import &#123;a&#125; from &quot;./xxx.js&quot;\na = &#123;&#125;; // error\n \nimport &#123;a&#125; from &quot;./xxx.js&quot;\na.foo = &quot;hello&quot;; // a = &#123; foo : 'hello' &#125;\n</code></pre>\n<p><strong>单例模式</strong>：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。</p>\n<pre><code>import &#123; a &#125; &quot;./xxx.js&quot;;\nimport &#123; a &#125; &quot;./xxx.js&quot;;\n// 相当于 import &#123; a &#125; &quot;./xxx.js&quot;;\n \nimport &#123; a &#125; from &quot;./xxx.js&quot;;\nimport &#123; b &#125; from &quot;./xxx.js&quot;;\n// 相当于 import &#123; a, b &#125; from &quot;./xxx.js&quot;;\n</code></pre>\n<p>静态执行特性：import 是静态执行，所以不能使用表达式和变量。</p>\n<pre><code>import &#123; &quot;f&quot; + &quot;oo&quot; &#125; from &quot;methods&quot;;\n// error\nlet module = &quot;methods&quot;;\nimport &#123; foo &#125; from module;\n// error\nif (true) &#123;\n  import &#123; foo &#125; from &quot;method1&quot;;\n&#125; else &#123;\n  import &#123; foo &#125; from &quot;method2&quot;;\n&#125;\n// error\n</code></pre>\n<h3 id=\"export-default-命令\"><a class=\"anchor\" href=\"#export-default-命令\">#</a> export default 命令</h3>\n<ul>\n<li>在一个文件或模块中，export、import 可以有多个，export default 仅有一个。</li>\n<li>export default 中的 default 是对应的导出接口变量。</li>\n<li>通过 export 方式导出，在导入时要加 { }，export default 则不需要。</li>\n<li>export default 向外暴露的成员，可以使用任意变量来接收。</li>\n</ul>\n<pre><code>var a = &quot;My name is Tom!&quot;;\nexport default a; // 仅有一个\nexport default var c = &quot;error&quot;; \n// error，default 已经是对应的导出变量，不能跟着变量声明语句\n \nimport b from &quot;./xxx.js&quot;; // 不需要加&#123;&#125;， 使用任意变量接收\n</code></pre>\n<h2 id=\"复合使用\"><a class=\"anchor\" href=\"#复合使用\">#</a> 复合使用</h2>\n<blockquote>\n<p><strong>注</strong>：import () 是提案，这边暂时不延伸讲解。</p>\n</blockquote>\n<p>export 与 import 可以在同一模块使用，使用特点：</p>\n<ul>\n<li>\n<p>可以将导出接口改名，包括 default。</p>\n</li>\n<li>\n<p>复合使用 export 与 import ，也可以导出全部，当前模块导出的接口会覆盖继承导出的。</p>\n</li>\n<li>\n<pre><code> export &#123; foo, bar &#125; from &quot;methods&quot;;\n  \n // 约等于下面两段语句，不过上面导入导出方式该模块没有导入 foo 与 bar\n import &#123; foo, bar &#125; from &quot;methods&quot;;\n export &#123; foo, bar &#125;;\n  \n /* ------- 特点 1 --------*/\n // 普通改名\n export &#123; foo as bar &#125; from &quot;methods&quot;;\n // 将 foo 转导成 default\n export &#123; foo as default &#125; from &quot;methods&quot;;\n // 将 default 转导成 foo\n export &#123; default as foo &#125; from &quot;methods&quot;;\n  \n /* ------- 特点 2 --------*/\n export * from &quot;methods&quot;;\n</code></pre>\n</li>\n</ul>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/AJAX/XHR%E5%93%8D%E5%BA%94/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/AJAX/XHR%E5%93%8D%E5%BA%94/",
            "title": "XHR响应",
            "date_published": "2022-06-30T13:36:00.000Z",
            "content_html": "<h1 id=\"ajax-服务器-响应\"><a class=\"anchor\" href=\"#ajax-服务器-响应\">#</a> AJAX - 服务器 响应</h1>\n<hr>\n<h2 id=\"服务器响应\"><a class=\"anchor\" href=\"#服务器响应\">#</a> 服务器响应</h2>\n<p>如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">responseText</td>\n<td style=\"text-align:left\">获得字符串形式的响应数据。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">responseXML</td>\n<td style=\"text-align:left\">获得 XML 形式的响应数据。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"responsetext-属性\"><a class=\"anchor\" href=\"#responsetext-属性\">#</a> responseText 属性</h2>\n<p>如果来自服务器的响应并非 XML，请使用 responseText 属性。</p>\n<h2 id=\"responsexml-属性\"><a class=\"anchor\" href=\"#responsexml-属性\">#</a> responseXML 属性</h2>\n<p>如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性：</p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "AJAX"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%87%BD%E6%95%B0/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%87%BD%E6%95%B0/",
            "title": "ES6函数",
            "date_published": "2022-06-30T13:36:00.000Z",
            "content_html": "<h2 id=\"函数参数的扩展\"><a class=\"anchor\" href=\"#函数参数的扩展\">#</a> 函数参数的扩展</h2>\n<h3 id=\"默认参数\"><a class=\"anchor\" href=\"#默认参数\">#</a> 默认参数</h3>\n<p>基本用法</p>\n<pre><code>function fn(name,age=17)&#123;\n console.log(name+&quot;,&quot;+age);\n&#125;\nfn(&quot;Amy&quot;,18);  // Amy,18\nfn(&quot;Amy&quot;,&quot;&quot;);  // Amy,\nfn(&quot;Amy&quot;);     // Amy,17\n</code></pre>\n<p>注意点：使用函数默认参数时，不允许有同名参数</p>\n<pre><code>// 不报错\nfunction fn(name,name)&#123;\n console.log(name);\n&#125;\n \n// 报错\n//SyntaxError: Duplicate parameter name not allowed in this context\nfunction fn(name,name,age=17)&#123;\n console.log(name+&quot;,&quot;+age);\n&#125;\n</code></pre>\n<p>只有在未传递参数，或者参数为 undefined 时，才会使用默认参数，null 值被认为是有效的值传递</p>\n<pre><code>function fn(name,age=17)&#123;\n    console.log(name+&quot;,&quot;+age);\n&#125;\nfn(&quot;Amy&quot;,null); // Amy,null\n</code></pre>\n<p>函数参数默认值存在暂时性死区，在函数参数默认值表达式中，还未初始化赋值的参数值无法作为其他参数的默认值</p>\n<pre><code>function f(x,y=x)&#123;\n    console.log(x,y);\n&#125;\nf(1);  // 1 1\n \nfunction f(x=y)&#123;\n    console.log(x);\n&#125;\nf();  // ReferenceError: y is not defined\n</code></pre>\n<h3 id=\"不定参数\"><a class=\"anchor\" href=\"#不定参数\">#</a> 不定参数</h3>\n<p>不定参数用来表示不确定参数个数，形如，... 变量名，由... 加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。</p>\n<p>基本用法</p>\n<pre><code>function f(...values)&#123;\n    console.log(values.length);\n&#125;\nf(1,2);      //2\nf(1,2,3,4);  //4\n</code></pre>\n<h2 id=\"箭头函数\"><a class=\"anchor\" href=\"#箭头函数\">#</a> 箭头函数</h2>\n<p>箭头函数提供了一种更加简洁的函数书写方式。基本语法是</p>\n<pre><code>参数 =&gt; 函数体\n</code></pre>\n<p>基本用法</p>\n<pre><code>var f = v =&gt; v;\n//等价于\nvar f = function(a)&#123;\n return a;\n&#125;\nf(1);  //1\n</code></pre>\n<p>当箭头函数没有参数或者有多个参数，要用 <strong>()</strong> 括起来</p>\n<pre><code>var f = (a,b) =&gt; a+b;\nf(6,2);  //8\n</code></pre>\n<p>当箭头函数函数体有多行语句，用 <strong>{}</strong> 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 <strong>{}</strong> , 结果会自动返回</p>\n<pre><code>var f = (a,b) =&gt; &#123;\n let result = a+b;\n return result;\n&#125;\nf(6,2);  // 8\n</code></pre>\n<p>当箭头函数要返回对象的时候，为了区分于代码块，要用 <strong>()</strong> 将对象包裹起来</p>\n<pre><code>// 报错\nvar f = (id,name) =&gt; &#123;id: id, name: name&#125;;\nf(6,2);  // SyntaxError: Unexpected token :\n \n// 不报错\nvar f = (id,name) =&gt; (&#123;id: id, name: name&#125;);\nf(6,2);  // &#123;id: 6, name: 2&#125;\n</code></pre>\n<p>注意点：没有 this、super、arguments 和 new.target 绑定</p>\n<pre><code>var func = () =&gt; &#123;\n  // 箭头函数里面没有 this 对象，\n  // 此时的 this 是外层的 this 对象，即 Window \n  console.log(this)\n&#125;\nfunc(55)  // Window \n \nvar func = () =&gt; &#123;    \n  console.log(arguments)\n&#125;\nfunc(55);  // ReferenceError: arguments is not defined\n</code></pre>\n<p>箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象</p>\n<pre><code>function fn()&#123;\n  setTimeout(()=&gt;&#123;\n    // 定义时，this 绑定的是 fn 中的 this 对象\n    console.log(this.a);\n  &#125;,0)\n&#125;\nvar a = 20;\n// fn 的 this 对象为 &#123;a: 18&#125;\nfn.call(&#123;a: 18&#125;);  // 18\n</code></pre>\n<p>不可以作为构造函数，也就是不能使用 new 命令，否则会报错</p>\n<h3 id=\"适合使用的场景\"><a class=\"anchor\" href=\"#适合使用的场景\">#</a> 适合使用的场景</h3>\n<p>ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。</p>\n<pre><code>// 回调函数\nvar Person = &#123;\n    'age': 18,\n    'sayHello': function () &#123;\n      setTimeout(function () &#123;\n        console.log(this.age);\n      &#125;);\n    &#125;\n&#125;;\nvar age = 20;\nPerson.sayHello();  // 20\n \nvar Person1 = &#123;\n    'age': 18,\n    'sayHello': function () &#123;\n      setTimeout(()=&gt;&#123;\n        console.log(this.age);\n      &#125;);\n    &#125;\n&#125;;\nvar age = 20;\nPerson1.sayHello();  // 18\n</code></pre>\n<p>所以，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。</p>\n<h3 id=\"不适合使用的场景\"><a class=\"anchor\" href=\"#不适合使用的场景\">#</a> 不适合使用的场景</h3>\n<p>定义函数的方法，且该方法中包含 this</p>\n<pre><code>var Person = &#123;\n    'age': 18,\n    'sayHello': ()=&gt;&#123;\n        console.log(this.age);\n      &#125;\n&#125;;\nvar age = 20;\nPerson.sayHello();  // 20\n// 此时 this 指向的是全局对象\n \nvar Person1 = &#123;\n    'age': 18,\n    'sayHello': function () &#123;\n        console.log(this.age);\n    &#125;\n&#125;;\nvar age = 20;\nPerson1.sayHello();   // 18\n// 此时的 this 指向 Person1 对象\n</code></pre>\n<p>需要动态 this 的时候</p>\n<pre><code>var button = document.getElementById('userClick');\nbutton.addEventListener('click', () =&gt; &#123;\n     this.classList.toggle('on');\n&#125;);\n</code></pre>\n<p>button 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象。</p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AF%B9%E8%B1%A1/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AF%B9%E8%B1%A1/",
            "title": "ES6对象",
            "date_published": "2022-06-30T13:36:00.000Z",
            "content_html": "<h2 id=\"对象字面量\"><a class=\"anchor\" href=\"#对象字面量\">#</a> 对象字面量</h2>\n<h3 id=\"属性的简洁表示法\"><a class=\"anchor\" href=\"#属性的简洁表示法\">#</a> 属性的简洁表示法</h3>\n<p>ES6 允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。</p>\n<pre><code>const age = 12;\nconst name = &quot;Amy&quot;;\nconst person = &#123;age, name&#125;;\nperson   //&#123;age: 12, name: &quot;Amy&quot;&#125;\n//等同于\nconst person = &#123;age: age, name: name&#125;\n</code></pre>\n<h3 id=\"方法名也可以简写\"><a class=\"anchor\" href=\"#方法名也可以简写\">#</a> 方法名也可以简写</h3>\n<pre><code>const person = &#123;\n  sayHi()&#123;\n    console.log(&quot;Hi&quot;);\n  &#125;\n&#125;\nperson.sayHi();  //&quot;Hi&quot;\n//等同于\nconst person = &#123;\n  sayHi:function()&#123;\n    console.log(&quot;Hi&quot;);\n  &#125;\n&#125;\nperson.sayHi();//&quot;Hi&quot;\n</code></pre>\n<p>如果是 Generator 函数，则要在前面加一个星号</p>\n<pre><code>const obj = &#123;\n  * myGenerator() &#123;\n    yield 'hello world';\n  &#125;\n&#125;;\n//等同于\nconst obj = &#123;\n  myGenerator: function* () &#123;\n    yield 'hello world';\n  &#125;\n&#125;;\n</code></pre>\n<h3 id=\"属性名表达式\"><a class=\"anchor\" href=\"#属性名表达式\">#</a> 属性名表达式</h3>\n<p>ES6 允许用表达式作为属性名，但是一定要将表达式放在方括号内</p>\n<pre><code>const obj = &#123;\n [&quot;he&quot;+&quot;llo&quot;]()&#123;\n   return &quot;Hi&quot;;\n  &#125;\n&#125;\nobj.hello();  //&quot;Hi&quot;\n</code></pre>\n<p>注意点：属性的简洁表示法和属性名表达式不能同时使用，否则会报错</p>\n<pre><code>const hello = &quot;Hello&quot;;\nconst obj = &#123;\n [hello]\n&#125;;\nobj  //SyntaxError: Unexpected token &#125;\n \nconst hello = &quot;Hello&quot;;\nconst obj = &#123;\n [hello+&quot;2&quot;]:&quot;world&quot;\n&#125;;\nobj  //&#123;Hello2: &quot;world&quot;&#125;\n</code></pre>\n<h2 id=\"对象的拓展运算符\"><a class=\"anchor\" href=\"#对象的拓展运算符\">#</a> 对象的拓展运算符</h2>\n<p>拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象。</p>\n<h3 id=\"基本用法\"><a class=\"anchor\" href=\"#基本用法\">#</a> 基本用法</h3>\n<pre><code>let person = &#123;name: &quot;Amy&quot;, age: 15&#125;;\nlet someone = &#123; ...person &#125;;\nsomeone;  //&#123;name: &quot;Amy&quot;, age: 15&#125;\n</code></pre>\n<h3 id=\"可用于合并两个对象\"><a class=\"anchor\" href=\"#可用于合并两个对象\">#</a> 可用于合并两个对象</h3>\n<pre><code>let age = &#123;age: 15&#125;;\nlet name = &#123;name: &quot;Amy&quot;&#125;;\nlet person = &#123;...age, ...name&#125;;\nperson;  //&#123;age: 15, name: &quot;Amy&quot;&#125;\n</code></pre>\n<h3 id=\"注意点\"><a class=\"anchor\" href=\"#注意点\">#</a> 注意点</h3>\n<p>自定义的属性和拓展运算符对象里面属性的相同的时候：<strong>自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。</strong></p>\n<pre><code>let person = &#123;name: &quot;Amy&quot;, age: 15&#125;;\nlet someone = &#123; ...person, name: &quot;Mike&quot;, age: 17&#125;;\nsomeone;  //&#123;name: &quot;Mike&quot;, age: 17&#125;\n</code></pre>\n<p>自定义的属性在拓展运算度前面，则变成设置新对象默认属性值。</p>\n<pre><code>let person = &#123;name: &quot;Amy&quot;, age: 15&#125;;\nlet someone = &#123;name: &quot;Mike&quot;, age: 17, ...person&#125;;\nsomeone;  //&#123;name: &quot;Amy&quot;, age: 15&#125;\n</code></pre>\n<p>拓展运算符后面是空对象，没有任何效果也不会报错。</p>\n<pre><code>let a = &#123;...&#123;&#125;, a: 1, b: 2&#125;;\na;  //&#123;a: 1, b: 2&#125;\n</code></pre>\n<p>拓展运算符后面是 null 或者 undefined，没有效果也不会报错</p>\n<pre><code>let b = &#123;...null, ...undefined, a: 1, b: 2&#125;;\nb;  //&#123;a: 1, b: 2&#125;\n</code></pre>\n<h2 id=\"对象的新方法\"><a class=\"anchor\" href=\"#对象的新方法\">#</a> 对象的新方法</h2>\n<h3 id=\"objectassigntarget-source_1\"><a class=\"anchor\" href=\"#objectassigntarget-source_1\">#</a> Object.assign(target, source_1, ···)</h3>\n<p>用于将源对象的所有可枚举属性复制到目标对象中。</p>\n<p><strong>基本用法</strong></p>\n<pre><code>let target = &#123;a: 1&#125;;\nlet object2 = &#123;b: 2&#125;;\nlet object3 = &#123;c: 3&#125;;\nObject.assign(target,object2,object3);  \n// 第一个参数是目标对象，后面的参数是源对象\ntarget;  // &#123;a: 1, b: 2, c: 3\n</code></pre>\n<ul>\n<li>\n<p>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>\n</li>\n<li>\n<p>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</p>\n<pre><code>Object.assign(3);         // Number &#123;3&#125;\ntypeof Object.assign(3);  // &quot;object&quot;\n</code></pre>\n</li>\n</ul>\n<p>因为 null 和 undefined 不能转化为对象，所以会报错</p>\n<pre><code>Object.assign(null);       // TypeError: Cannot convert undefined or null to object\nObject.assign(undefined);  // TypeError: Cannot convert undefined or null to object\n当参数不止一个时，null 和 undefined 不放第一个，即不为目标对象时，会跳过 null 和 undefined ，不报错\nObject.assign(1,undefined);  // Number &#123;1&#125;\nObject.assign(&#123;a: 1&#125;,null);  // &#123;a: 1&#125;\n \nObject.assign(undefined,&#123;a: 1&#125;);  // TypeError: Cannot convert undefined or null to object\n</code></pre>\n<p><strong>注意点</strong></p>\n<p>assign 的属性拷贝是浅拷贝:</p>\n<pre><code>let sourceObj = &#123; a: &#123; b: 1&#125;&#125;;\nlet targetObj = &#123;c: 3&#125;;\nObject.assign(targetObj, sourceObj);\ntargetObj.a.b = 2;\nsourceObj.a.b;  // 2\n</code></pre>\n<p>同名属性替换</p>\n<pre><code>targetObj = &#123; a: &#123; b: 1, c:2&#125;&#125;;\nsourceObj = &#123; a: &#123; b: &quot;hh&quot;&#125;&#125;;\nObject.assign(targetObj, sourceObj);\ntargetObj;  // &#123;a: &#123;b: &quot;hh&quot;&#125;&#125;\n</code></pre>\n<p>数组的处理</p>\n<pre><code>Object.assign([2,3], [5]);  // [5,3]\n</code></pre>\n<p>会将数组处理成对象，所以先将 [2,3] 转为 {0:2,1:3} ，然后再进行属性复制，所以源对象的 0 号属性覆盖了目标对象的 0。</p>\n<h3 id=\"objectis\"><a class=\"anchor\" href=\"#objectis\">#</a> <span class=\"exturl\" data-url=\"aHR0cDovL09iamVjdC5pcw==\">Object.is</span>(value1, value2)</h3>\n<p>用来比较两个值是否严格相等，与（===）基本类似。</p>\n<p><strong>基本用法</strong></p>\n<pre><code>Object.is(&quot;q&quot;,&quot;q&quot;);      // true\nObject.is(1,1);          // true\nObject.is([1],[1]);      // false\nObject.is(&#123;q:1&#125;,&#123;q:1&#125;);  // false\n</code></pre>\n<p>与（===）的区别</p>\n<pre><code>//一是+0不等于-0\nObject.is(+0,-0);  //false\n+0 === -0  //true\n//二是NaN等于本身\nObject.is(NaN,NaN); //true\nNaN === NaN  //false\n</code></pre>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E7%AE%80%E4%BB%8B/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/ES6/%E7%AE%80%E4%BB%8B/",
            "title": "ES6简介",
            "date_published": "2022-06-30T13:36:00.000Z",
            "content_html": "<p>ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。</p>\n<p>ES6 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。</p>\n<h2 id=\"ecmascript-的背景\"><a class=\"anchor\" href=\"#ecmascript-的背景\">#</a> ECMAScript 的背景</h2>\n<p>JavaScript 是大家所了解的语言名称，但是这个语言名称是商标（ Oracle 公司注册的商标）。因此，JavaScript 的正式名称是 ECMAScript 。1996 年 11 月，JavaScript 的创造者网景公司将 JS 提交给国际化标准组织 ECMA（European computer manufactures association，欧洲计算机制造联合会），希望这种语言能够成为国际标准，随后 ECMA 发布了规定浏览器脚本语言的标准，即 ECMAScript。这也有利于这门语言的开放和中立。</p>\n<hr>\n<h2 id=\"ecmascript-的历史\"><a class=\"anchor\" href=\"#ecmascript-的历史\">#</a> ECMAScript 的历史</h2>\n<p>ES6 是 ECMAScript 标准十余年来变动最大的一个版本，为其添加了许多新的语法特性。</p>\n<ul>\n<li>1997 年 ECMAScript 1.0 诞生。</li>\n<li>1998 年 6 月 ECMAScript 2.0 诞生，包含一些小的更改，用于同步独立的 ISO 国际标准。</li>\n<li>1999 年 12 月 ECMAScript 3.0 诞生，它是一个巨大的成功，在业界得到了广泛的支持，它奠定了 JS 的基本语法，被其后版本完全继承。直到今天，我们一开始学习 JS ，其实就是在学 3.0 版的语法。</li>\n<li>2000 年的 ECMAScript 4.0 是当下 ES6 的前身，但由于这个版本太过激烈，对 ES 3 做了彻底升级，所以暂时被 &quot;和谐&quot; 了。</li>\n<li>2009 年 12 月，ECMAScript 5.0 版正式发布。ECMA 专家组预计 ECMAScript 的第五个版本会在 2013 年中期到 2018 年作为主流的开发标准。2011 年 6 月，ES 5.1 版发布，并且成为 ISO 国际标准。</li>\n<li>2013 年，ES6 草案冻结，不再添加新的功能，新的功能将被放到 ES7 中；2015 年 6 月， ES6 正式通过，成为国际标准。</li>\n</ul>\n<hr>\n<h2 id=\"es6-的目标与愿景\"><a class=\"anchor\" href=\"#es6-的目标与愿景\">#</a> ES6 的目标与愿景</h2>\n<p>成为更好编写的开发语言有以下目标。</p>\n<p>适应更复杂的应用；实现代码库之间的共享；不断迭代维护新版本。</p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "ES6"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/AJAX/XHR%E5%AF%B9%E8%B1%A1/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/AJAX/XHR%E5%AF%B9%E8%B1%A1/",
            "title": "XHR对象",
            "date_published": "2022-06-30T13:35:00.000Z",
            "content_html": "<h1 id=\"ajax-创建-xmlhttprequest-对象\"><a class=\"anchor\" href=\"#ajax-创建-xmlhttprequest-对象\">#</a> AJAX - 创建 XMLHttpRequest 对象</h1>\n<hr>\n<p>XMLHttpRequest 是 AJAX 的基础。</p>\n<hr>\n<h2 id=\"xmlhttprequest-对象\"><a class=\"anchor\" href=\"#xmlhttprequest-对象\">#</a> XMLHttpRequest 对象</h2>\n<p>所有现代浏览器均支持 XMLHttpRequest 对象（IE5 和 IE6 使用 ActiveXObject）。</p>\n<p>XMLHttpRequest 用于在后台与服务器交换数据。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>\n<hr>\n<h2 id=\"创建-xmlhttprequest-对象\"><a class=\"anchor\" href=\"#创建-xmlhttprequest-对象\">#</a> 创建 XMLHttpRequest 对象</h2>\n<p>所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。</p>\n<p>创建 XMLHttpRequest 对象的语法：</p>\n<pre><code>variable=new XMLHttpRequest();\n</code></pre>\n<p>老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：</p>\n<pre><code>variable=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);\n</code></pre>\n<p>为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ：</p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "AJAX"
            ]
        },
        {
            "id": "https://entropywhite.com/computer-science/web/JavaScript/AJAX/AJAX%E5%BC%82%E6%AD%A5/",
            "url": "https://entropywhite.com/computer-science/web/JavaScript/AJAX/AJAX%E5%BC%82%E6%AD%A5/",
            "title": "AJAX异步",
            "date_published": "2022-06-30T13:34:00.000Z",
            "content_html": "<p>全称：<strong>Asynchronous JavaScript And XML（异步 JavaScript 及 XML）</strong></p>\n<p>Ajax 的作用：实现异步请求的技术</p>\n<p><strong>什么是同步请求？</strong></p>\n<p>场景：页面上有一个 a 标签，用户点击 a 标签，浏览器发出一个请求，然后服务器给出一个响应。</p>\n<p>(请求，其实是用户的操作，触发的)</p>\n<p><strong>什么是异步（不同步）请求？</strong></p>\n<p>场景：在用户注册的时候，用户首先输入用户名，接下来用户继续填写其他注册信息，与此同时，浏览器自动发送了一个请求，将用户输入的用户名发送给服务器，去校验是否可用.</p>\n<p>(请求，是浏览器自己发送的，与用户没有关系)</p>\n<p><strong>同步与异步区别的理解：</strong></p>\n<p>1. 同步请求：之前我们写的注册案例，依次写用户名，密码，等等所有信息之后，手动按提交按钮，才会把浏览器上的数据传到服务器进行校验用户名是否重复，然后在浏览器上提示用户名是否重复的信息，这种方式一速度较慢，需要将全部信息写完之后刷新整个页面提交到服务器，如果没有通过验证还得重新填写信息再提交，比较浪费流量，二则是如果没有通过验证所有的信息都没有了还得重新填写，太麻烦</p>\n<p>2. 异步请求：使用 ajax 的话，将用户名文本框绑定一个鼠标离焦事件，事件里用 ajax 提交用户名到服务器校验，这个验证是我们鼠标离开用户名文本框浏览器自动向服务器发出请求校验的，我们在填写别的信息时，服务器会将校验信息发送给浏览器提示是否重复信息，这样既省流量，又可以只修改用户名即可，最后验证通过才可以提交全部信息；</p>\n<p><strong>为什么需要异步请求，或者说那些功能必须使用异步请求技术来实现？</strong></p>\n<p>在不刷新页面（使用 a 标签发送请求和使用 form 表单发送请求，这两种请求都会，刷新页面）的情况下，发送请求，接收响应，然后修改部分的页面，这样的需求需要异步请求实现</p>\n<p>总结：在不使用 a 标签和 form 表单发送请求的情况下，使用异步请求</p>\n<p><strong>在这个需求中，发送请求应该谁来做？</strong></p>\n<p>浏览器</p>\n<p><strong>让浏览器来帮助发送这个请求，那么程序员如何与浏览器沟通，让它帮助我们发送请求？</strong></p>\n<p>Javascript 技术</p>\n<p>企业为什么特别喜欢使用 ajax?</p>\n<p>钱。企业的网络通信费用，按流量计费，那么使用 ajax 它的数据量小，所以省钱</p>\n<p>ajax 它的数据量小 —— 因为他不重新加载整个页面（加载部分）</p>\n<p>Ajax 因为数据量小，响应速度快，用户体验好</p>\n",
            "tags": [
                "计算机科学",
                "web",
                "JavaScript",
                "AJAX"
            ]
        }
    ]
}