<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://entropywhite.com</id>
    <title>熵白之痕</title>
    <subtitle>以前进为目标吧</subtitle>
    <icon>https://entropywhite.com/images/favicon.ico</icon>
    <link href="https://entropywhite.com" />
    <author>
      <name>EntropyWhite</name>
    </author>
    <updated>2022-06-26T14:42:18.461Z</updated>
    <category term="web" />
    <category term="前端" />
    <category term="markdown" />
    <category term="hexo" />
    <entry>
        <id>https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%BD%95%E7%99%BE%E5%BA%A6%E7%AB%99%E7%82%B9/</id>
        <title>博客文件解析</title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E6%94%B6%E5%BD%95%E7%99%BE%E5%BA%A6%E7%AB%99%E7%82%B9/"/>
        <content type="html">&lt;h1 id=&#34;博客收录百度站点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#博客收录百度站点&#34;&gt;#&lt;/a&gt; 博客收录百度站点&lt;/h1&gt;
&lt;p&gt;首先点击这个链接&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tLw==&#34;&gt;百度搜索资源平台_共创共享鲜活搜索 (baidu.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;进入后注册或登录（有号的话）百度账号&lt;/p&gt;
&lt;p&gt;登录成功后鼠标移到&lt;strong&gt;用户中心&lt;/strong&gt;，点击出现的&lt;strong&gt;站点管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/40.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;进入页面后，点击&lt;strong&gt;添加网站&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一、输入网站，选择 http 或 https（看你博客有没有套 SSL 证书），输入博客域名地址，点击下一步&lt;/p&gt;
&lt;p&gt;二、设置站点领域为&lt;strong&gt;信息技术&lt;/strong&gt;（也可以按自己所需选择），点击下一步&lt;/p&gt;
&lt;p&gt;三、验证网站（重点），有三种验证方式&lt;/p&gt;
&lt;p&gt;1. 文件验证（没成功）&lt;/p&gt;
&lt;p&gt;下方会提示下载一个验证文件，下载完后放到博客的根目录下，所谓的根目录其实是你博客的根目录下的 Source 文件夹里，放进去后重新使用 git bash 输入 hexo g -d 部署到网上，完成后点击最下方的完成验证&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/41.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;这个我试过是没成功的，我看网上的是这样做的&lt;/p&gt;
&lt;p&gt;2.HTML 标签验证（没成功）&lt;/p&gt;
&lt;p&gt;下方会提示将一段代码放到网站的首页的 head 标签里头，据我所找的网上说是放在 themes/shoka/layout/_partials 文件夹内的某个文件里头&lt;/p&gt;
&lt;p&gt;至于是哪个我就不清楚了，因为我找到不是和我们一个主题的，如果有成功的小伙伴请放上截图评论&lt;/p&gt;
&lt;p&gt;3.CNAME 验证（成功）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/42.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;首先，登录你购买域名的服务商，进入 dns 解析页面&lt;/p&gt;
&lt;p&gt;点进你的域名，点击添加记录，主机记录输入它给你的一串记录（如上方的 code-……，点后面的是你需要绑定的域名，不要放进主机记录），记录类型选择 CNAME，记录值就输入它让你解析的地址，完成后点确认&lt;/p&gt;
&lt;p&gt;回到百度验证页面，点完成验证即可成功验证&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/39.png&#34; alt&gt;&lt;/p&gt;
</content>
        <category term="计算机科学" scheme="https://entropywhite.com/categories/computer-science/" />
        <category term="hexo博客" scheme="https://entropywhite.com/categories/computer-science/blog/" />
        <category term="Theme Shoka Documentation" scheme="https://entropywhite.com/categories/computer-science/blog/Theme-Shoka-Documentation/" />
        <category term="Hexo" scheme="https://entropywhite.com/tags/Hexo/" />
        <category term="教程" scheme="https://entropywhite.com/tags/%E6%95%99%E7%A8%8B/" />
        <updated>2022-06-26T14:42:18.461Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/html/Canvas%E5%92%8CSVG/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/html/Canvas%E5%92%8CSVG/"/>
        <content type="html">&lt;h1 id=&#34;html5-canvas&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#html5-canvas&#34;&gt;#&lt;/a&gt; HTML5 Canvas&lt;/h1&gt;
&lt;hr&gt;
&lt;p&gt;canvas 标签定义图形，比如图表和其他图像，必须使用脚本来绘制图形&lt;/p&gt;
&lt;h2 id=&#34;创建一个画布canvas&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建一个画布canvas&#34;&gt;#&lt;/a&gt; 创建一个画布（Canvas）&lt;/h2&gt;
&lt;p&gt;一个画布在网页中是一个矩形框，通过 &amp;lt;canvas&amp;gt; 元素来绘制&lt;/p&gt;
&lt;p&gt;默认情况下 &amp;lt;canvas&amp;gt; 元素没有边框和内容。&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas&amp;gt; 简单实例如下:&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;canvas id=&#34;myCanvas&#34; width=&#34;200&#34; height=&#34;100&#34;&gt;&amp;lt;/canvas&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;标签通常需要指定一个 id 属性 (脚本中经常引用), width 和 height 属性定义的画布的大小&lt;/p&gt;
&lt;h2 id=&#34;使用-javascript-来绘制图像&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用-javascript-来绘制图像&#34;&gt;#&lt;/a&gt; 使用 JavaScript 来绘制图像&lt;/h2&gt;
&lt;p&gt;canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;canvas id=&#34;myCanvas&#34; width=&#34;200&#34; height=&#34;100&#34; style=&#34;border:1px solid #c3c3c3;&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;您的浏览器不支持 HTML5 canvas 标签&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;/canvas&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;script&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var c=document.getElementById(&#34;myCanvas&#34;); //找到元素&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var ctx=c.getContext(&#34;2d&#34;); //创建对象 getContext(&#34;2d&#34;) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.fillStyle=&#34;#FF0000&#34;; //绘制边框&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.fillRect(0,0,150,75); //fillRect(x,y,width,height) 方法定义了矩形当前的填充方式&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;/script&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;canvas-坐标&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#canvas-坐标&#34;&gt;#&lt;/a&gt; Canvas 坐标&lt;/h2&gt;
&lt;p&gt;canvas 是一个二维网格&lt;/p&gt;
&lt;p&gt;canvas 的左上角坐标为 (0,0)&lt;/p&gt;
&lt;p&gt;上面的 fillRect 方法拥有参数 (0,0,150,75)&lt;/p&gt;
&lt;p&gt;意思是：在画布上绘制 150x75 的矩形，从左上角开始 (0,0)&lt;/p&gt;
&lt;h2 id=&#34;canvas-路径&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#canvas-路径&#34;&gt;#&lt;/a&gt; Canvas - 路径&lt;/h2&gt;
&lt;p&gt;在 Canvas 上画线，我们将使用以下两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;moveTo(&lt;em&gt;x,y&lt;/em&gt;) 定义线条开始坐标&lt;/li&gt;
&lt;li&gt;lineTo(&lt;em&gt;x,y&lt;/em&gt;) 定义线条结束坐标&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;绘制线条我们必须使用到 &amp;quot;ink&amp;quot; 的方法，就像 stroke ()&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;canvas id=&#34;myCanvas&#34; width=&#34;200&#34; height=&#34;100&#34; style=&#34;border:1px solid #d3d3d3;&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;您的浏览器不支持 HTML5 canvas 标签&amp;lt;/canvas&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;script&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var c=document.getElementById(&#34;myCanvas&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var ctx=c.getContext(&#34;2d&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.moveTo(0,0);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.lineTo(200,100);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.stroke();&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;/script&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在 canvas 中绘制圆形，我们将使用以下方法:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;arc(x,y,r,start,stop)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上我们在绘制圆形时使用了 &amp;quot;ink&amp;quot; 的方法，比如 stroke () 或者 fill ()&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var c=document.getElementById(&#34;myCanvas&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var ctx=c.getContext(&#34;2d&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.beginPath();&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.arc(95,50,40,0,2*Math.PI);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.stroke();&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;canvas-文本&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#canvas-文本&#34;&gt;#&lt;/a&gt; Canvas - 文本&lt;/h2&gt;
&lt;p&gt;使用 canvas 绘制文本，重要的属性和方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;font - 定义字体&lt;/li&gt;
&lt;li&gt;fillText(&lt;em&gt;text,x,y&lt;/em&gt;) - 在 canvas 上绘制实心的文本&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var c=document.getElementById(&#34;myCanvas&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var ctx=c.getContext(&#34;2d&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.font=&#34;30px Arial&#34;;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.fillText(&#34;Hello World&#34;,10,50);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;strokeText(&lt;em&gt;text,x,y&lt;/em&gt;) - 在 canvas 上绘制空心的文本&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var c=document.getElementById(&#34;myCanvas&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var ctx=c.getContext(&#34;2d&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.font=&#34;30px Arial&#34;;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.strokeText(&#34;Hello World&#34;,10,50);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;canvas-渐变&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#canvas-渐变&#34;&gt;#&lt;/a&gt; Canvas - 渐变&lt;/h2&gt;
&lt;p&gt;渐变可以填充在矩形，圆形，线条，文本等等，各种形状可以自己定义不同的颜色&lt;/p&gt;
&lt;p&gt;以下有两种不同的方式来设置 Canvas 渐变：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;createLinearGradient(&lt;em&gt;x,y,x1,y1&lt;/em&gt;) - 创建线条渐变&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var c=document.getElementById(&#34;myCanvas&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var ctx=c.getContext(&#34;2d&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;// 创建渐变&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var grd=ctx.createLinearGradient(0,0,200,0);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;grd.addColorStop(0,&#34;red&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;grd.addColorStop(1,&#34;white&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;// 填充渐变&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.fillStyle=grd;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.fillRect(10,10,150,80);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;
&lt;li&gt;createRadialGradient(&lt;em&gt;x,y,r,x1,y1,r1&lt;/em&gt;) - 创建一个径向 / 圆渐变&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var c=document.getElementById(&#34;myCanvas&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var ctx=c.getContext(&#34;2d&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;// 创建渐变&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var grd=ctx.createRadialGradient(75,50,5,90,60,100);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;grd.addColorStop(0,&#34;red&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;grd.addColorStop(1,&#34;white&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt; &lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;// 填充渐变&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.fillStyle=grd;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.fillRect(10,10,150,80);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当我们使用渐变对象，必须使用两种或两种以上的停止颜色&lt;/p&gt;
&lt;p&gt;addColorStop () 方法指定颜色停止，参数使用坐标来描述，可以是 0 至 1&lt;/p&gt;
&lt;p&gt;使用渐变，设置 fillStyle 或 strokeStyle 的值为 渐变，然后绘制形状，如矩形，文本，或一条线&lt;/p&gt;
&lt;h2 id=&#34;canvas-图像&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#canvas-图像&#34;&gt;#&lt;/a&gt; Canvas - 图像&lt;/h2&gt;
&lt;p&gt;把一幅图像放置到画布上，使用以下方法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drawImage(&lt;em&gt;image,x,y&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var c=document.getElementById(&#34;myCanvas&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var ctx=c.getContext(&#34;2d&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;var img=document.getElementById(&#34;scream&#34;);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ctx.drawImage(img,10,10);&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&#34;什么是svg&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#什么是svg&#34;&gt;#&lt;/a&gt; 什么是 SVG？&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;SVG 指可伸缩矢量图形 (Scalable Vector Graphics)&lt;/li&gt;
&lt;li&gt;SVG 用于定义用于网络的基于矢量的图形&lt;/li&gt;
&lt;li&gt;SVG 使用 XML 格式定义图形&lt;/li&gt;
&lt;li&gt;SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失&lt;/li&gt;
&lt;li&gt;SVG 是万维网联盟的标准&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;html5-svg&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#html5-svg&#34;&gt;#&lt;/a&gt; HTML5 SVG&lt;/h2&gt;
&lt;p&gt;HTML5 支持内联 SVG&lt;/p&gt;
&lt;p&gt;HTML &lt;strong&gt;&amp;lt;svg&amp;gt;&lt;/strong&gt; 元素是 SVG 图形的容器&lt;/p&gt;
&lt;p&gt;SVG 有多种绘制路径、框、圆、文本和图形图像的方法&lt;/p&gt;
&lt;h2 id=&#34;svg优势&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#svg优势&#34;&gt;#&lt;/a&gt; SVG 优势&lt;/h2&gt;
&lt;p&gt;与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SVG 图像可通过文本编辑器来创建和修改&lt;/li&gt;
&lt;li&gt;SVG 图像可被搜索、索引、脚本化或压缩&lt;/li&gt;
&lt;li&gt;SVG 是可伸缩的&lt;/li&gt;
&lt;li&gt;SVG 图像可在任何的分辨率下被高质量地打印&lt;/li&gt;
&lt;li&gt;SVG 可在图像质量不下降的情况下被放大&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;svg圆形&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#svg圆形&#34;&gt;#&lt;/a&gt; SVG 圆形&lt;/h2&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; version=&#34;1.1&#34;&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   &amp;lt;circle cx=&#34;100&#34; cy=&#34;50&#34; r=&#34;40&#34; stroke=&#34;black&#34; stroke-width=&#34;2&#34; fill=&#34;red&#34; /&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&amp;lt;/svg&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;svg-与-canvas两者间的区别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#svg-与-canvas两者间的区别&#34;&gt;#&lt;/a&gt; SVG 与 Canvas 两者间的区别&lt;/h2&gt;
&lt;p&gt;SVG 是一种使用 XML 描述 2D 图形的语言&lt;/p&gt;
&lt;p&gt;Canvas 通过 JavaScript 来绘制 2D 图形&lt;/p&gt;
&lt;p&gt;SVG 基于 XML，这意味着 SVG DOM 中的每个元素都是可用的。您可以为某个元素附加 JavaScript 事件处理器&lt;/p&gt;
&lt;p&gt;在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形&lt;/p&gt;
&lt;p&gt;Canvas 是逐像素进行渲染的。在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象&lt;/p&gt;
&lt;h2 id=&#34;canvas-与-svg-的比较&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#canvas-与-svg-的比较&#34;&gt;#&lt;/a&gt; Canvas 与 SVG 的比较&lt;/h2&gt;
&lt;p&gt;下表列出了 canvas 与 SVG 之间的一些不同之处&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Canvas&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;SVG&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;依赖分辨率不支持事件处理器弱的文本渲染能力能够以 .png 或 .jpg 格式保存结果图像最适合图像密集型的游戏，其中的许多对象会被频繁重绘&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不依赖分辨率支持事件处理器最适合带有大型渲染区域的应用程序（比如谷歌地图）复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）不适合游戏应用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content>
        <updated>2022-06-21T11:58:16.552Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/blog/%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81/</id>
        <title>一些关于本博客问题</title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/blog/%E5%89%8D%E6%83%85%E6%8F%90%E8%A6%81/"/>
        <content type="html">&lt;h1 id=&#34;关于本博客&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关于本博客&#34;&gt;#&lt;/a&gt; 关于本博客&lt;/h1&gt;
&lt;p&gt;博客将更新一些不限于前端的知识，比如其他编程知识、游戏分享等&lt;/p&gt;
&lt;p&gt;基于 shoka 的主题进行自定义&lt;/p&gt;
&lt;h1 id=&#34;访问博客食用方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#访问博客食用方法&#34;&gt;#&lt;/a&gt; 访问博客食用方法&lt;/h1&gt;
&lt;h2 id=&#34;如果你发现刚刚还存在的博客突然变成github404无非几种情况&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#如果你发现刚刚还存在的博客突然变成github404无非几种情况&#34;&gt;#&lt;/a&gt; 如果你发现刚刚还存在的博客，突然变成 github404，无非几种情况&lt;/h2&gt;
&lt;p&gt;一是 github 服务器炸了（不太可能）&lt;/p&gt;
&lt;p&gt;二是我在更新博客（会存在一段时间 404，请至少过 5 分钟在访问）&lt;/p&gt;
&lt;h2 id=&#34;博客加载缓慢&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#博客加载缓慢&#34;&gt;#&lt;/a&gt; 博客加载缓慢&lt;/h2&gt;
&lt;p&gt;在进入博客前有个加载页面，如果你在加载页面停留过久（1 分钟以上），可以尝试翻墙再访问看看如何（因为使用了 github 作服务器，有外网的因素）&lt;/p&gt;
</content>
        <category term="计算机科学" scheme="https://entropywhite.com/categories/computer-science/" />
        <category term="hexo博客" scheme="https://entropywhite.com/categories/computer-science/blog/" />
        <category term="Theme Shoka Documentation" scheme="https://entropywhite.com/categories/computer-science/blog/Theme-Shoka-Documentation/" />
        <category term="Hexo" scheme="https://entropywhite.com/tags/Hexo/" />
        <updated>2022-06-10T01:17:00.000Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98/</id>
        <title>博客问题</title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98/"/>
        <content type="html">&lt;h2 id=&#34;bug1未解决&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bug1未解决&#34;&gt;#&lt;/a&gt; bug1 (未解决)&lt;/h2&gt;
&lt;p&gt;在运行 hexo s 查看博客时出现报错&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/20.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;只要在 hexo 中使用到 hexo-renderer-stylus，就会出现上面的警告，不去管他也能正常使用，但是看起来不舒服。&lt;/p&gt;
&lt;p&gt;提供两种修复办法&lt;/p&gt;
&lt;p&gt;一：将 node 从 14 降级到 12，警告消失，但是这样容易引起其他依赖问题&lt;/p&gt;
&lt;p&gt;二：Hexo 这里的 warning 是由于&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy9naXRodWIuY29tL3N0eWx1cy9zdHlsdXM=&#34;&gt; stylus&lt;/span&gt; 导致的，幸运的是 stylus 在 0.54.8 版本修复了这个问题，所以对于 Hexo 用户来说，重新装一下 &lt;code&gt;hexo-renderer-stylus&lt;/code&gt; ，就可正常使用。&lt;/p&gt;
&lt;p&gt;但重装之后发现还是会报警告，继续追溯源头，发现是这其实是&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzJTNBLy93d3cubnBtanMuY29tL3BhY2thZ2Uvbmli&#34;&gt; ni&lt;/span&gt;b 这个包里的 stylus 引起的问题，而这个包已经很久没更新了。&lt;/p&gt;
&lt;p&gt;2.1 将 hexo-renderer-stylus 更新到 2.0.1&lt;/p&gt;
&lt;p&gt;2.2 &lt;strong&gt;将 stylus 从 0.54.5 更新到 0.54.8&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&#34;resolutions&#34;: &amp;#123;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    &#34;stylus&#34;: &#34;^0.54.8&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  &amp;#125;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果还是有警告，可以 cd node_module/nib，强行把它的 stylus 升级到 0.54.8（不推荐这么做）&lt;/p&gt;
&lt;h2 id=&#34;bug2已解决&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bug2已解决&#34;&gt;#&lt;/a&gt; bug2 (已解决)&lt;/h2&gt;
&lt;p&gt;在运行 hexo s 查看博客时出现如下报错&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ERROR &amp;#123;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  err: Error: Cannot find module &#39;pangu&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;下载 pangu 插件即可&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm install remark-pangu&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&#34;bug3已解决&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bug3已解决&#34;&gt;#&lt;/a&gt; bug3 (已解决)&lt;/h2&gt;
&lt;p&gt;在安装插件时发生报错&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/21.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;将 npm 版本升级至最高即可&lt;/p&gt;
&lt;h2 id=&#34;bug4已解决&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bug4已解决&#34;&gt;#&lt;/a&gt; bug4 (已解决)&lt;/h2&gt;
&lt;p&gt;访问自己博客主页 (&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS01bXE0MGs1dWsuZ2l0aHViLmlv&#34;&gt;http:// 仓库名.github.io&lt;/span&gt;) 时出现 404 画面&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/22.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;在仓库页面，点击 Settings，一路拉到最下，看见 Change visibility，点击后出现以下页面&lt;/p&gt;
&lt;p&gt;原因是你的仓库没有公开，创建仓库时设置了私有&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/23.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;Make public: 公开仓库、Make private: 私有仓库&lt;/p&gt;
&lt;p&gt;我们的博客仓库必须公开，不公开就会出现 404 页面。点击 Make public，输入黑体加粗 (Jerysurp/Jerysurp.github.io)，点红色字体即可，稍作等待后就会出现博客页面&lt;/p&gt;
&lt;h2 id=&#34;bug5已解决&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#bug5已解决&#34;&gt;#&lt;/a&gt; bug5 (已解决)&lt;/h2&gt;
&lt;p&gt;上传到 github 时报错&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/38.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;删除博客根目录下的 **.deploy_git** 文件&lt;/p&gt;
&lt;p&gt;使用 git bash 输入&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;git config --global core.autocrlf false&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;将 git 加入到系统环境变量&lt;/p&gt;
&lt;p&gt;重新进行 hexo c d g&lt;/p&gt;
</content>
        <category term="计算机科学" scheme="https://entropywhite.com/categories/computer-science/" />
        <category term="hexo博客" scheme="https://entropywhite.com/categories/computer-science/blog/" />
        <category term="Theme Shoka Documentation" scheme="https://entropywhite.com/categories/computer-science/blog/Theme-Shoka-Documentation/" />
        <category term="Hexo" scheme="https://entropywhite.com/tags/Hexo/" />
        <category term="教程" scheme="https://entropywhite.com/tags/%E6%95%99%E7%A8%8B/" />
        <updated>2022-06-10T00:48:00.000Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</id>
        <title>博客文件解析</title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
        <content type="html">&lt;p&gt;hexo 博客&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/24.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;node_modules：下载的插件 (依赖) 都在这&lt;/p&gt;
&lt;p&gt;public：静态页面&lt;/p&gt;
&lt;p&gt;source：写好的文章放里面&lt;/p&gt;
&lt;p&gt;themes：存放主题&lt;/p&gt;
&lt;p&gt;_config.yml：全局配置文件&lt;/p&gt;
&lt;p&gt;package.json：依赖包描述文件&lt;/p&gt;
&lt;p&gt;主题文件&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/30.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;example：给你参考的模板&lt;/p&gt;
&lt;p&gt;languages：语言文件&lt;/p&gt;
&lt;p&gt;source：静态文件&lt;/p&gt;
&lt;p&gt;_config.yml：主题配置文件&lt;/p&gt;
&lt;p&gt;_images.yml：图像配置文件&lt;/p&gt;
&lt;p&gt;package.json：依赖包描述文件&lt;/p&gt;
</content>
        <category term="计算机科学" scheme="https://entropywhite.com/categories/computer-science/" />
        <category term="hexo博客" scheme="https://entropywhite.com/categories/computer-science/blog/" />
        <category term="Theme Shoka Documentation" scheme="https://entropywhite.com/categories/computer-science/blog/Theme-Shoka-Documentation/" />
        <category term="Hexo" scheme="https://entropywhite.com/tags/Hexo/" />
        <category term="教程" scheme="https://entropywhite.com/tags/%E6%95%99%E7%A8%8B/" />
        <updated>2022-06-10T00:47:00.000Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/</id>
        <title>博客主题</title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/"/>
        <content type="html">&lt;h1 id=&#34;第二章美化博客&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#第二章美化博客&#34;&gt;#&lt;/a&gt; 第二章：美化博客&lt;/h1&gt;
&lt;h2 id=&#34;下载主题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#下载主题&#34;&gt;#&lt;/a&gt; 下载主题&lt;/h2&gt;
&lt;p&gt;在下载主题前，需要前往&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9oZXhvLmlvL3RoZW1lcy8=&#34;&gt; Themes | Hexo&lt;/span&gt;hexo 官网主题页面寻找自己喜欢的主题，这里以 shoka 举例，其他主题请自行查看其他攻略食用&lt;/p&gt;
&lt;p&gt;前往 github 下载 shoka 主题&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;https://github.com/amehime/hexo-theme-shoka&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;或者用 git bash 下载 (这个我没成功)&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;下载好的主题放到博客根目录下的 themes 里&lt;/p&gt;
&lt;h2 id=&#34;2下载依赖&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2下载依赖&#34;&gt;#&lt;/a&gt; 2. 下载依赖&lt;/h2&gt;
&lt;p&gt;使用主题前先要安装一些主题依赖的插件，没有安装以下插件的话，主题会报错&lt;/p&gt;
&lt;p&gt;在博客根目录下打开 git bash，输入下列命令&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm un hexo-renderer-marked --save &#34;删除默认的渲染器&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm i hexo-renderer-multi-markdown-it --save &#34;md文件渲染器，压缩css/js/html&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm i hexo-autoprefixer --save &#34;给生成的css文件添加浏览器前缀&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm i hexo-algoliasearch --save &#34;站内搜索功能&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm i hexo-symbols-count-time --save &#34;文章或站点子数及阅读时间统计&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm i hexo-feed --save &#34;生成feed文件&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&#34;配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置&#34;&gt;#&lt;/a&gt; 配置&lt;/h3&gt;
&lt;p&gt;打开全局配置文件，在 deploy 下面加入配置&lt;/p&gt;
&lt;p&gt;autoprefixer 配置&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;autoprefixer:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;	exclude:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;		- &#39;*.min.css&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;markdown 配置&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;markdown:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  render: # 渲染器设置&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    html: false # 过滤 HTML 标签&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    xhtmlOut: true # 使用 &#39;/&#39; 来闭合单标签 （比如 &amp;lt;br /&gt;）。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    breaks: true # 转换段落里的 &#39;\n&#39; 到 &amp;lt;br&gt;。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    linkify: true # 将类似 URL 的文本自动转换为链接。&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    typographer:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    quotes: &#39;“”‘’&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  plugins: # markdown-it插件设置&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    - plugin:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        name: markdown-it-toc-and-anchor&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        options: # 文章目录以及锚点应用的class名称，shoka主题必须设置成这样&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;          tocClassName: &#39;toc&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;          anchorClassName: &#39;anchor&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    - plugin:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        name: markdown-it-multimd-table&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        options:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;20&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;          multiline: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;21&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;          rowspan: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;22&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;          headerless: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;23&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    - plugin:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;24&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        name: ./markdown-it-furigana&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;25&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;26&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        options:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;27&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;          fallbackParens: &#34;()&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;28&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    - plugin:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;29&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        name: ./markdown-it-spoiler&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;30&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;31&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        options:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;32&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;          title: &#34;你知道得太多了&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;加入 minify 配置，压缩 html/css/js&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;minify:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  html:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    exclude: #排除hexo-feed用到的模板&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      - &#39;**/json.ejs&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      - &#39;**/atom.ejs&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      - &#39;**/rss.ejs&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  css:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    exclude:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      - &#39;**/*.min.css&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;  js:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    mangle:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      toplevel: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    output:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    compress:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;18&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    exclude:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;19&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;      - &#39;**/*.min.js&#39;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;停用默认代码高亮功能，否则代码块的 mac 样式不能显示&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;highlight:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   enable: false&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;prismjs:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   enable: false&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;algolia 配置&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;algolia:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   appId: #your appid&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   apiKey: #your apikey&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   adminApiKey: #your adminapikey&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   chunkSize: 5000&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   indexName:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;   fields:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     - title #必须配置&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     - path #必须配置&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     - categories #推荐配置&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     - content:strip:truncate,0,4000&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     - gallery&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     - photos&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;     - tags&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;feed 配置&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;feed:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    limit: 20&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    order_by: &#34;-date&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    tag_dir: false&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    category_dir: false&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;6&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    rss:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;7&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;8&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        template: &#34;themes/shoka/layout/_alternate/rss.ejs&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;9&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        output: &#34;rss.xml&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;10&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    atom:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;11&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;12&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        template: &#34;themes/shoka/layout/_alternate/atom.ejs&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;13&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        output: &#34;atom.xml&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;14&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;    jsonFeed:&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;15&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        enable: true&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;16&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        template: &#34;themes/shoka/layout/_alternate/json.ejs&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;17&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;        output: &#34;feed.json&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
        <category term="计算机科学" scheme="https://entropywhite.com/categories/computer-science/" />
        <category term="hexo博客" scheme="https://entropywhite.com/categories/computer-science/blog/" />
        <category term="Theme Shoka Documentation" scheme="https://entropywhite.com/categories/computer-science/blog/Theme-Shoka-Documentation/" />
        <category term="Hexo" scheme="https://entropywhite.com/tags/Hexo/" />
        <category term="教程" scheme="https://entropywhite.com/tags/%E6%95%99%E7%A8%8B/" />
        <updated>2022-06-10T00:46:00.000Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/</id>
        <title>安装hexo和部署到github</title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%88%9B%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
        <content type="html">&lt;h1 id=&#34;安装hexo和部署到github&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#安装hexo和部署到github&#34;&gt;#&lt;/a&gt; 安装 hexo 和部署到 github&lt;/h1&gt;
&lt;h2 id=&#34;下载nodejs&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#下载nodejs&#34;&gt;#&lt;/a&gt; 下载 NodeJs&lt;/h2&gt;
&lt;p&gt;下载 NodeJs 地址: &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ub2RlanMub3JnL2VuL2Rvd25sb2FkLw==&#34;&gt;Download | Node.js (nodejs.org)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/1.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;默认点击 windows installer 即可&lt;/p&gt;
&lt;p&gt;安装时一路 next 即可，不用安装其他，但安装地址如需要可以更改 (一般不放 C 盘)&lt;/p&gt;
&lt;h2 id=&#34;下载git&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#下载git&#34;&gt;#&lt;/a&gt; 下载 git&lt;/h2&gt;
&lt;p&gt;下载 git 地址： &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9ucG0udGFvYmFvLm9yZy9taXJyb3JzL2dpdC1mb3Itd2luZG93cy92Mi4yMi4wLndpbmRvd3MuMS9HaXQtMi4yMi4wLTY0LWJpdC5leGU=&#34;&gt;https://npm.taobao.org/mirrors/git-for-windows/v2.22.0.windows.1/Git-2.22.0-64-bit.exe&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下载后会有一个 git bash 命令行工具&lt;/p&gt;
&lt;h3 id=&#34;检查nodejs-npm和git版本及安装&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#检查nodejs-npm和git版本及安装&#34;&gt;#&lt;/a&gt; 检查 NodeJs、npm 和 git 版本及安装&lt;/h3&gt;
&lt;p&gt;打开 cmd 执行以下命令&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;node -v&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;3&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm -v&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;4&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;5&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;git --version&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;img data-src=&#34;../../../../img/2.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;出现版本号即为安装成功&lt;/p&gt;
&lt;h2 id=&#34;nodejs环境变量配置&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#nodejs环境变量配置&#34;&gt;#&lt;/a&gt; NodeJs 环境变量配置&lt;/h2&gt;
&lt;h3 id=&#34;修改模块安装和缓存路径&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#修改模块安装和缓存路径&#34;&gt;#&lt;/a&gt; 修改模块安装和缓存路径&lt;/h3&gt;
&lt;p&gt;在你安装 nodejs 的目录下新建一个名字为 node_cache 的文件夹&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/3.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;打开 cmd，使用命令修改模块安装路径，“” 里为自己的 nodejs 的路径&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm config set prefix &#34;&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;使用命令修改缓存路径，“” 里为自己的 node_cache 文件夹的路径&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm config set cache &#34;&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;最后使用命令检查是否配置成功&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm config get prefix&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm config get cache&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;img data-src=&#34;../../../../img/4.JPG&#34; alt&gt;&lt;/p&gt;
&lt;h3 id=&#34;配置环境变量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#配置环境变量&#34;&gt;#&lt;/a&gt; 配置环境变量&lt;/h3&gt;
&lt;p&gt;点击 &amp;quot;我的电脑&amp;quot; 右键 — 属性 — 高级系统设置 — 环境变量 — 用户变量 — 编辑 — 将 nodejs 默认配置路径删除 (有就删，没有可以不管)&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/5.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;点下方的系统变量的新建，填入图片里的信息&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/6.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;打开 cmd，输入命令 &amp;quot;node&amp;quot;，回车，输入 require (&#39;cluster&#39;)，出现配置说明成功&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/7.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;在装有 install.sh 脚本的目录下右键打开 git，输入&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;source install.sh test_node&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;source install.sh test_git&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;出现版本号和成功提示 环境变量配置成功&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/8.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;创建 github&lt;/p&gt;
&lt;h2 id=&#34;安装hexo&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#安装hexo&#34;&gt;#&lt;/a&gt; 安装 Hexo&lt;/h2&gt;
&lt;p&gt;在你想放置博客的文件夹下右键打开 git bash 执行下列命令&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;curl -O https://cdn.jsdelivr.net/gh/kjhuanhao/hexo-script@master/install.sh&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS1pbnN0YWxsLTR0M2tmZHJvMTRnOXhhazU3Ym0ya3NxcWtrb3k0NmdzdGJsODduajQ4Yi5zaA==&#34;&gt;会在你右键的目录下安装一个 install.sh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/9.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;在装有 install.sh 的目录下，打开 git bash 执行下列命令&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;source install.sh hexo_win&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;img data-src=&#34;../../../../img/10.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;中间红色的错误是验证你的 github，如果弹出则输入你的 github 的账号密码，如果没有弹出也可以不管，出现最后一句话后，在你的博客目录下会出现一个 hexoblog 文件夹；&lt;/p&gt;
&lt;p&gt;进入博客目录下，打开 git bash，输入下列命令&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hexo g&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hexo s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;打开浏览器输入&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;http://localhost:4000&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;即可查看自己的初始博客&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/11.JPG&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;创建github仓库&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建github仓库&#34;&gt;#&lt;/a&gt; 创建 github 仓库&lt;/h2&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;https://github.com/&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;先要注册一个 GitHub 账户&lt;/p&gt;
&lt;p&gt;注册完登录后，在 GitHub.com 中看到一个 New repository，点击 new 新建仓库&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/12.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;输入 Repository name，&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3huLS1naXRodWItdnk3aXUwdTk4ZmY3dWxuang3NWJqbDJjbjM5YTRnYS5naXRodWIuaW8=&#34;&gt;建议设置为注册 github 名字.github.io&lt;/span&gt;&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;Jerysury.github.io&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;勾选 Add a README file 自述文件（后续有用），待 Create repository 绿色框亮起则点击创建仓库&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/13.JPG&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;获取ssh密钥&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#获取ssh密钥&#34;&gt;#&lt;/a&gt; 获取 SSH 密钥&lt;/h2&gt;
&lt;p&gt;打开 git bash，输入下列命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &amp;quot;yourname&amp;quot;
git config --global user.email &amp;quot;youremail&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;yourname 输入你的 github 用户名&lt;/p&gt;
&lt;p&gt;youremail 输入你的 github 注册时的邮箱&lt;/p&gt;
&lt;p&gt;输入下列命令查看输入是否正确&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;git config --global --list&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;确保无误后，输入下列命令获取 ssh 密钥&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;ssh-keygen -t rsa -C &#34;youremail&#34;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;出现第一个选项时输入 y，剩余一直空格即可&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/14.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;创建成功后在 C:/ 用户 / 用户名 /.ssh 中找到密钥，带有 pub 后缀的是公钥，没带有 pub 后缀的是私钥，右键用记事本方式打开 id_rsa.pub 文件，复制里面的公钥&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/15.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;回到 github，点击右上角头像，点击 Settings&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/16.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;点击 Access 下方的 SSH and GPK keys，点击 New SSH key&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/17.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;title 输入密钥名，key 里粘贴上一步中所复制的公钥，点击 Add SSH key 添加密钥，即可添加成功&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/18.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;输入下列命令测试是否连通 github&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/19.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;我这里不知道为什么 ip 去到了美国微软哪里，搜了很多办法也没修好，不过网址也能正常运作，我就暂时不管了&lt;/p&gt;
&lt;p&gt;这是成功界面&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/37.png&#34; alt&gt;&lt;/p&gt;
&lt;h2 id=&#34;部署博客&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#部署博客&#34;&gt;#&lt;/a&gt; 部署博客&lt;/h2&gt;
&lt;p&gt;在你的博客根目录下打开_config.yml&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/25.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;打开后拉到最下面，输入图片中的内容&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/26.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;type：指定 git&lt;/p&gt;
&lt;p&gt;repo：你的 github 仓库地址，从仓库地址页面点击 Code，复制其 https 或 git 链接&lt;/p&gt;
&lt;p&gt;branch：github 仓库分支&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/27.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;在博客根目录下打开 git bash，输入指令安装依赖&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;npm install hexo-deployer-git --save&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;安装完后输入&lt;/p&gt;
&lt;figure class=&#34;highlight text&#34;&gt;&lt;figcaption data-lang=&#34;text&#34;&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td data-num=&#34;1&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hexo g&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td data-num=&#34;2&#34;&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;hexo d&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;img data-src=&#34;../../../../img/28.JPG&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;出现以上提示前往仓库查看是否有上传成功，报错不用管，不影响&lt;/p&gt;
&lt;p&gt;输入 http:// 你的 github 用户名.github.io 即可访问博客&lt;/p&gt;
&lt;h1 id=&#34;使用域名访问博客&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用域名访问博客&#34;&gt;#&lt;/a&gt; 使用域名访问博客&lt;/h1&gt;
&lt;p&gt;在完成上面基础后，可以正常访问博客后，可使用域名来代替 github 的网址访问博客&lt;/p&gt;
&lt;p&gt;首先你需要获取一个域名，无论是腾讯云还是阿里云等等都可以，去自定义一个域名购买，域名一年制，只要后缀不是.com 之类的都很便宜，获取域名就不演示了，百度下都知道&lt;/p&gt;
&lt;h2 id=&#34;修改或添加域名文件&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#修改或添加域名文件&#34;&gt;#&lt;/a&gt; 修改或添加域名文件&lt;/h2&gt;
&lt;p&gt;在放置你博客文件的仓库中，先查看有没有 **“&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL1JFQURNRS5tZA==&#34;&gt;README.md&lt;/span&gt;”** 这个文件，这个在创建仓库时候有选过。&lt;/p&gt;
&lt;p&gt;如果有，则会在仓库底下有一栏这样的信息，点击右上角的笔，修改为你购买的域名（不要 www），点击最下方绿色按钮完成修改&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/32.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;如果没有，则在仓库中，点击&lt;strong&gt; Add file&lt;/strong&gt;，&lt;strong&gt;Create new file&lt;/strong&gt;，文件名字填写 READNE，内容填写你购买的域名（不要 www）&lt;/p&gt;
&lt;p&gt;好像如果没有的话，最下方会提示你缺少这个文件，然后你可以选择去创建&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/31.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;设置完文件后，点击仓库的&lt;strong&gt; Settings&lt;/strong&gt;，在侧边栏点击&lt;strong&gt; Pages&lt;/strong&gt;，在&lt;strong&gt; Custom domain&lt;/strong&gt; 中输入你购买的域名（不要 www），点击 save，这时候会提示你 dns 之类的错误，先不管&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/33.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;去到你所购买域名的客户商，查找该客户商的 DNS 解析（每家都不一样）&lt;/p&gt;
&lt;p&gt;添加两行记录&lt;/p&gt;
&lt;p&gt;一行主机记录为 @，类型为 CHAME，记录路径为你的仓库名&lt;/p&gt;
&lt;p&gt;一行主机记录为 www，类型为 CHAME，记录路径为你的仓库名&lt;/p&gt;
&lt;p&gt;这样带不带 www 都可以访问这个域名&lt;/p&gt;
&lt;p&gt;顺带提一句，这里可以解析为你 github 仓库的 ip 地址，但是 github 哪里的 dns 会告诉你转为仓库名&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/34.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;回到 github 哪里，刷新页面重新检查域名 DNS（如果没自动检查就点击旁边的按钮）&lt;/p&gt;
&lt;p&gt;没问题之后最上方会显示你的网址准备好了，复制网址即可让他人访问你的博客了&lt;/p&gt;
&lt;h1 id=&#34;关于sslhttps&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#关于sslhttps&#34;&gt;#&lt;/a&gt; 关于 SSL（https）&lt;/h1&gt;
&lt;p&gt;在自定义域名的下方是有一个强制启动 HTTPS 链接的&lt;strong&gt; Enforce HTTPS&lt;/strong&gt;，因为我在域名哪里弄了 SSL 证书，勾选了这个之后就会提示我的博客链接不安全，证书来自 github（外网缘故？）&lt;/p&gt;
&lt;p&gt;我的建议还是获取证书去域名哪里安装较好&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/35.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;这里以腾讯云为例，搜索 SSL 证书进入此界面，点击申请免费证书，经过里头的填写相关信息即可申请一张一年的免费证书（同一主域最多申请 20 张，也就是 20 年）&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;../../../../img/36.png&#34; alt&gt;&lt;/p&gt;
&lt;p&gt;申请到之后，会让你进行 DNS 验证（有手动和自动，区别在于你之前是否域名进行解析）&lt;/p&gt;
&lt;p&gt;待证书审核通过后可以下载保存&lt;/p&gt;
&lt;p&gt;后面的流程说实话我忘了。请大家自行百度&lt;/p&gt;
</content>
        <category term="计算机科学" scheme="https://entropywhite.com/categories/computer-science/" />
        <category term="hexo博客" scheme="https://entropywhite.com/categories/computer-science/blog/" />
        <category term="Theme Shoka Documentation" scheme="https://entropywhite.com/categories/computer-science/blog/Theme-Shoka-Documentation/" />
        <category term="Hexo" scheme="https://entropywhite.com/tags/Hexo/" />
        <category term="教程" scheme="https://entropywhite.com/tags/%E6%95%99%E7%A8%8B/" />
        <updated>2022-06-10T00:45:00.000Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E5%8A%9F%E8%83%BD/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/blog/Create%20Blog/%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98%E5%8A%9F%E8%83%BD/"/>
        <content type="html"></content>
        <updated>2022-06-10T00:43:15.818Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/css/%E5%85%B6%E4%BB%96CSS/content-visibility/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/css/%E5%85%B6%E4%BB%96CSS/content-visibility/"/>
        <content type="html">&lt;h2 id=&#34;何为-content-visibility&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#何为-content-visibility&#34;&gt;#&lt;/a&gt; 何为  &lt;code&gt;content-visibility&lt;/code&gt; ？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;content-visibility&lt;/code&gt; ：属性控制一个元素是否渲染其内容，它允许用户代理（浏览器）潜在地省略大量布局和渲染工作，直到需要它为止。&lt;/p&gt;
&lt;p&gt;有几个常见的取值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;content-visibility: visible;
content-visibility: hidden;
content-visibility: auto;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;content-visibility: visible&lt;/code&gt; ：默认值，没有任何效果，相当于没有添加  &lt;code&gt;content-visibility&lt;/code&gt; ，元素的渲染与往常一致。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content-visibility: hidden&lt;/code&gt; ：与  &lt;code&gt;display: none&lt;/code&gt;  类似，用户代理将跳过其内容的渲染。（这里需要注意的是，跳过的是内容的渲染）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content-visibility: auto&lt;/code&gt; ：如果该元素不在屏幕上，并且与用户无关，则不会渲染其后代元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;contain-intrinsic-size&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#contain-intrinsic-size&#34;&gt;#&lt;/a&gt; contain-intrinsic-size&lt;/h3&gt;
&lt;p&gt;当然，除  &lt;code&gt;content-visibility&lt;/code&gt;  之外，还有一个与之配套的属性 --  &lt;code&gt;contain-intrinsic-size&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;contain-intrinsic-size&lt;/code&gt; ：控制由  &lt;code&gt;content-visibility&lt;/code&gt;  指定的元素的自然大小。&lt;/p&gt;
&lt;p&gt;上面两个属性光看定义和介绍会有点绕。&lt;/p&gt;
&lt;p&gt;我们首先来看看  &lt;code&gt;content-visibility&lt;/code&gt;  如何具体使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;content-visibility: visible&lt;/code&gt;  是默认值，添加后没有任何效果，我们就直接跳过。&lt;/p&gt;
&lt;h2 id=&#34;利用-content-visibility-hidden-优化展示切换性能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#利用-content-visibility-hidden-优化展示切换性能&#34;&gt;#&lt;/a&gt; 利用  &lt;code&gt;content-visibility: hidden&lt;/code&gt;  优化展示切换性能&lt;/h2&gt;
&lt;p&gt;首先来看看  &lt;code&gt;content-visibility: hidden&lt;/code&gt; ，它通常会拿来和  &lt;code&gt;display: none&lt;/code&gt;  做比较，但是其实它们之间还是有很大的不同的。&lt;/p&gt;
&lt;p&gt;首先，假设我们有两个 DIV 包裹框：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;g-wrap&amp;quot;&amp;gt;
    &amp;lt;div&amp;gt;1111&amp;lt;/div&amp;gt;
    &amp;lt;div class=&amp;quot;hidden&amp;quot;&amp;gt;2222&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置两个 div 为  &lt;code&gt;200x200&lt;/code&gt;  的黑色块：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.g-wrap &amp;gt; div &amp;#123;
    width: 200px;
    height: 200px;
    background: #000;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0Z5uGrwQFUGN9iax3TS0lcuonBdqHpOgWnwACiaAnLgOBHQ3rsZYP7rZdw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;OK，没有问题，接下来，我们给其中的  &lt;code&gt;.hidden&lt;/code&gt;  设置  &lt;code&gt;content-visibility: hidden&lt;/code&gt; ，看看会发生什么：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.hidden &amp;#123;
    content-visibility: hidden;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0Zmot8P62VzRfeq6TGseWB8aZ7p3OqL8Tvj1oMa95K56picO6iapQQcE4Q/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意，仔细看效果，这里添加了  &lt;code&gt;content-visibility: hidden&lt;/code&gt;  之后，&lt;strong&gt;消失的只是添加了该元素的 div 的子元素消失不见，而父元素本身及其样式，还是存在页面上的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果我们去掉设置了  &lt;code&gt;content-visibility: hidden&lt;/code&gt;  的元素本身的  &lt;code&gt;width&lt;/code&gt; 、 &lt;code&gt;height&lt;/code&gt; 、 &lt;code&gt;padding&lt;/code&gt; 、 &lt;code&gt;margin&lt;/code&gt;  等属性，则元素看上去就如同设置了  &lt;code&gt;display: none&lt;/code&gt;  一般，在页面上消失不见了。&lt;/p&gt;
&lt;p&gt;那么， &lt;code&gt;content-visibility: hidden&lt;/code&gt;  的作用是什么呢？&lt;/p&gt;
&lt;p&gt;设置了  &lt;code&gt;content-visibility: hidden&lt;/code&gt;  的元素，&lt;strong&gt;其元素的子元素将被隐藏，但是，它的渲染状态将会被缓存&lt;/strong&gt;。所以，当  &lt;code&gt;content-visibility: hidden&lt;/code&gt;  被移除时，用户代理无需重头开始渲染它和它的子元素。&lt;/p&gt;
&lt;p&gt;因此，如果我们将这个属性应用在一些一开始需要被隐藏，但是其后在页面的某一时刻需要被渲染，或者是一些需要被频繁切换显示、隐藏状态的元素上，其渲染效率将会有一个非常大的提升。&lt;/p&gt;
&lt;h2 id=&#34;利用-content-visibility-auto-实现懒加载或虚拟列表&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#利用-content-visibility-auto-实现懒加载或虚拟列表&#34;&gt;#&lt;/a&gt; 利用  &lt;code&gt;content-visibility: auto&lt;/code&gt;  实现懒加载或虚拟列表&lt;/h2&gt;
&lt;p&gt;OK，接下来是  &lt;code&gt;content-visibility&lt;/code&gt;  的核心用法，利用  &lt;code&gt;auto&lt;/code&gt;  属性值。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;content-visibility: auto&lt;/code&gt;  的作用是，如果该元素不在屏幕上，并且与用户无关，则不会渲染其后代元素。是不是与 LazyLoad 非常类似？&lt;/p&gt;
&lt;p&gt;我们来看这样一个 DEMO ，了解其作用：&lt;/p&gt;
&lt;p&gt;假设，我们存在这样一个 HTML 结构，含有大量的文本内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;g-wrap&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;paragraph&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    // ... 包含了 N 个 paragraph
    &amp;lt;div class=&amp;quot;paragraph&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个  &lt;code&gt;.paragraph&lt;/code&gt;  的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZlicfKepfpKM9LsEyKNEAa4sHIfnuUsvatwBL6C7K87ch3MN58OmL7mQ/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;因此，整个的页面看起来就是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于，我们没有对页面内容进行任何处理，因此，所有的  &lt;code&gt;.paragraph&lt;/code&gt;  在页面刷新的一瞬间，都会进行渲染，看到的效果就如上所示。&lt;/p&gt;
&lt;p&gt;当然，现代浏览器愈加趋于智能，基于这种场景，其实我们非常希望对于仍未看到，仍旧未滚动到的区域，可以延迟加载，只有到我们需要展示、滚动到该处时，页面内容才进行渲染。&lt;/p&gt;
&lt;p&gt;基于这种场景， &lt;code&gt;content-visibility: auto&lt;/code&gt;  就应运而生了，它允许浏览器对于设置了该属性的元素进行判断，如果该元素当前不处于视口内，则不渲染该元素。&lt;/p&gt;
&lt;p&gt;我们基于上述的代码，只需要最小化，添加这样一段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.paragraph &amp;#123;
    content-visibility: auto;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再看看效果，仔细观察右侧的滚动条：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZkW8pdFFIClxN4yTgVCCA5ovG2ib0bUuEfBpTSoAlEHrbQgAezcFxiaiaw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里我使用了  &lt;code&gt;::-webkit-scrollbar&lt;/code&gt;  相关样式，让滚动条更明显。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能你还没意识到发生了什么，我们对比下添加了  &lt;code&gt;content-visibility: auto&lt;/code&gt;  和没有添加  &lt;code&gt;content-visibility: auto&lt;/code&gt;  的两种效果下文本的整体高度：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZEGWYB2KLOLNib2gOhibZ4WMiaFRwJ5sdWEfDSAibwDMuJN6YFm2DZUPvsg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;有着非常明显的差异，这是因为，设置了  &lt;code&gt;content-visibility: auto&lt;/code&gt;  的元素，在非可视区域内，目前并没有被渲染，因此，右侧内容的高度其实是比正常状态下少了一大截的。&lt;/p&gt;
&lt;p&gt;好，我们实际开始进行滚动，看看会发生什么：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;由于下方的元素在滚动的过程中，出现在视口范围内才被渲染，因此，滚动条出现了明显的飘忽不定的抖动现象。（当然这也是使用了  &lt;code&gt;content-visibility: auto&lt;/code&gt;  的一个小问题之一），不过明显可以看出，这与我们通常使用 JavaScript 实现的懒加载或者延迟加载非常类似。&lt;/p&gt;
&lt;p&gt;当然，与懒加载不同的是，在向下滚动的过程中，上方消失的已经被渲染过且消失在视口的元素，也会因为消失在视口中，重新被隐藏。因此，即便页面滚动到最下方，整体的滚动条高度还是没有什么变化的。&lt;/p&gt;
&lt;h2 id=&#34;content-visibility-是否能够优化渲染性能&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#content-visibility-是否能够优化渲染性能&#34;&gt;#&lt;/a&gt;  &lt;code&gt;content-visibility&lt;/code&gt;  是否能够优化渲染性能？&lt;/h2&gt;
&lt;p&gt;那么， &lt;code&gt;content-visibility&lt;/code&gt;  是否能够优化渲染性能呢？&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;Youtube -- Slashing layout cost with content-visibility&lt;/strong&gt; [1] 中，给了一个非常好的例子。&lt;/p&gt;
&lt;p&gt;这里我简单复现一下。&lt;/p&gt;
&lt;p&gt;对于一个存在巨量 HTML 内容的页面，譬如类似于这个页面 -- &lt;strong&gt;HTML - Living Standard&lt;/strong&gt;[2]&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以感受到，往下翻，根本翻不到尽头。（这里我在本地模拟了该页面，复制了该页面的所有 DOM，并非实际在该网站进行测试）&lt;/p&gt;
&lt;p&gt;如果不对这个页面做任何处理，看看首次渲染需要花费的时间：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZHk1xzQO5qJ1ialQcmE6aTkaEvXhqFCUxtqrgiaoeiatz4VPZMl1YUNmWg/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，DOMContentLoaded 的时间的  &lt;code&gt;3s+&lt;/code&gt; ，而花费在 Rendering 上的就有整整  &lt;code&gt;2900ms&lt;/code&gt; ！&lt;/p&gt;
&lt;p&gt;而如果给这个页面的每个段落，添加上  &lt;code&gt;content-visibility: auto&lt;/code&gt; ，再看看整体的耗时：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZNxIaXNwkaI02Ifd5zJRuCbaT1PWknVeNTeRsIQuCC4YC6xaD8wZr6w/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，DOMContentLoaded 的时间骤降至了  &lt;code&gt;500ms+&lt;/code&gt; ，而花费在 Rendering 上的，直接优化到了  &lt;code&gt;61ms&lt;/code&gt; ！&lt;/p&gt;
&lt;p&gt;2900ms --&amp;gt; 61ms，可谓是惊人级别的优化了。因此， &lt;code&gt;content-visibility: auto&lt;/code&gt;  对于长文本、长列表功能的优化是显而易见的。&lt;/p&gt;
&lt;h2 id=&#34;利用-contain-intrinsic-size-解决滚动条抖动问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#利用-contain-intrinsic-size-解决滚动条抖动问题&#34;&gt;#&lt;/a&gt; 利用  &lt;code&gt;contain-intrinsic-size&lt;/code&gt;  解决滚动条抖动问题&lt;/h2&gt;
&lt;p&gt;当然， &lt;code&gt;content-visibility&lt;/code&gt;  也存在一些小问题。&lt;/p&gt;
&lt;p&gt;从上面的例子，也能看到，在利用  &lt;code&gt;content-visibility: auto&lt;/code&gt;  处理长文本、长列表的时候。在滚动页面的过程中，滚动条一直在抖动，这不是一个很好的体验。&lt;/p&gt;
&lt;p&gt;当然，这也是许多虚拟列表都会存在的一些问题。&lt;/p&gt;
&lt;p&gt;好在，规范制定者也发现了这个问题。这里我们可以使用另外一个 CSS 属性，也就是文章一开头提到的另外一个属性 --  &lt;code&gt;contain-intrinsic-size&lt;/code&gt; ，来解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;contain-intrinsic-size&lt;/code&gt; ：控制由  &lt;code&gt;content-visibility&lt;/code&gt;  指定的元素的自然大小。&lt;/p&gt;
&lt;p&gt;什么意思呢？&lt;/p&gt;
&lt;p&gt;还是上面的例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;g-wrap&amp;quot;&amp;gt;
    &amp;lt;div class=&amp;quot;paragraph&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
    // ... 包含了 N 个 paragraph
    &amp;lt;div class=&amp;quot;paragraph&amp;quot;&amp;gt;...&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果我们不使用  &lt;code&gt;contain-intrinsic-size&lt;/code&gt; ，只对视口之外的元素使用  &lt;code&gt;content-visibility: auto&lt;/code&gt; ，那么视口外的元素高度通常就为 0。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当然，如果直接给父元素设置固定的  &lt;code&gt;height&lt;/code&gt; ，也是会有高度的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么实际的滚动效果，滚动条就是抖动的：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以，我们可以同时利用上  &lt;code&gt;contain-intrinsic-size&lt;/code&gt; ，如果能准确知道设置了  &lt;code&gt;content-visibility: auto&lt;/code&gt;  的元素在渲染状态下的高度，就填写对应的高度。如果如法准确知道高度，也可以填写一个大概的值：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.paragraph &amp;#123;
    content-visibility: auto;
    contain-intrinsic-size: 320px;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如此之后，浏览器会给未被实际渲染的视口之外的  &lt;code&gt;.paragraph&lt;/code&gt;  元素一个高度，避免出现滚动条抖动的现象：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_gif/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZbCM0FEwXgXiadeT3tw6Pn4ib3IibQfSFPGqO2nzxYdWam89CXRkS1WVqQ/640?wx_fmt=gif&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;content-visibility-的一些其他问题&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#content-visibility-的一些其他问题&#34;&gt;#&lt;/a&gt;  &lt;code&gt;content-visibility&lt;/code&gt;  的一些其他问题&lt;/h2&gt;
&lt;p&gt;首先，看看  &lt;code&gt;content-visibility&lt;/code&gt;  的兼容性（2022-06-03）：&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://mmbiz.qpic.cn/mmbiz_png/SMw0rcHsoNIwic4w74PUTvz4ibpf4zHc0ZHACoqdZP6j8hicFRnuwBQjtsnVicWCFJ3D25tjolZkEAEVbfibMK7GTGw/640?wx_fmt=png&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&#34; alt=&#34;图片&#34;&gt;&lt;/p&gt;
&lt;p&gt;目前还是比较惨淡的，并且我没有实际在业务中使用它，需要再等待一段时间。&lt;strong&gt;当然，由于该属性属于渐进增强一类的功能，即便失效，也完全不影响页面本身的展示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同时，也有一些同学表示，利用  &lt;code&gt;content-visibility: auto&lt;/code&gt;  只能解决部分场景，在海量 DOM 的场景下的实际效果，还有待进一步的实测。真正运用的时候，多做对比，再做取舍。&lt;/p&gt;
&lt;p&gt;当然，现代浏览器已经越来越智能，类似  &lt;code&gt;content-visibility&lt;/code&gt;  功能的属性也越来越多，我们在性能优化的路上有了更多选择，总归是一件好事。&lt;/p&gt;
</content>
        <updated>2022-06-09T01:32:24.218Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/css/css%E9%A2%84%E5%A4%84%E7%90%86/scss-master/docs/README/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/css/css%E9%A2%84%E5%A4%84%E7%90%86/scss-master/docs/README/"/>
        <content type="html">&lt;h2 id=&#34;basic&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#basic&#34;&gt;#&lt;/a&gt; Basic&lt;/h2&gt;
&lt;p&gt;The generated ggdreams_scss_tutorial&#39;s documentation is at https://ggdreams_scss_tutorial.readthedocs.io/&lt;/p&gt;
&lt;p&gt;This directory contains the documentation source.  It is written using reST&lt;br&gt;
(re-Structured Text) format source files which are processed using Sphinx and&lt;br&gt;
turned into HTML, PDF or ePub documents. If you wish to build these yourself,&lt;br&gt;
you need to install Sphinx. Sphinx is available on many Linux distributions as a&lt;br&gt;
pre-built package. You can also install Sphinx on all platforms using the Python&lt;br&gt;
package manager &amp;quot;pip&amp;quot;. For more information on Sphinx, please visit this page:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL3d3dy5zcGhpbngtZG9jLm9yZw==&#34;&gt;http://www.sphinx-doc.org&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Once Sphinx is installed, the supplied Makefile can be used to build the&lt;br&gt;
different targets.&lt;/p&gt;
&lt;h2 id=&#34;contribute&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#contribute&#34;&gt;#&lt;/a&gt; Contribute&lt;/h2&gt;
&lt;p&gt;直接修改顶层目录中的 &lt;code&gt;.md&lt;/code&gt;  文件，文档将会由 Actions 自动生成，并发布于 readthedocs 文档托管服务。&lt;/p&gt;
</content>
        <updated>2022-06-02T00:52:28.542Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/async%E5%87%BD%E6%95%B0/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/async%E5%87%BD%E6%95%B0/"/>
        <content type="html">&lt;h2 id=&#34;async&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#async&#34;&gt;#&lt;/a&gt; async&lt;/h2&gt;
&lt;p&gt;async 是 ES7 才有的与异步操作有关的关键字，和 Promise ， Generator 有很大关联的。&lt;/p&gt;
&lt;h3 id=&#34;语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#语法&#34;&gt;#&lt;/a&gt; 语法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;async function name([param[, param[, ... param]]]) &amp;#123; statements &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;name: 函数名称。&lt;/li&gt;
&lt;li&gt;param: 要传递给函数的参数的名称。&lt;/li&gt;
&lt;li&gt;statements: 函数体语句。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;返回值&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#返回值&#34;&gt;#&lt;/a&gt; 返回值&lt;/h3&gt;
&lt;p&gt;async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async function helloAsync()&amp;#123;
    return &amp;quot;helloAsync&amp;quot;;
  &amp;#125;
  
console.log(helloAsync())  // Promise &amp;#123;&amp;lt;resolved&amp;gt;: &amp;quot;helloAsync&amp;quot;&amp;#125;
 
helloAsync().then(v=&amp;gt;&amp;#123;
   console.log(v);         // helloAsync
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。&lt;/p&gt;
&lt;p&gt;await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function testAwait()&amp;#123;
   return new Promise((resolve) =&amp;gt; &amp;#123;
       setTimeout(function()&amp;#123;
          console.log(&amp;quot;testAwait&amp;quot;);
          resolve();
       &amp;#125;, 1000);
   &amp;#125;);
&amp;#125;
 
async function helloAsync()&amp;#123;
   await testAwait();
   console.log(&amp;quot;helloAsync&amp;quot;);
 &amp;#125;
helloAsync();
// testAwait
// helloAsync
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;await&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#await&#34;&gt;#&lt;/a&gt; await&lt;/h2&gt;
&lt;p&gt;await 操作符用于等待一个 Promise 对象，它只能在异步函数 async function 内部使用。&lt;/p&gt;
&lt;h3 id=&#34;语法-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#语法-2&#34;&gt;#&lt;/a&gt; 语法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;[return_value] = await expression;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;expression: 一个 Promise 对象或者任何要等待的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;返回值-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#返回值-2&#34;&gt;#&lt;/a&gt; 返回值&lt;/h3&gt;
&lt;p&gt;返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。&lt;/p&gt;
&lt;p&gt;如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function testAwait (x) &amp;#123;
  return new Promise(resolve =&amp;gt; &amp;#123;
    setTimeout(() =&amp;gt; &amp;#123;
      resolve(x);
    &amp;#125;, 2000);
  &amp;#125;);
&amp;#125;
 
async function helloAsync() &amp;#123;
  var x = await testAwait (&amp;quot;hello world&amp;quot;);
  console.log(x); 
&amp;#125;
helloAsync ();
// hello world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function testAwait()&amp;#123;
   console.log(&amp;quot;testAwait&amp;quot;);
&amp;#125;
async function helloAsync()&amp;#123;
   await testAwait();
   console.log(&amp;quot;helloAsync&amp;quot;);
&amp;#125;
helloAsync();
// testAwait
// helloAsync
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;await 针对所跟不同表达式的处理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。&lt;/li&gt;
&lt;li&gt;非 Promise 对象：直接返回对应的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;async function a()&amp;#123;  
  console.log(&amp;quot;1&amp;quot;)  
   console.log(&amp;quot;2&amp;quot;)
&amp;#125;
a()
console.log(&amp;quot;3&amp;quot;)
//打印： 1 2 3 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 await 测试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;async function a()&amp;#123;  
  await 1  
  console.log(&amp;quot;1&amp;quot;)  
  console.log(&amp;quot;2&amp;quot;)
&amp;#125;
a()
console.log(&amp;quot;3&amp;quot;)
//打印： 3 1 2
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-05-26T02:43:38.928Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/Generator%E5%87%BD%E6%95%B0/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/Generator%E5%87%BD%E6%95%B0/"/>
        <content type="html">&lt;p&gt;ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法&lt;/p&gt;
&lt;h3 id=&#34;generator-函数组成&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#generator-函数组成&#34;&gt;#&lt;/a&gt; Generator 函数组成&lt;/h3&gt;
&lt;p&gt;Generator 有两个区分于普通函数的部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是在 function 后面，函数名之前有个 * ；&lt;/li&gt;
&lt;li&gt;函数内部有 yield 表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* func()&amp;#123;
 console.log(&amp;quot;one&amp;quot;);
 yield &#39;1&#39;;
 console.log(&amp;quot;two&amp;quot;);
 yield &#39;2&#39;; 
 console.log(&amp;quot;three&amp;quot;);
 return &#39;3&#39;;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;执行机制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#执行机制&#34;&gt;#&lt;/a&gt; 执行机制&lt;/h3&gt;
&lt;p&gt;调用 Generator 函数和调用普通函数一样，在函数名后面加上 () 即可，但是 Generator 函数不会像普通函数一样立即执行，而是返回一个指向内部状态对象的指针，所以要调用遍历器对象 Iterator 的 next 方法，指针就会从函数头部或者上一次停下来的地方开始执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;f.next();
// one
// &amp;#123;value: &amp;quot;1&amp;quot;, done: false&amp;#125;
 
f.next();
// two
// &amp;#123;value: &amp;quot;2&amp;quot;, done: false&amp;#125;
 
f.next();
// three
// &amp;#123;value: &amp;quot;3&amp;quot;, done: true&amp;#125;
 
f.next();
// &amp;#123;value: undefined, done: true&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次调用 next 方法时，从 Generator 函数的头部开始执行，先是打印了 one , 执行到 yield 就停下来，并将 yield 后边表达式的值 &#39;1&#39;，作为返回对象的 value 属性值，此时函数还没有执行完， 返回对象的 done 属性值是 false。&lt;/p&gt;
&lt;p&gt;第二次调用 next 方法时，同上步 。&lt;/p&gt;
&lt;p&gt;第三次调用 next 方法时，先是打印了 three ，然后执行了函数的返回操作，并将 return 后面的表达式的值，作为返回对象的 value 属性值，此时函数已经结束，多以 done 属性值为 true 。&lt;/p&gt;
&lt;p&gt;第四次调用 next 方法时， 此时函数已经执行完了，所以返回 value 属性值是 undefined ，done 属性值是 true 。如果执行第三步时，没有 return 语句的话，就直接返回 {value: undefined, done: true}。&lt;/p&gt;
&lt;h3 id=&#34;函数返回的遍历器对象的方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数返回的遍历器对象的方法&#34;&gt;#&lt;/a&gt; 函数返回的遍历器对象的方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;next 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，next 方法不传入参数的时候，yield 表达式的返回值是 undefined 。当 next 传入参数的时候，该参数会作为上一步 yield 的返回值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* sendParameter()&amp;#123;
    console.log(&amp;quot;start&amp;quot;);
    var x = yield &#39;2&#39;;
    console.log(&amp;quot;one:&amp;quot; + x);
    var y = yield &#39;3&#39;;
    console.log(&amp;quot;two:&amp;quot; + y);
    console.log(&amp;quot;total:&amp;quot; + (x + y));
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;next 不传参&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var sendp1 = sendParameter();
sendp1.next();
// start
// &amp;#123;value: &amp;quot;2&amp;quot;, done: false&amp;#125;
sendp1.next();
// one:undefined
// &amp;#123;value: &amp;quot;3&amp;quot;, done: false&amp;#125;
sendp1.next();
// two:undefined
// total:NaN
// &amp;#123;value: undefined, done: true&amp;#125;
next传参
var sendp2 = sendParameter();
sendp2.next(10);
// start
// &amp;#123;value: &amp;quot;2&amp;quot;, done: false&amp;#125;
sendp2.next(20);
// one:20
// &amp;#123;value: &amp;quot;3&amp;quot;, done: false&amp;#125;
sendp2.next(30);
// two:30
// total:50
// &amp;#123;value: undefined, done: true&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了使用 next ，还可以使用 for... of 循环遍历 Generator 函数生产的 Iterator 对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;return 方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;return 方法返回给定值，并结束遍历 Generator 函数。&lt;/p&gt;
&lt;p&gt;return 方法提供参数时，返回该参数；不提供参数时，返回 undefined 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* foo()&amp;#123;
    yield 1;
    yield 2;
    yield 3;
&amp;#125;
var f = foo();
f.next();
// &amp;#123;value: 1, done: false&amp;#125;
f.return(&amp;quot;foo&amp;quot;);
// &amp;#123;value: &amp;quot;foo&amp;quot;, done: true&amp;#125;
f.next();
// &amp;#123;value: undefined, done: true&amp;#125;
throw 方法
throw 方法可以再 Generator 函数体外面抛出异常，再函数体内部捕获。
var g = function* () &amp;#123;
  try &amp;#123;
    yield;
  &amp;#125; catch (e) &amp;#123;
    console.log(&#39;catch inner&#39;, e);
  &amp;#125;
&amp;#125;;
 
var i = g();
i.next();
 
try &amp;#123;
  i.throw(&#39;a&#39;);
  i.throw(&#39;b&#39;);
&amp;#125; catch (e) &amp;#123;
  console.log(&#39;catch outside&#39;, e);
&amp;#125;
// catch inner a
// catch outside b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;遍历器对象抛出了两个错误，第一个被 Generator 函数内部捕获，第二个因为函数体内部的 catch 函数已经执行过了，不会再捕获这个错误，所以这个错误就抛出 Generator 函数体，被函数体外的 catch 捕获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;yield* 表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;yield* 表达式表示 yield 返回一个遍历器对象，用于在 Generator 函数内部，调用另一个 Generator 函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* callee() &amp;#123;
    console.log(&#39;callee: &#39; + (yield));
&amp;#125;
function* caller() &amp;#123;
    while (true) &amp;#123;
        yield* callee();
    &amp;#125;
&amp;#125;
const callerObj = caller();
callerObj.next();
// &amp;#123;value: undefined, done: false&amp;#125;
callerObj.next(&amp;quot;a&amp;quot;);
// callee: a
// &amp;#123;value: undefined, done: false&amp;#125;
callerObj.next(&amp;quot;b&amp;quot;);
// callee: b
// &amp;#123;value: undefined, done: false&amp;#125;
 
// 等同于
function* caller() &amp;#123;
    while (true) &amp;#123;
        for (var value of callee) &amp;#123;
          yield value;
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用场景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#使用场景&#34;&gt;#&lt;/a&gt; 使用场景&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实现 Iterator&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为不具备 Iterator 接口的对象提供遍历方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function* objectEntries(obj) &amp;#123;
    const propKeys = Reflect.ownKeys(obj);
    for (const propKey of propKeys) &amp;#123;
        yield [propKey, obj[propKey]];
    &amp;#125;
&amp;#125;
 
const jane = &amp;#123; first: &#39;Jane&#39;, last: &#39;Doe&#39; &amp;#125;;
for (const [key,value] of objectEntries(jane)) &amp;#123;
    console.log(`$&amp;#123;key&amp;#125;: $&amp;#123;value&amp;#125;`);
&amp;#125;
// first: Jane
// last: Doe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Reflect.ownKeys () 返回对象所有的属性，不管属性是否可枚举，包括 Symbol。&lt;/p&gt;
&lt;p&gt;jane 原生是不具备 Iterator 接口无法通过 for... of 遍历。这边用了 Generator 函数加上了 Iterator 接口，所以就可以遍历 jane 对象了。&lt;/p&gt;
</content>
        <updated>2022-05-26T02:43:31.605Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/Promise%E5%AF%B9%E8%B1%A1/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/Promise%E5%AF%B9%E8%B1%A1/"/>
        <content type="html">&lt;h2 id=&#34;概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述&#34;&gt;#&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;是异步编程的一种解决方案。&lt;/p&gt;
&lt;p&gt;从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。&lt;/p&gt;
&lt;h2 id=&#34;promise-状态&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#promise-状态&#34;&gt;#&lt;/a&gt; Promise 状态&lt;/h2&gt;
&lt;h3 id=&#34;状态的特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#状态的特点&#34;&gt;#&lt;/a&gt; 状态的特点&lt;/h3&gt;
&lt;p&gt;Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。&lt;/p&gt;
&lt;p&gt;Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const p1 = new Promise(function(resolve,reject)&amp;#123;
    resolve(&#39;success1&#39;);
    resolve(&#39;success2&#39;);
&amp;#125;); 
const p2 = new Promise(function(resolve,reject)&amp;#123;  
    resolve(&#39;success3&#39;); 
    reject(&#39;reject&#39;);
&amp;#125;);
p1.then(function(value)&amp;#123;  
    console.log(value); // success1
&amp;#125;);
p2.then(function(value)&amp;#123; 
    console.log(value); // success3
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;状态的缺点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#状态的缺点&#34;&gt;#&lt;/a&gt; 状态的缺点&lt;/h3&gt;
&lt;p&gt;无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。&lt;/p&gt;
&lt;p&gt;如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。&lt;/p&gt;
&lt;p&gt;当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。&lt;/p&gt;
&lt;h2 id=&#34;then-方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#then-方法&#34;&gt;#&lt;/a&gt; then 方法&lt;/h2&gt;
&lt;p&gt;then 方法接收两个函数作为参数，第一个参数是 Promise 执行成功时的回调，第二个参数是 Promise 执行失败时的回调，两个函数只会有一个被调用。&lt;/p&gt;
&lt;h3 id=&#34;then-方法的特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#then-方法的特点&#34;&gt;#&lt;/a&gt; then 方法的特点&lt;/h3&gt;
&lt;p&gt;在 JavaScript 事件队列的当前运行完成之前，回调函数永远不会被调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const p = new Promise(function(resolve,reject)&amp;#123;
  resolve(&#39;success&#39;);
&amp;#125;);
 
p.then(function(value)&amp;#123;
  console.log(value);
&amp;#125;);
 
console.log(&#39;first&#39;);
// first
// success
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;strong&gt;.then&lt;/strong&gt; 形式添加的回调函数，不论什么时候，都会被调用。&lt;/p&gt;
&lt;p&gt;通过多次调用&lt;/p&gt;
&lt;p&gt;.then&lt;/p&gt;
&lt;p&gt;，可以添加多个回调函数，它们会按照插入顺序并且独立运行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const p = new Promise(function(resolve,reject)&amp;#123;
  resolve(1);
&amp;#125;).then(function(value)&amp;#123; // 第一个then // 1
  console.log(value);
  return value * 2;
&amp;#125;).then(function(value)&amp;#123; // 第二个then // 2
  console.log(value);
&amp;#125;).then(function(value)&amp;#123; // 第三个then // undefined
  console.log(value);
  return Promise.resolve(&#39;resolve&#39;); 
&amp;#125;).then(function(value)&amp;#123; // 第四个then // resolve
  console.log(value);
  return Promise.reject(&#39;reject&#39;); 
&amp;#125;).then(function(value)&amp;#123; // 第五个then //reject:reject
  console.log(&#39;resolve:&#39; + value);
&amp;#125;, function(err) &amp;#123;
  console.log(&#39;reject:&#39; + err);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then 方法将返回一个 resolved 或 rejected 状态的 Promise 对象用于链式调用，且 Promise 对象的值就是这个返回值。&lt;/p&gt;
&lt;h3 id=&#34;then-方法注意点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#then-方法注意点&#34;&gt;#&lt;/a&gt; then 方法注意点&lt;/h3&gt;
&lt;p&gt;简便的 Promise 链式编程最好保持扁平化，不要嵌套 Promise。&lt;/p&gt;
&lt;p&gt;注意总是返回或终止 Promise 链。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const p1 = new Promise(function(resolve,reject)&amp;#123;
  resolve(1);
&amp;#125;).then(function(result) &amp;#123;
  p2(result).then(newResult =&amp;gt; p3(newResult));
&amp;#125;).then(() =&amp;gt; p4());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建新 Promise 但忘记返回它时，对应链条被打破，导致 p4 会与 p2 和 p3 同时进行。&lt;/p&gt;
&lt;p&gt;大多数浏览器中不能终止的 Promise 链里的 rejection，建议后面都跟上 &lt;strong&gt;.catch(error =&amp;gt; console.log(error));&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;更多文章&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#更多文章&#34;&gt;#&lt;/a&gt; 更多文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;JS-Promise%E5%AF%B9%E8%B1%A1&#34;&gt;JS-Promise 对象&lt;/a&gt;&lt;/p&gt;
</content>
        <updated>2022-05-26T02:43:24.985Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%A8%A1%E5%9D%97/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%A8%A1%E5%9D%97/"/>
        <content type="html">&lt;h2 id=&#34;概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述&#34;&gt;#&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;在 ES6 前， 实现模块化使用的是 RequireJS 或者 seaJS（分别是基于 AMD 规范的模块化库， 和基于 CMD 规范的模块化库）。&lt;/p&gt;
&lt;p&gt;ES6 引入了模块化，其设计思想是在编译时就能确定模块的依赖关系，以及输入和输出的变量。&lt;/p&gt;
&lt;p&gt;ES6 的模块化分为导出（export） @与导入（import）两个模块。&lt;/p&gt;
&lt;h2 id=&#34;特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#特点&#34;&gt;#&lt;/a&gt; 特点&lt;/h2&gt;
&lt;p&gt;ES6 的模块自动开启严格模式，不管你有没有在模块头部加上 &lt;strong&gt;use strict;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;模块中可以导入和导出各种类型的变量，如函数，对象，字符串，数字，布尔值，类等。&lt;/p&gt;
&lt;p&gt;每个模块都有自己的上下文，每一个模块内声明的变量都是局部变量，不会污染全局作用域。&lt;/p&gt;
&lt;p&gt;每一个模块只加载一次（是单例的）， 若再去加载同目录下同文件，直接从内存中读取。&lt;/p&gt;
&lt;h2 id=&#34;export-与-import&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#export-与-import&#34;&gt;#&lt;/a&gt; export 与 import&lt;/h2&gt;
&lt;h3 id=&#34;基本用法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本用法&#34;&gt;#&lt;/a&gt; 基本用法&lt;/h3&gt;
&lt;p&gt;模块导入导出各种类型的变量，如字符串，数值，函数，类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导出的函数声明与类声明必须要有名称（export default 命令另外考虑）。&lt;/li&gt;
&lt;li&gt;不仅能导出声明还能导出引用（例如函数）。&lt;/li&gt;
&lt;li&gt;export 命令可以出现在模块的任何位置，但必需处于模块顶层。&lt;/li&gt;
&lt;li&gt;import 命令会提升到整个模块的头部，首先执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*-----export [test.js]-----*/
let myName = &amp;quot;Tom&amp;quot;;
let myAge = 20;
let myfn = function()&amp;#123;
    return &amp;quot;My name is&amp;quot; + myName + &amp;quot;! I&#39;m &#39;&amp;quot; + myAge + &amp;quot;years old.&amp;quot;
&amp;#125;
let myClass =  class myClass &amp;#123;
    static a = &amp;quot;yeah!&amp;quot;;
&amp;#125;
export &amp;#123; myName, myAge, myfn, myClass &amp;#125;
 
/*-----import [xxx.js]-----*/
import &amp;#123; myName, myAge, myfn, myClass &amp;#125; from &amp;quot;./test.js&amp;quot;;
console.log(myfn());// My name is Tom! I&#39;m 20 years old.
console.log(myAge);// 20
console.log(myName);// Tom
console.log(myClass.a );// yeah!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建议使用大括号指定所要输出的一组变量写在文档尾部，明确导出的接口。&lt;/p&gt;
&lt;p&gt;函数与类都需要有对应的名称，导出文档尾部也避免了无对应名称。&lt;/p&gt;
&lt;h3 id=&#34;as-的用法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#as-的用法&#34;&gt;#&lt;/a&gt; as 的用法&lt;/h3&gt;
&lt;p&gt;export 命令导出的接口名称，须和模块内部的变量有一一对应关系。&lt;/p&gt;
&lt;p&gt;导入的变量名，须和导出的接口名称相同，即顺序可以不一致。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*-----export [test.js]-----*/
let myName = &amp;quot;Tom&amp;quot;;
export &amp;#123; myName as exportName &amp;#125;
 
/*-----import [xxx.js]-----*/
import &amp;#123; exportName &amp;#125; from &amp;quot;./test.js&amp;quot;;
console.log(exportName);// Tom
使用 as 重新定义导出的接口名称，隐藏模块内部的变量
/*-----export [test1.js]-----*/
let myName = &amp;quot;Tom&amp;quot;;
export &amp;#123; myName &amp;#125;
/*-----export [test2.js]-----*/
let myName = &amp;quot;Jerry&amp;quot;;
export &amp;#123; myName &amp;#125;
/*-----import [xxx.js]-----*/
import &amp;#123; myName as name1 &amp;#125; from &amp;quot;./test1.js&amp;quot;;
import &amp;#123; myName as name2 &amp;#125; from &amp;quot;./test2.js&amp;quot;;
console.log(name1);// Tom
console.log(name2);// Jerry
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同模块导出接口名称命名重复， 使用 as 重新定义变量名。&lt;/p&gt;
&lt;h3 id=&#34;import-命令的特点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#import-命令的特点&#34;&gt;#&lt;/a&gt; import 命令的特点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;只读属性&lt;/strong&gt;：不允许在加载模块的脚本里面，改写接口的引用指向，即可以改写 import 变量类型为对象的属性值，不能改写 import 变量类型为基本类型的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;#123;a&amp;#125; from &amp;quot;./xxx.js&amp;quot;
a = &amp;#123;&amp;#125;; // error
 
import &amp;#123;a&amp;#125; from &amp;quot;./xxx.js&amp;quot;
a.foo = &amp;quot;hello&amp;quot;; // a = &amp;#123; foo : &#39;hello&#39; &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;单例模式&lt;/strong&gt;：多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。import 同一模块，声明不同接口引用，会声明对应变量，但只执行一次 import 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;#123; a &amp;#125; &amp;quot;./xxx.js&amp;quot;;
import &amp;#123; a &amp;#125; &amp;quot;./xxx.js&amp;quot;;
// 相当于 import &amp;#123; a &amp;#125; &amp;quot;./xxx.js&amp;quot;;
 
import &amp;#123; a &amp;#125; from &amp;quot;./xxx.js&amp;quot;;
import &amp;#123; b &amp;#125; from &amp;quot;./xxx.js&amp;quot;;
// 相当于 import &amp;#123; a, b &amp;#125; from &amp;quot;./xxx.js&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态执行特性：import 是静态执行，所以不能使用表达式和变量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &amp;#123; &amp;quot;f&amp;quot; + &amp;quot;oo&amp;quot; &amp;#125; from &amp;quot;methods&amp;quot;;
// error
let module = &amp;quot;methods&amp;quot;;
import &amp;#123; foo &amp;#125; from module;
// error
if (true) &amp;#123;
  import &amp;#123; foo &amp;#125; from &amp;quot;method1&amp;quot;;
&amp;#125; else &amp;#123;
  import &amp;#123; foo &amp;#125; from &amp;quot;method2&amp;quot;;
&amp;#125;
// error
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;export-default-命令&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#export-default-命令&#34;&gt;#&lt;/a&gt; export default 命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在一个文件或模块中，export、import 可以有多个，export default 仅有一个。&lt;/li&gt;
&lt;li&gt;export default 中的 default 是对应的导出接口变量。&lt;/li&gt;
&lt;li&gt;通过 export 方式导出，在导入时要加 { }，export default 则不需要。&lt;/li&gt;
&lt;li&gt;export default 向外暴露的成员，可以使用任意变量来接收。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var a = &amp;quot;My name is Tom!&amp;quot;;
export default a; // 仅有一个
export default var c = &amp;quot;error&amp;quot;; 
// error，default 已经是对应的导出变量，不能跟着变量声明语句
 
import b from &amp;quot;./xxx.js&amp;quot;; // 不需要加&amp;#123;&amp;#125;， 使用任意变量接收
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;复合使用&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复合使用&#34;&gt;#&lt;/a&gt; 复合使用&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：import () 是提案，这边暂时不延伸讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;export 与 import 可以在同一模块使用，使用特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以将导出接口改名，包括 default。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复合使用 export 与 import ，也可以导出全部，当前模块导出的接口会覆盖继承导出的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; export &amp;#123; foo, bar &amp;#125; from &amp;quot;methods&amp;quot;;
  
 // 约等于下面两段语句，不过上面导入导出方式该模块没有导入 foo 与 bar
 import &amp;#123; foo, bar &amp;#125; from &amp;quot;methods&amp;quot;;
 export &amp;#123; foo, bar &amp;#125;;
  
 /* ------- 特点 1 --------*/
 // 普通改名
 export &amp;#123; foo as bar &amp;#125; from &amp;quot;methods&amp;quot;;
 // 将 foo 转导成 default
 export &amp;#123; foo as default &amp;#125; from &amp;quot;methods&amp;quot;;
 // 将 default 转导成 foo
 export &amp;#123; default as foo &amp;#125; from &amp;quot;methods&amp;quot;;
  
 /* ------- 特点 2 --------*/
 export * from &amp;quot;methods&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
        <updated>2022-05-26T02:43:21.624Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/Class%E7%B1%BB/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/Class%E7%B1%BB/"/>
        <content type="html">&lt;h2 id=&#34;概述&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#概述&#34;&gt;#&lt;/a&gt; 概述&lt;/h2&gt;
&lt;p&gt;在 ES6 中，class (类) 作为对象的模板被引入，可以通过 class 关键字定义类。&lt;/p&gt;
&lt;p&gt;class 的本质是 function。&lt;/p&gt;
&lt;p&gt;它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。&lt;/p&gt;
&lt;h2 id=&#34;基础用法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基础用法&#34;&gt;#&lt;/a&gt; 基础用法&lt;/h2&gt;
&lt;h3 id=&#34;类定义&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类定义&#34;&gt;#&lt;/a&gt; 类定义&lt;/h3&gt;
&lt;p&gt;类表达式可以为匿名或命名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 匿名类
let Example = class &amp;#123;
    constructor(a) &amp;#123;
        this.a = a;
    &amp;#125;
&amp;#125;
// 命名类
let Example = class Example &amp;#123;
    constructor(a) &amp;#123;
        this.a = a;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;类声明&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类声明&#34;&gt;#&lt;/a&gt; 类声明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
    constructor(a) &amp;#123;
        this.a = a;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意要点：不可重复声明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example&amp;#123;&amp;#125;
class Example&amp;#123;&amp;#125;
// Uncaught SyntaxError: Identifier &#39;Example&#39; has already been 
// declared
 
let Example1 = class&amp;#123;&amp;#125;
class Example&amp;#123;&amp;#125;
// Uncaught SyntaxError: Identifier &#39;Example&#39; has already been 
// declared
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意要点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#注意要点&#34;&gt;#&lt;/a&gt; 注意要点&lt;/h3&gt;
&lt;p&gt;类定义不会被提升，这意味着，必须在访问前对类进行定义，否则就会报错。&lt;/p&gt;
&lt;p&gt;类中方法不需要 function 关键字。&lt;/p&gt;
&lt;p&gt;方法间不能加分号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new Example(); 
class Example &amp;#123;&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;类的主体&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类的主体&#34;&gt;#&lt;/a&gt; 类的主体&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;prototype&lt;/p&gt;
&lt;p&gt;ES6 中，prototype 仍旧存在，虽然可以直接自类中定义方法，但是其实方法还是定义在 prototype 上的。 覆盖方法 / 初始化时添加方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Example.prototype=&amp;#123;
    //methods
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.assign(Example.prototype,&amp;#123;
    //methods
&amp;#125;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态属性&lt;/p&gt;
&lt;p&gt;静态属性：class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
// 新提案
    static a = 2;
&amp;#125;
// 目前可行写法
Example.b = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;公共属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example&amp;#123;&amp;#125;
Example.prototype.a = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例属性&lt;/p&gt;
&lt;p&gt;实例属性：定义在实例对象（ this ）上的属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
    a = 2;
    constructor () &amp;#123;
        console.log(this.a);
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;name 属性&lt;/p&gt;
&lt;p&gt;返回跟在 class 后的类名 (存在时)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let Example=class Exam &amp;#123;
    constructor(a) &amp;#123;
        this.a = a;
    &amp;#125;
&amp;#125;
console.log(Example.name); // Exam
 
let Example=class &amp;#123;
    constructor(a) &amp;#123;
        this.a = a;
    &amp;#125;
&amp;#125;
console.log(Example.name); // Example
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;constructor 方法&lt;/p&gt;
&lt;p&gt;constructor 方法是类的默认方法，创建类的实例化对象时被调用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example&amp;#123;
    constructor()&amp;#123;
      console.log(&#39;我是constructor&#39;);
    &amp;#125;
&amp;#125;
new Example(); // 我是constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Test &amp;#123;
    constructor()&amp;#123;
        // 默认返回实例对象 this
    &amp;#125;
&amp;#125;
console.log(new Test() instanceof Test); // true
 
class Example &amp;#123;
    constructor()&amp;#123;
        // 指定返回对象
        return new Test();
    &amp;#125;
&amp;#125;
console.log(new Example() instanceof Example); // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example&amp;#123;
    static sum(a, b) &amp;#123;
        console.log(a+b);
    &amp;#125;
&amp;#125;
Example.sum(1, 2); // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原型方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
    sum(a, b) &amp;#123;
        console.log(a + b);
    &amp;#125;
&amp;#125;
let exam = new Example();
exam.sum(1, 2); // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
    constructor() &amp;#123;
        this.sum = (a, b) =&amp;gt; &amp;#123;
            console.log(a + b);
        &amp;#125;
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;类的实例化&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类的实例化&#34;&gt;#&lt;/a&gt; 类的实例化&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;class 的实例化必须通过 new 关键字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;&amp;#125;
 
let exam1 = Example(); 
// Class constructor Example cannot be invoked without &#39;new&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实例化对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;共享原型对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
    constructor(a, b) &amp;#123;
        this.a = a;
        this.b = b;
        console.log(&#39;Example&#39;);
    &amp;#125;
    sum() &amp;#123;
        return this.a + this.b;
    &amp;#125;
&amp;#125;
let exam1 = new Example(2, 1);
let exam2 = new Example(3, 1);
 
// __proto__ 已废弃，不建议使用
// console.log(exam1.__proto__ == exam2.__proto__); 
 
console.log(Object.getPrototypeOf(exam1) === Object.getPrototypeOf(exam2));// true
 
Object.getPrototypeOf(exam1).sub = function() &amp;#123;
    return this.a - this.b;
&amp;#125;
console.log(exam1.sub()); // 1
console.log(exam2.sub()); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;decorator&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#decorator&#34;&gt;#&lt;/a&gt; decorator&lt;/h2&gt;
&lt;p&gt;decorator 是一个函数，用来修改类的行为，在代码编译时产生作用。&lt;/p&gt;
&lt;h3 id=&#34;类修饰&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类修饰&#34;&gt;#&lt;/a&gt; 类修饰&lt;/h3&gt;
&lt;p&gt;一个参数&lt;/p&gt;
&lt;p&gt;第一个参数 target，指向类本身&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function testable(target) &amp;#123;
    target.isTestable = true;
&amp;#125;
@testable
class Example &amp;#123;&amp;#125;
Example.isTestable; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个参数 —— 嵌套实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function testable(isTestable) &amp;#123;
    return function(target) &amp;#123;
        target.isTestable=isTestable;
    &amp;#125;
&amp;#125;
@testable(true)
class Example &amp;#123;&amp;#125;
Example.isTestable; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例属性&lt;/p&gt;
&lt;p&gt;上面两个例子添加的是静态属性，若要添加实例属性，在类的 prototype 上操作即可。&lt;/p&gt;
&lt;h3 id=&#34;方法修饰&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#方法修饰&#34;&gt;#&lt;/a&gt; 方法修饰&lt;/h3&gt;
&lt;p&gt;3 个参数：target（类的原型对象）、name（修饰的属性名）、descriptor（该属性的描述对象）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
    @writable
    sum(a, b) &amp;#123;
        return a + b;
    &amp;#125;
&amp;#125;
function writable(target, name, descriptor) &amp;#123;
    descriptor.writable = false;
    return descriptor; // 必须返回
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修饰器执行顺序&lt;/p&gt;
&lt;p&gt;由外向内进入，由内向外执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
    @logMethod(1)
    @logMethod(2)
    sum(a, b)&amp;#123;
        return a + b;
    &amp;#125;
&amp;#125;
function logMethod(id) &amp;#123;
    console.log(&#39;evaluated logMethod&#39;+id);
    return (target, name, desctiptor) =&amp;gt; console.log(&#39;excuted         logMethod &#39;+id);
&amp;#125;
// evaluated logMethod 1
// evaluated logMethod 2
// excuted logMethod 2
// excuted logMethod 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;封装与继承&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#封装与继承&#34;&gt;#&lt;/a&gt; 封装与继承&lt;/h2&gt;
&lt;h3 id=&#34;getter-setter&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#getter-setter&#34;&gt;#&lt;/a&gt; getter / setter&lt;/h3&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example&amp;#123;
    constructor(a, b) &amp;#123;
        this.a = a; // 实例化时调用 set 方法
        this.b = b;
    &amp;#125;
    get a()&amp;#123;
        console.log(&#39;getter&#39;);
        return this.a;
    &amp;#125;
    set a(a)&amp;#123;
        console.log(&#39;setter&#39;);
        this.a = a; // 自身递归调用
    &amp;#125;
&amp;#125;
let exam = new Example(1,2); // 不断输出 setter ，最终导致 RangeError
class Example1&amp;#123;
    constructor(a, b) &amp;#123;
        this.a = a;
        this.b = b;
    &amp;#125;
    get a()&amp;#123;
        console.log(&#39;getter&#39;);
        return this._a;
    &amp;#125;
    set a(a)&amp;#123;
        console.log(&#39;setter&#39;);
        this._a = a;
    &amp;#125;
&amp;#125;
let exam1 = new Example1(1,2); // 只输出 setter , 不会调用 getter 方法
console.log(exam1._a); // 1, 可以直接访问
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getter 不可单独出现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Example &amp;#123;
    constructor(a) &amp;#123;
        this.a = a; 
    &amp;#125;
    get a() &amp;#123;
        return this.a;
    &amp;#125;
&amp;#125;
let exam = new Example(1); // Uncaught TypeError: Cannot set property // a of #&amp;lt;Example&amp;gt; which has only a getter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;getter 与 setter 必须同级出现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father &amp;#123;
    constructor()&amp;#123;&amp;#125;
    get a() &amp;#123;
        return this._a;
    &amp;#125;
&amp;#125;
class Child extends Father &amp;#123;
    constructor()&amp;#123;
        super();
    &amp;#125;
    set a(a) &amp;#123;
        this._a = a;
    &amp;#125;
&amp;#125;
let test = new Child();
test.a = 2;
console.log(test.a); // undefined
 
class Father1 &amp;#123;
    constructor()&amp;#123;&amp;#125;
    // 或者都放在子类中
    get a() &amp;#123;
        return this._a;
    &amp;#125;
    set a(a) &amp;#123;
        this._a = a;
    &amp;#125;
&amp;#125;
class Child1 extends Father1 &amp;#123;
    constructor()&amp;#123;
        super();
    &amp;#125;
&amp;#125;
let test1 = new Child1();
test1.a = 2;
console.log(test1.a); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;extends&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#extends&#34;&gt;#&lt;/a&gt; extends&lt;/h3&gt;
&lt;p&gt;通过 extends 实现类的继承&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Child extends Father &amp;#123; ... &amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;super&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#super&#34;&gt;#&lt;/a&gt; super&lt;/h3&gt;
&lt;p&gt;子类 constructor 方法中必须有 super ，且必须出现在 this 之前&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father &amp;#123;
    constructor() &amp;#123;&amp;#125;
&amp;#125;
class Child extends Father &amp;#123;
    constructor() &amp;#123;&amp;#125;
    // or 
    // constructor(a) &amp;#123;
        // this.a = a;
        // super();
    // &amp;#125;
&amp;#125;
let test = new Child(); // Uncaught ReferenceError: Must call super 
// constructor in derived class before accessing &#39;this&#39; or returning 
// from derived constructor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用父类构造函数，只能出现在子类的构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Father &amp;#123;
    test()&amp;#123;
        return 0;
    &amp;#125;
    static test1()&amp;#123;
        return 1;
    &amp;#125;
&amp;#125;
class Child extends Father &amp;#123;
    constructor()&amp;#123;
        super();
    &amp;#125;
&amp;#125;
class Child1 extends Father &amp;#123;
    test2() &amp;#123;
        super(); // Uncaught SyntaxError: &#39;super&#39; keyword unexpected     
        // here
    &amp;#125;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用父类方法，super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Child2 extends Father &amp;#123;
    constructor()&amp;#123;
        super();
        // 调用父类普通方法
        console.log(super.test()); // 0
    &amp;#125;
    static test3()&amp;#123;
        // 调用父类静态方法
        return super.test1+2;
    &amp;#125;
&amp;#125;
Child2.test3(); // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意要点-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#注意要点-2&#34;&gt;#&lt;/a&gt; 注意要点&lt;/h3&gt;
&lt;p&gt;不可继承常规对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Father = &amp;#123;
    // ...
&amp;#125;
class Child extends Father &amp;#123;
     // ...
&amp;#125;
// Uncaught TypeError: Class extends value #&amp;lt;Object&amp;gt; is not a constructor or null
 
// 解决方案
Object.setPrototypeOf(Child.prototype, Father);
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-05-26T02:43:17.276Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%87%BD%E6%95%B0/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%87%BD%E6%95%B0/"/>
        <content type="html">&lt;h2 id=&#34;函数参数的扩展&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#函数参数的扩展&#34;&gt;#&lt;/a&gt; 函数参数的扩展&lt;/h2&gt;
&lt;h3 id=&#34;默认参数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#默认参数&#34;&gt;#&lt;/a&gt; 默认参数&lt;/h3&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fn(name,age=17)&amp;#123;
 console.log(name+&amp;quot;,&amp;quot;+age);
&amp;#125;
fn(&amp;quot;Amy&amp;quot;,18);  // Amy,18
fn(&amp;quot;Amy&amp;quot;,&amp;quot;&amp;quot;);  // Amy,
fn(&amp;quot;Amy&amp;quot;);     // Amy,17
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意点：使用函数默认参数时，不允许有同名参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 不报错
function fn(name,name)&amp;#123;
 console.log(name);
&amp;#125;
 
// 报错
//SyntaxError: Duplicate parameter name not allowed in this context
function fn(name,name,age=17)&amp;#123;
 console.log(name+&amp;quot;,&amp;quot;+age);
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只有在未传递参数，或者参数为 undefined 时，才会使用默认参数，null 值被认为是有效的值传递&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fn(name,age=17)&amp;#123;
    console.log(name+&amp;quot;,&amp;quot;+age);
&amp;#125;
fn(&amp;quot;Amy&amp;quot;,null); // Amy,null
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数参数默认值存在暂时性死区，在函数参数默认值表达式中，还未初始化赋值的参数值无法作为其他参数的默认值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(x,y=x)&amp;#123;
    console.log(x,y);
&amp;#125;
f(1);  // 1 1
 
function f(x=y)&amp;#123;
    console.log(x);
&amp;#125;
f();  // ReferenceError: y is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;不定参数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不定参数&#34;&gt;#&lt;/a&gt; 不定参数&lt;/h3&gt;
&lt;p&gt;不定参数用来表示不确定参数个数，形如，... 变量名，由... 加上一个具名参数标识符组成。具名参数只能放在参数组的最后，并且有且只有一个不定参数。&lt;/p&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(...values)&amp;#123;
    console.log(values.length);
&amp;#125;
f(1,2);      //2
f(1,2,3,4);  //4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;箭头函数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#箭头函数&#34;&gt;#&lt;/a&gt; 箭头函数&lt;/h2&gt;
&lt;p&gt;箭头函数提供了一种更加简洁的函数书写方式。基本语法是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;参数 =&amp;gt; 函数体
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本用法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f = v =&amp;gt; v;
//等价于
var f = function(a)&amp;#123;
 return a;
&amp;#125;
f(1);  //1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当箭头函数没有参数或者有多个参数，要用 &lt;strong&gt;()&lt;/strong&gt; 括起来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f = (a,b) =&amp;gt; a+b;
f(6,2);  //8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当箭头函数函数体有多行语句，用 &lt;strong&gt;{}&lt;/strong&gt; 包裹起来，表示代码块，当只有一行语句，并且需要返回结果时，可以省略 &lt;strong&gt;{}&lt;/strong&gt; , 结果会自动返回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var f = (a,b) =&amp;gt; &amp;#123;
 let result = a+b;
 return result;
&amp;#125;
f(6,2);  // 8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当箭头函数要返回对象的时候，为了区分于代码块，要用 &lt;strong&gt;()&lt;/strong&gt; 将对象包裹起来&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 报错
var f = (id,name) =&amp;gt; &amp;#123;id: id, name: name&amp;#125;;
f(6,2);  // SyntaxError: Unexpected token :
 
// 不报错
var f = (id,name) =&amp;gt; (&amp;#123;id: id, name: name&amp;#125;);
f(6,2);  // &amp;#123;id: 6, name: 2&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意点：没有 this、super、arguments 和 new.target 绑定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var func = () =&amp;gt; &amp;#123;
  // 箭头函数里面没有 this 对象，
  // 此时的 this 是外层的 this 对象，即 Window 
  console.log(this)
&amp;#125;
func(55)  // Window 
 
var func = () =&amp;gt; &amp;#123;    
  console.log(arguments)
&amp;#125;
func(55);  // ReferenceError: arguments is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function fn()&amp;#123;
  setTimeout(()=&amp;gt;&amp;#123;
    // 定义时，this 绑定的是 fn 中的 this 对象
    console.log(this.a);
  &amp;#125;,0)
&amp;#125;
var a = 20;
// fn 的 this 对象为 &amp;#123;a: 18&amp;#125;
fn.call(&amp;#123;a: 18&amp;#125;);  // 18
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不可以作为构造函数，也就是不能使用 new 命令，否则会报错&lt;/p&gt;
&lt;h3 id=&#34;适合使用的场景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#适合使用的场景&#34;&gt;#&lt;/a&gt; 适合使用的场景&lt;/h3&gt;
&lt;p&gt;ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 回调函数
var Person = &amp;#123;
    &#39;age&#39;: 18,
    &#39;sayHello&#39;: function () &amp;#123;
      setTimeout(function () &amp;#123;
        console.log(this.age);
      &amp;#125;);
    &amp;#125;
&amp;#125;;
var age = 20;
Person.sayHello();  // 20
 
var Person1 = &amp;#123;
    &#39;age&#39;: 18,
    &#39;sayHello&#39;: function () &amp;#123;
      setTimeout(()=&amp;gt;&amp;#123;
        console.log(this.age);
      &amp;#125;);
    &amp;#125;
&amp;#125;;
var age = 20;
Person1.sayHello();  // 18
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。&lt;/p&gt;
&lt;h3 id=&#34;不适合使用的场景&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#不适合使用的场景&#34;&gt;#&lt;/a&gt; 不适合使用的场景&lt;/h3&gt;
&lt;p&gt;定义函数的方法，且该方法中包含 this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var Person = &amp;#123;
    &#39;age&#39;: 18,
    &#39;sayHello&#39;: ()=&amp;gt;&amp;#123;
        console.log(this.age);
      &amp;#125;
&amp;#125;;
var age = 20;
Person.sayHello();  // 20
// 此时 this 指向的是全局对象
 
var Person1 = &amp;#123;
    &#39;age&#39;: 18,
    &#39;sayHello&#39;: function () &amp;#123;
        console.log(this.age);
    &amp;#125;
&amp;#125;;
var age = 20;
Person1.sayHello();   // 18
// 此时的 this 指向 Person1 对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要动态 this 的时候&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var button = document.getElementById(&#39;userClick&#39;);
button.addEventListener(&#39;click&#39;, () =&amp;gt; &amp;#123;
     this.classList.toggle(&#39;on&#39;);
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;button 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象。&lt;/p&gt;
</content>
        <updated>2022-05-26T02:43:13.789Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E7%BB%84/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E7%BB%84/"/>
        <content type="html">&lt;h2 id=&#34;数组创建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数组创建&#34;&gt;#&lt;/a&gt; 数组创建&lt;/h2&gt;
&lt;h3 id=&#34;arrayof&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arrayof&#34;&gt;#&lt;/a&gt; Array.of()&lt;/h3&gt;
&lt;p&gt;将参数中所有值作为元素形成数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
 
// 参数值可为不同类型
console.log(Array.of(1, &#39;2&#39;, true)); // [1, &#39;2&#39;, true]
 
// 参数为空时返回空数组
console.log(Array.of()); // []
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;arrayfrom&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#arrayfrom&#34;&gt;#&lt;/a&gt; Array.from()&lt;/h3&gt;
&lt;p&gt;将类数组对象或可迭代对象转化为数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 参数为数组,返回与原数组一样的数组
console.log(Array.from([1, 2])); // [1, 2]
 
// 参数含空位
console.log(Array.from([1, , 3])); // [1, undefined, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Array.from(arrayLike[, mapFn[, thisArg]])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;返回值为转换后的数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;arrayLike&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想要转换的类数组对象或可迭代对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(Array.from([1, 2, 3])); // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;mapFn&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可选，map 函数，用于对每个元素进行处理，放入数组的是处理后的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(Array.from([1, 2, 3], (n) =&amp;gt; n * 2)); // [2, 4, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;thisArg&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可选，用于指定 map 函数执行时的 this 对象。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = &amp;#123;
    do: function(n) &amp;#123;
        return n * 2;
    &amp;#125;
&amp;#125;
let arrayLike = [1, 2, 3];
console.log(Array.from(arrayLike, function (n)&amp;#123;
    return this.do(n);
&amp;#125;, map)); // [2, 4, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;类数组对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#类数组对象&#34;&gt;#&lt;/a&gt; 类数组对象&lt;/h3&gt;
&lt;p&gt;一个类数组对象必须含有 length 属性，且元素属性名必须是数值或者可转换为数值的字符&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = Array.from(&amp;#123;
  0: &#39;1&#39;,
  1: &#39;2&#39;,
  2: 3,
  length: 3
&amp;#125;);
console.log(arr); // [&#39;1&#39;, &#39;2&#39;, 3]
 
// 没有 length 属性,则返回空数组
let array = Array.from(&amp;#123;
  0: &#39;1&#39;,
  1: &#39;2&#39;,
  2: 3,
&amp;#125;);
console.log(array); // []
 
// 元素属性名不为数值且无法转换为数值，返回长度为 length 元素值为 undefined 的数组  
let array1 = Array.from(&amp;#123;
  a: 1,
  b: 2,
  length: 2
&amp;#125;);
console.log(array1); // [undefined, undefined]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;转换可迭代对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#转换可迭代对象&#34;&gt;#&lt;/a&gt; 转换可迭代对象&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;转换 map&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let map = new Map();
map.set(&#39;key0&#39;, &#39;value0&#39;);
map.set(&#39;key1&#39;, &#39;value1&#39;);
console.log(Array.from(map)); // [[&#39;key0&#39;, &#39;value0&#39;],[&#39;key1&#39;,
// &#39;value1&#39;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;转换 set&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2, 3];
let set = new Set(arr);
console.log(Array.from(set)); // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;转换字符串&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let str = &#39;abc&#39;;
console.log(Array.from(str)); // [&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;扩展的方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#扩展的方法&#34;&gt;#&lt;/a&gt; 扩展的方法&lt;/h2&gt;
&lt;h3 id=&#34;查找&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#查找&#34;&gt;#&lt;/a&gt; 查找&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;find()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查找数组中符合条件的元素，若有多个符合条件的元素，则返回第一个元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = Array.of(1, 2, 3, 4);
console.log(arr.find(item =&amp;gt; item &amp;gt; 2)); // 3
 
// 数组空位处理为 undefined
console.log([, 1].find(n =&amp;gt; true)); // undefined
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;findIndex()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查找数组中符合条件的元素索引，若有多个符合条件的元素，则返回第一个元素索引。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = Array.of(1, 2, 1, 3);
// 参数1：回调函数
// 参数2(可选)：指定回调函数中的 this 值
console.log(arr.findIndex(item =&amp;gt; item == 2)); // 1
 
// 数组空位处理为 undefined
console.log([, 1].findIndex(n =&amp;gt; true)); //0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;填充&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#填充&#34;&gt;#&lt;/a&gt; 填充&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;fill()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一定范围索引的数组元素内容填充为单个指定的值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr = Array.of(1, 2, 3, 4);
// 参数1：用来填充的值
// 参数2：被填充的起始索引
// 参数3(可选)：被填充的结束索引，默认为数组末尾
console.log(arr.fill(0,1,2)); // [1, 0, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;copyWithin()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将一定范围索引的数组元素修改为此数组另一指定范围索引的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 参数1：被修改的起始索引
// 参数2：被用来覆盖的数据的起始索引
// 参数3(可选)：被用来覆盖的数据的结束索引，默认为数组末尾
console.log([1, 2, 3, 4].copyWithin(0,2,4)); // [3, 4, 3, 4]
 
// 参数1为负数表示倒数
console.log([1, 2, 3, 4].copyWithin(-2, 0)); // [1, 2, 1, 2]
 
console.log([1, 2, ,4].copyWithin(0, 2, 4)); // [, 4, , 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;遍历&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#遍历&#34;&gt;#&lt;/a&gt; 遍历&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;entries()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遍历键值对&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(let [key, value] of [&#39;a&#39;, &#39;b&#39;].entries())&amp;#123;
    console.log(key, value);
&amp;#125;
// 0 &amp;quot;a&amp;quot;
// 1 &amp;quot;b&amp;quot;
 
// 不使用 for... of 循环
let entries = [&#39;a&#39;, &#39;b&#39;].entries();
console.log(entries.next().value); // [0, &amp;quot;a&amp;quot;]
console.log(entries.next().value); // [1, &amp;quot;b&amp;quot;]
 
// 数组含空位
console.log([...[,&#39;a&#39;].entries()]); // [[0, undefined], [1, &amp;quot;a&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;keys()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遍历键名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(let key of [&#39;a&#39;, &#39;b&#39;].keys())&amp;#123;
    console.log(key);
&amp;#125;
// 0
// 1
 
// 数组含空位
console.log([...[,&#39;a&#39;].keys()]); // [0, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;values()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;遍历键值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(let value of [&#39;a&#39;, &#39;b&#39;].values())&amp;#123;
    console.log(value);
&amp;#125;
// &amp;quot;a&amp;quot;
// &amp;quot;b&amp;quot;
 
// 数组含空位
console.log([...[,&#39;a&#39;].values()]); // [undefined, &amp;quot;a&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;包含&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#包含&#34;&gt;#&lt;/a&gt; 包含&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;includes()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数组是否包含指定值。&lt;/p&gt;
&lt;p&gt;注意：与 Set 和 Map 的 has 方法区分；Set 的 has 方法用于查找值；Map 的 has 方法用于查找键名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 参数1：包含的指定值
[1, 2, 3].includes(1);    // true
 
// 参数2：可选，搜索的起始索引，默认为0
[1, 2, 3].includes(1, 2); // false
 
// NaN 的包含判断
[1, NaN, 3].includes(NaN); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;嵌套数组转一维数组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#嵌套数组转一维数组&#34;&gt;#&lt;/a&gt; 嵌套数组转一维数组&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;flat()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log([1 ,[2, 3]].flat()); // [1, 2, 3]
 
// 指定转换的嵌套层数
console.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]]
 
// 不管嵌套多少层
console.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]
 
// 自动跳过空位
console.log([1, [2, , 3]].flat());&amp;lt;p&amp;gt; // [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;flatMap()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先对数组中每个元素进行了的处理，再对数组执行 flat () 方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 参数1：遍历函数，该遍历函数可接受3个参数：当前元素、当前元素索引、原数组
// 参数2：指定遍历函数中 this 的指向
console.log([1, 2, 3].flatMap(n =&amp;gt; [n * 2])); // [2, 4, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数组缓冲区&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数组缓冲区&#34;&gt;#&lt;/a&gt; 数组缓冲区&lt;/h2&gt;
&lt;p&gt;数组缓冲区是内存中的一段地址。&lt;/p&gt;
&lt;p&gt;定型数组的基础。&lt;/p&gt;
&lt;p&gt;实际字节数在创建时确定，之后只可修改其中的数据，不可修改大小。&lt;/p&gt;
&lt;h3 id=&#34;创建数组缓冲区&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建数组缓冲区&#34;&gt;#&lt;/a&gt; 创建数组缓冲区&lt;/h3&gt;
&lt;p&gt;通过构造函数创建:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let buffer = new ArrayBuffer(10);
console.log(buffer.byteLength); // 10
分割已有数组缓冲区
let buffer = new ArrayBuffer(10);
let buffer1 = buffer.slice(1, 3);
console.log(buffer1.byteLength); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;视图&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#视图&#34;&gt;#&lt;/a&gt; 视图&lt;/h3&gt;
&lt;p&gt;视图是用来操作内存的接口。&lt;/p&gt;
&lt;p&gt;视图可以操作数组缓冲区或缓冲区字节的子集，并按照其中一种数值数据类型来读取和写入数据。&lt;/p&gt;
&lt;p&gt;DataView 类型是一种通用的数组缓冲区视图，其支持所有 8 种数值型数据类型。&lt;/p&gt;
&lt;p&gt;创建:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 默认 DataView 可操作数组缓冲区全部内容
let buffer = new ArrayBuffer(10);
    dataView = new DataView(buffer); 
dataView.setInt8(0,1);
console.log(dataView.getInt8(0)); // 1
 
// 通过设定偏移量(参数2)与长度(参数3)指定 DataView 可操作的字节范围
let buffer1 = new ArrayBuffer(10);
    dataView1 = new DataView(buffer1, 0, 3);
dataView1.setInt8(5,1); // RangeError
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定型数组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#定型数组&#34;&gt;#&lt;/a&gt; 定型数组&lt;/h2&gt;
&lt;p&gt;数组缓冲区的特定类型的视图。&lt;/p&gt;
&lt;p&gt;可以强制使用特定的数据类型，而不是使用通用的 DataView 对象来操作数组缓冲区。&lt;/p&gt;
&lt;h3 id=&#34;创建&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#创建&#34;&gt;#&lt;/a&gt; 创建&lt;/h3&gt;
&lt;p&gt;通过数组缓冲区生成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let buffer = new ArrayBuffer(10),
    view = new Int8Array(buffer);
console.log(view.byteLength); // 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let view = new Int32Array(10);
console.log(view.byteLength); // 40
console.log(view.length);     // 10
 
// 不传参则默认长度为0
// 在这种情况下数组缓冲区分配不到空间，创建的定型数组不能用来保存数据
let view1 = new Int32Array();
console.log(view1.byteLength); // 0
console.log(view1.length);     // 0
 
// 可接受参数包括定型数组、可迭代对象、数组、类数组对象
let arr = Array.from(&amp;#123;
  0: &#39;1&#39;,
  1: &#39;2&#39;,
  2: 3,
  length: 3
&amp;#125;);
let view2 = new Int16Array([1, 2]),
    view3 = new Int32Array(view2),
    view4 = new Int16Array(new Set([1, 2, 3])),
    view5 = new Int16Array([1, 2, 3]),
    view6 = new Int16Array(arr);
console.log(view2 .buffer === view3.buffer); // false
console.log(view4.byteLength); // 6
console.log(view5.byteLength); // 6
console.log(view6.byteLength); // 6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意要点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#注意要点&#34;&gt;#&lt;/a&gt; 注意要点&lt;/h3&gt;
&lt;p&gt;length 属性不可写，如果尝试修改这个值，在非严格模式下会直接忽略该操作，在严格模式下会抛出错误&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let view = new Int16Array([1, 2]);
view.length = 3;
console.log(view.length); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定型数组可使用 entries ()、keys ()、values () 进行迭代&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let view = new Int16Array([1, 2]);
for(let [k, v] of view.entries())&amp;#123;
    console.log(k, v);
&amp;#125;
// 0 1
// 1 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;find () 等方法也可用于定型数组，但是定型数组中的方法会额外检查数值类型是否安全，也会通过 Symbol.species 确认方法的返回值是定型数组而非普通数组。concat () 方法由于两个定型数组合并结果不确定，故不能用于定型数组；另外，由于定型数组的尺寸不可更改，可以改变数组的尺寸的方法，例如 splice () ，不适用于定型数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let view = new Int16Array([1, 2]);
view.find((n) &amp;gt; 1); // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有定型数组都含有静态 of () 方法和 from () 方法，运行效果分别与 Array.of () 方法和 Array.from () 方法相似，区别是定型数组的方法返回定型数组，而普通数组的方法返回普通数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let view = Int16Array.of(1, 2);
console.log(view instanceof Int16Array); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定型数组不是普通数组，不继承自 Array&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let view = new Int16Array([1, 2]);
console.log(Array.isArray(view)); // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定型数组中增加了 set () 与 subarray () 方法。 set () 方法用于将其他数组复制到已有定型数组，subarray () 用于提取已有定型数组的一部分形成新的定型数组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// set 方法
// 参数1：一个定型数组或普通数组
// 参数2：可选，偏移量，开始插入数据的位置，默认为0
let view= new Int16Array(4);
view.set([1, 2]);
view.set([3, 4], 2);
console.log(view); // [1, 2, 3, 4]
 
// subarray 方法
// 参数1：可选，开始位置
// 参数2：可选，结束位置(不包含结束位置)
let view= new Int16Array([1, 2, 3, 4]), 
    subview1 = view.subarray(), 
    subview2 = view.subarray(1), 
    subview3 = view.subarray(1, 3);
console.log(subview1); // [1, 2, 3, 4]
console.log(subview2); // [2, 3, 4]
console.log(subview3); // [2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;扩展运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#扩展运算符&#34;&gt;#&lt;/a&gt; 扩展运算符&lt;/h2&gt;
&lt;h3 id=&#34;复制数组&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#复制数组&#34;&gt;#&lt;/a&gt; 复制数组&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;let arr = [1, 2],
    arr1 = [...arr];
console.log(arr1); // [1, 2]
 
// 数组含空位
let arr2 = [1, , 3],
    arr3 = [...arr2];
console.log(arr3); [1, undefined, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;合并数组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log([...[1, 2],...[3, 4]]); // [1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-05-26T02:43:10.552Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AF%B9%E8%B1%A1/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AF%B9%E8%B1%A1/"/>
        <content type="html">&lt;h2 id=&#34;对象字面量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对象字面量&#34;&gt;#&lt;/a&gt; 对象字面量&lt;/h2&gt;
&lt;h3 id=&#34;属性的简洁表示法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#属性的简洁表示法&#34;&gt;#&lt;/a&gt; 属性的简洁表示法&lt;/h3&gt;
&lt;p&gt;ES6 允许对象的属性直接写变量，这时候属性名是变量名，属性值是变量值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const age = 12;
const name = &amp;quot;Amy&amp;quot;;
const person = &amp;#123;age, name&amp;#125;;
person   //&amp;#123;age: 12, name: &amp;quot;Amy&amp;quot;&amp;#125;
//等同于
const person = &amp;#123;age: age, name: name&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法名也可以简写&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#方法名也可以简写&#34;&gt;#&lt;/a&gt; 方法名也可以简写&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const person = &amp;#123;
  sayHi()&amp;#123;
    console.log(&amp;quot;Hi&amp;quot;);
  &amp;#125;
&amp;#125;
person.sayHi();  //&amp;quot;Hi&amp;quot;
//等同于
const person = &amp;#123;
  sayHi:function()&amp;#123;
    console.log(&amp;quot;Hi&amp;quot;);
  &amp;#125;
&amp;#125;
person.sayHi();//&amp;quot;Hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是 Generator 函数，则要在前面加一个星号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const obj = &amp;#123;
  * myGenerator() &amp;#123;
    yield &#39;hello world&#39;;
  &amp;#125;
&amp;#125;;
//等同于
const obj = &amp;#123;
  myGenerator: function* () &amp;#123;
    yield &#39;hello world&#39;;
  &amp;#125;
&amp;#125;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;属性名表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#属性名表达式&#34;&gt;#&lt;/a&gt; 属性名表达式&lt;/h3&gt;
&lt;p&gt;ES6 允许用表达式作为属性名，但是一定要将表达式放在方括号内&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const obj = &amp;#123;
 [&amp;quot;he&amp;quot;+&amp;quot;llo&amp;quot;]()&amp;#123;
   return &amp;quot;Hi&amp;quot;;
  &amp;#125;
&amp;#125;
obj.hello();  //&amp;quot;Hi&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意点：属性的简洁表示法和属性名表达式不能同时使用，否则会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const hello = &amp;quot;Hello&amp;quot;;
const obj = &amp;#123;
 [hello]
&amp;#125;;
obj  //SyntaxError: Unexpected token &amp;#125;
 
const hello = &amp;quot;Hello&amp;quot;;
const obj = &amp;#123;
 [hello+&amp;quot;2&amp;quot;]:&amp;quot;world&amp;quot;
&amp;#125;;
obj  //&amp;#123;Hello2: &amp;quot;world&amp;quot;&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;对象的拓展运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对象的拓展运算符&#34;&gt;#&lt;/a&gt; 对象的拓展运算符&lt;/h2&gt;
&lt;p&gt;拓展运算符（...）用于取出参数对象所有可遍历属性然后拷贝到当前对象。&lt;/p&gt;
&lt;h3 id=&#34;基本用法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#基本用法&#34;&gt;#&lt;/a&gt; 基本用法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;let person = &amp;#123;name: &amp;quot;Amy&amp;quot;, age: 15&amp;#125;;
let someone = &amp;#123; ...person &amp;#125;;
someone;  //&amp;#123;name: &amp;quot;Amy&amp;quot;, age: 15&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;可用于合并两个对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#可用于合并两个对象&#34;&gt;#&lt;/a&gt; 可用于合并两个对象&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;let age = &amp;#123;age: 15&amp;#125;;
let name = &amp;#123;name: &amp;quot;Amy&amp;quot;&amp;#125;;
let person = &amp;#123;...age, ...name&amp;#125;;
person;  //&amp;#123;age: 15, name: &amp;quot;Amy&amp;quot;&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;注意点&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#注意点&#34;&gt;#&lt;/a&gt; 注意点&lt;/h3&gt;
&lt;p&gt;自定义的属性和拓展运算符对象里面属性的相同的时候：&lt;strong&gt;自定义的属性在拓展运算符后面，则拓展运算符对象内部同名的属性将被覆盖掉。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let person = &amp;#123;name: &amp;quot;Amy&amp;quot;, age: 15&amp;#125;;
let someone = &amp;#123; ...person, name: &amp;quot;Mike&amp;quot;, age: 17&amp;#125;;
someone;  //&amp;#123;name: &amp;quot;Mike&amp;quot;, age: 17&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义的属性在拓展运算度前面，则变成设置新对象默认属性值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let person = &amp;#123;name: &amp;quot;Amy&amp;quot;, age: 15&amp;#125;;
let someone = &amp;#123;name: &amp;quot;Mike&amp;quot;, age: 17, ...person&amp;#125;;
someone;  //&amp;#123;name: &amp;quot;Amy&amp;quot;, age: 15&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拓展运算符后面是空对象，没有任何效果也不会报错。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a = &amp;#123;...&amp;#123;&amp;#125;, a: 1, b: 2&amp;#125;;
a;  //&amp;#123;a: 1, b: 2&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拓展运算符后面是 null 或者 undefined，没有效果也不会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let b = &amp;#123;...null, ...undefined, a: 1, b: 2&amp;#125;;
b;  //&amp;#123;a: 1, b: 2&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;对象的新方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对象的新方法&#34;&gt;#&lt;/a&gt; 对象的新方法&lt;/h2&gt;
&lt;h3 id=&#34;objectassigntarget-source_1&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#objectassigntarget-source_1&#34;&gt;#&lt;/a&gt; Object.assign(target, source_1, ···)&lt;/h3&gt;
&lt;p&gt;用于将源对象的所有可枚举属性复制到目标对象中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本用法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let target = &amp;#123;a: 1&amp;#125;;
let object2 = &amp;#123;b: 2&amp;#125;;
let object3 = &amp;#123;c: 3&amp;#125;;
Object.assign(target,object2,object3);  
// 第一个参数是目标对象，后面的参数是源对象
target;  // &amp;#123;a: 1, b: 2, c: 3
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.assign(3);         // Number &amp;#123;3&amp;#125;
typeof Object.assign(3);  // &amp;quot;object&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为 null 和 undefined 不能转化为对象，所以会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.assign(null);       // TypeError: Cannot convert undefined or null to object
Object.assign(undefined);  // TypeError: Cannot convert undefined or null to object
当参数不止一个时，null 和 undefined 不放第一个，即不为目标对象时，会跳过 null 和 undefined ，不报错
Object.assign(1,undefined);  // Number &amp;#123;1&amp;#125;
Object.assign(&amp;#123;a: 1&amp;#125;,null);  // &amp;#123;a: 1&amp;#125;
 
Object.assign(undefined,&amp;#123;a: 1&amp;#125;);  // TypeError: Cannot convert undefined or null to object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;assign 的属性拷贝是浅拷贝:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let sourceObj = &amp;#123; a: &amp;#123; b: 1&amp;#125;&amp;#125;;
let targetObj = &amp;#123;c: 3&amp;#125;;
Object.assign(targetObj, sourceObj);
targetObj.a.b = 2;
sourceObj.a.b;  // 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同名属性替换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;targetObj = &amp;#123; a: &amp;#123; b: 1, c:2&amp;#125;&amp;#125;;
sourceObj = &amp;#123; a: &amp;#123; b: &amp;quot;hh&amp;quot;&amp;#125;&amp;#125;;
Object.assign(targetObj, sourceObj);
targetObj;  // &amp;#123;a: &amp;#123;b: &amp;quot;hh&amp;quot;&amp;#125;&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的处理&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.assign([2,3], [5]);  // [5,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会将数组处理成对象，所以先将 [2,3] 转为 {0:2,1:3} ，然后再进行属性复制，所以源对象的 0 号属性覆盖了目标对象的 0。&lt;/p&gt;
&lt;h3 id=&#34;objectis&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#objectis&#34;&gt;#&lt;/a&gt; &lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cDovL09iamVjdC5pcw==&#34;&gt;Object.is&lt;/span&gt;(value1, value2)&lt;/h3&gt;
&lt;p&gt;用来比较两个值是否严格相等，与（===）基本类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本用法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Object.is(&amp;quot;q&amp;quot;,&amp;quot;q&amp;quot;);      // true
Object.is(1,1);          // true
Object.is([1],[1]);      // false
Object.is(&amp;#123;q:1&amp;#125;,&amp;#123;q:1&amp;#125;);  // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与（===）的区别&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//一是+0不等于-0
Object.is(+0,-0);  //false
+0 === -0  //true
//二是NaN等于本身
Object.is(NaN,NaN); //true
NaN === NaN  //false
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-05-26T02:43:07.644Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E5%80%BC/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/%E6%95%B0%E5%80%BC/"/>
        <content type="html">&lt;h2 id=&#34;数值的表示&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数值的表示&#34;&gt;#&lt;/a&gt; 数值的表示&lt;/h2&gt;
&lt;p&gt;二进制表示法新写法：前缀 0b 或 0B 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(0b11 === 3); // true
console.log(0B11 === 3); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;八进制表示法新写法：前缀 0o 或 0O 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(0o11 === 9); // true
console.log(0O11 === 9); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常量&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#常量&#34;&gt;#&lt;/a&gt; 常量&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Number.EPSILON
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Number.EPSILON 属性表示 1 与大于 1 的最小浮点数之间的差。&lt;/p&gt;
&lt;p&gt;它的值接近于 2.2204460492503130808472633361816E-16，或者 2-52。&lt;/p&gt;
&lt;p&gt;测试数值是否在误差范围内:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0.1 + 0.2 === 0.3; // false
// 在误差范围内即视为相等
equal = (Math.abs(0.1 - 0.3 + 0.2) &amp;lt; Number.EPSILON); // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;属性特性&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#属性特性&#34;&gt;#&lt;/a&gt; 属性特性&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;writable：false
enumerable：false
configurable：false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;最大最小安全整数&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#最大最小安全整数&#34;&gt;#&lt;/a&gt; 最大 / 最小安全整数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;安全整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安全整数表示在 JavaScript 中能够精确表示的整数，安全整数的范围在 2 的 -53 次方到 2 的 53 次方之间（不包括两个端点），超过这个范围的整数无法精确表示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最大安全整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安全整数范围的上限，即 2 的 53 次方减 1 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2; // true
Number.MAX_SAFE_INTEGER === Number.MAX_SAFE_INTEGER + 1;     // false
Number.MAX_SAFE_INTEGER - 1 === Number.MAX_SAFE_INTEGER - 2; // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最小安全整数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安全整数范围的下限，即 2 的 53 次方减 1 的负数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.MIN_SAFE_INTEGER + 1 === Number.MIN_SAFE_INTEGER + 2; // false
Number.MIN_SAFE_INTEGER === Number.MIN_SAFE_INTEGER - 1;     // false
Number.MIN_SAFE_INTEGER - 1 === Number.MIN_SAFE_INTEGER - 2; // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;属性特性&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;writable：false
enumerable：false
configurable：false
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#方法&#34;&gt;#&lt;/a&gt; 方法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Number 对象新方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.isFinite()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于检查一个数值是否为有限的（ finite ），即不是 Infinity&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log( Number.isFinite(1));   // true
console.log( Number.isFinite(0.1)); // true
 
// NaN 不是有限的
console.log( Number.isFinite(NaN)); // false
 
console.log( Number.isFinite(Infinity));  // false
console.log( Number.isFinite(-Infinity)); // false
 
// Number.isFinate 没有隐式的 Number() 类型转换，所有非数值都返回 false
console.log( Number.isFinite(&#39;foo&#39;)); // false
console.log( Number.isFinite(&#39;15&#39;));  // false
console.log( Number.isFinite(true));  // false
Number.isNaN()
用于检查一个值是否为 NaN 。
console.log(Number.isNaN(NaN));      // true
console.log(Number.isNaN(&#39;true&#39;/0)); // true
 
// 在全局的 isNaN() 中，以下皆返回 true，因为在判断前会将非数值向数值转换
// 而 Number.isNaN() 不存在隐式的 Number() 类型转换，非 NaN 全部返回 false
Number.isNaN(&amp;quot;NaN&amp;quot;);      // false
Number.isNaN(undefined);  // false
Number.isNaN(&amp;#123;&amp;#125;);         // false
Number.isNaN(&amp;quot;true&amp;quot;);     // false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;从全局移植到 Number 对象的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;逐步减少全局方法，用于全局变量的模块化。&lt;/p&gt;
&lt;p&gt;方法的行为没有发生改变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Number.parseInt()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于将给定字符串转化为指定进制的整数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 不指定进制时默认为 10 进制
Number.parseInt(&#39;12.34&#39;); // 12
Number.parseInt(12.34);   // 12
 
// 指定进制
Number.parseInt(&#39;0011&#39;,2); // 3
 
// 与全局的 parseInt() 函数是同一个函数
Number.parseInt === parseInt; // true
Number.parseFloat()
用于把一个字符串解析成浮点数。
Number.parseFloat(&#39;123.45&#39;)    // 123.45
Number.parseFloat(&#39;123.45abc&#39;) // 123.45
 
// 无法被解析成浮点数，则返回 NaN
Number.parseFloat(&#39;abc&#39;) // NaN
 
// 与全局的 parseFloat() 方法是同一个方法
Number.parseFloat === parseFloat // true
Number.isInteger()
用于判断给定的参数是否为整数。
Number.isInteger(value)
Number.isInteger(0); // true
// JavaScript 内部，整数和浮点数采用的是同样的储存方法,因此 1 与 1.0 被视为相同的值
Number.isInteger(1);   // true
Number.isInteger(1.0); // true
 
Number.isInteger(1.1);     // false
Number.isInteger(Math.PI); // false
 
// NaN 和正负 Infinity 不是整数
Number.isInteger(NaN);       // false
Number.isInteger(Infinity);  // false
Number.isInteger(-Infinity); // false
 
Number.isInteger(&amp;quot;10&amp;quot;);  // false
Number.isInteger(true);  // false
Number.isInteger(false); // false
Number.isInteger([1]);   // false
 
// 数值的精度超过 53 个二进制位时，由于第 54 位及后面的位被丢弃，会产生误判
Number.isInteger(1.0000000000000001) // true
 
// 一个数值的绝对值小于 Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨
// 的最小值，会被自动转为 0，也会产生误判
Number.isInteger(5E-324); // false
Number.isInteger(5E-325); // true
Number.isSafeInteger()
用于判断数值是否在安全范围内。
Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1); // false
Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1); // false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;math-对象的扩展&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#math-对象的扩展&#34;&gt;#&lt;/a&gt; Math 对象的扩展&lt;/h2&gt;
&lt;p&gt;ES6 在 Math 对象上新增了 17 个数学相关的静态方法，这些方法只能在 Math 中调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;普通计算&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.cbrt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于计算一个数的立方根。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.cbrt(1);  // 1
Math.cbrt(0);  // 0
Math.cbrt(-1); // -1
// 会对非数值进行转换
Math.cbrt(&#39;1&#39;); // 1
 
// 非数值且无法转换为数值时返回 NaN
Math.cbrt(&#39;hhh&#39;); // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Math.imul
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 大多数情况下，结果与 a * b 相同 
Math.imul(1, 2);   // 2
 
// 用于正确返回大数乘法结果中的低位数值
Math.imul(0x7fffffff, 0x7fffffff); // 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Math.hypot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于计算所有参数的平方和的平方根。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.hypot(3, 4); // 5
 
// 非数值会先被转换为数值后进行计算
Math.hypot(1, 2, &#39;3&#39;); // 3.741657386773941
Math.hypot(true);      // 1
Math.hypot(false);     // 0
 
// 空值会被转换为 0
Math.hypot();   // 0
Math.hypot([]); // 0
 
// 参数为 Infinity 或 -Infinity 返回 Infinity
Math.hypot(Infinity); // Infinity
Math.hypot(-Infinity); // Infinity
 
// 参数中存在无法转换为数值的参数时返回 NaN
Math.hypot(NaN);         // NaN
Math.hypot(3, 4, &#39;foo&#39;); // NaN
Math.hypot(&amp;#123;&amp;#125;);          // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Math.clz32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于返回数字的 32 位无符号整数形式的前导 0 的个数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.clz32(0); // 32
Math.clz32(1); // 31
Math.clz32(0b01000000000100000000000000000000); // 1
 
// 当参数为小数时，只考虑整数部分
Math.clz32(0.5); // 32
 
// 对于空值或非数值，会转化为数值再进行计算
Math.clz32(&#39;1&#39;);       // 31
Math.clz32();          // 32
Math.clz32([]);        // 32
Math.clz32(&amp;#123;&amp;#125;);        // 32
Math.clz32(NaN);       // 32
Math.clz32(Infinity);  // 32
Math.clz32(-Infinity); // 32
Math.clz32(undefined); // 32
Math.clz32(&#39;hhh&#39;);     // 32
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数字处理&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#数字处理&#34;&gt;#&lt;/a&gt; 数字处理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Math.trunc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于返回数字的整数部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.trunc(12.3); // 12
Math.trunc(12);   // 12
 
// 整数部分为 0 时也会判断符号
Math.trunc(-0.5); // -0
Math.trunc(0.5);  // 0
 
// Math.trunc 会将非数值转为数值再进行处理
Math.trunc(&amp;quot;12.3&amp;quot;); // 12
 
// 空值或无法转化为数值时时返回 NaN
Math.trunc();           // NaN
Math.trunc(NaN);        // NaN
Math.trunc(&amp;quot;hhh&amp;quot;);      // NaN
Math.trunc(&amp;quot;123.2hhh&amp;quot;); // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Math.fround
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于获取数字的 32 位单精度浮点数形式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 对于 2 的 24 次方取负至 2 的 24 次方之间的整数（不含两个端点），返回结果与参数本身一致
Math.fround(-(2**24)+1);  // -16777215
Math.fround(2 ** 24 - 1); // 16777215
 
// 用于将 64 位双精度浮点数转为 32 位单精度浮点数
Math.fround(1.234) // 1.125
// 当小数的精度超过 24 个二进制位，会丢失精度
Math.fround(0.3); // 0.30000001192092896
// 参数为 NaN 或 Infinity 时返回本身
Math.fround(NaN)      // NaN
Math.fround(Infinity) // Infinity
 
// 参数为其他非数值类型时会将参数进行转换 
Math.fround(&#39;5&#39;);  // 5
Math.fround(true); // 1
Math.fround(null); // 0
Math.fround([]);   // 0
Math.fround(&amp;#123;&amp;#125;);   // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;判断&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#判断&#34;&gt;#&lt;/a&gt; 判断&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Math.sign
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;判断数字的符号（正、负、0）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.sign(1);  // 1
Math.sign(-1); // -1
 
// 参数为 0 时，不同符号的返回不同
Math.sign(0);  // 0
Math.sign(-0); // -0
 
// 判断前会对非数值进行转换
Math.sign(&#39;1&#39;);  // 1
Math.sign(&#39;-1&#39;); // -1  
 
// 参数为非数值（无法转换为数值）时返回 NaN
Math.sign(NaN);   // NaN 
Math.sign(&#39;hhh&#39;); // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对数方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#对数方法&#34;&gt;#&lt;/a&gt; 对数方法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;Math.expm1()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于计算 e 的 x 次方减 1 的结果，即 Math.exp (x) - 1 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.expm1(1);  // 1.718281828459045
Math.expm1(0);  // 0
Math.expm1(-1); // -0.6321205588285577
// 会对非数值进行转换
Math.expm1(&#39;0&#39;); //0
 
// 参数不为数值且无法转换为数值时返回 NaN
Math.expm1(NaN); // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Math.log1p(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于计算 1 + x 的自然对数，即 Math.log (1 + x) 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.log1p(1);  // 0.6931471805599453
Math.log1p(0);  // 0
Math.log1p(-1); // -Infinity
 
// 参数小于 -1 时返回 NaN
Math.log1p(-2); // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Math.log10(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于计算以 10 为底的 x 的对数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.log10(1);   // 0
// 计算前对非数值进行转换
Math.log10(&#39;1&#39;); // 0
// 参数为0时返回 -Infinity
Math.log10(0);   // -Infinity
// 参数小于0或参数不为数值（且无法转换为数值）时返回 NaN
Math.log10(-1);  // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Math.log2()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于计算 2 为底的 x 的对数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Math.log2(1);   // 0
// 计算前对非数值进行转换
Math.log2(&#39;1&#39;); // 0
// 参数为0时返回 -Infinity
Math.log2(0);   // -Infinity
// 参数小于0或参数不为数值（且无法转换为数值）时返回 NaN
Math.log2(-1);  // NaN
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;双曲函数方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#双曲函数方法&#34;&gt;#&lt;/a&gt; 双曲函数方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Math.sinh (x): 用于计算双曲正弦。&lt;/li&gt;
&lt;li&gt;Math.cosh (x): 用于计算双曲余弦。&lt;/li&gt;
&lt;li&gt;Math.tanh (x): 用于计算双曲正切。&lt;/li&gt;
&lt;li&gt;Math.asinh (x): 用于计算反双曲正弦。&lt;/li&gt;
&lt;li&gt;Math.acosh (x): 用于计算反双曲余弦。&lt;/li&gt;
&lt;li&gt;Math.atanh (x): 用于计算反双曲正切。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;指数运算符&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#指数运算符&#34;&gt;#&lt;/a&gt; 指数运算符&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1 ** 2; // 1
// 右结合，从右至左计算
2 ** 2 ** 3; // 256
// **=
let exam = 2;
exam ** = 2; // 4
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-05-26T02:43:04.362Z</updated>
    </entry>
    <entry>
        <id>https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
        <title></title>
        <link rel="alternate" href="https://entropywhite.com/computer-science/web/JavaScript/ES6/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
        <content type="html">&lt;h3 id=&#34;拓展的方法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#拓展的方法&#34;&gt;#&lt;/a&gt; 拓展的方法&lt;/h3&gt;
&lt;h3 id=&#34;子串的识别&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#子串的识别&#34;&gt;#&lt;/a&gt; 子串的识别&lt;/h3&gt;
&lt;p&gt;ES6 之前判断字符串是否包含子串，用 indexOf 方法，ES6 新增了子串的识别方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;includes()&lt;/strong&gt;：返回布尔值，判断是否找到参数字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;startsWith()&lt;/strong&gt;：返回布尔值，判断参数字符串是否在原字符串的头部。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;endsWith()&lt;/strong&gt;：返回布尔值，判断参数字符串是否在原字符串的尾部。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上三个方法都可以接受两个参数，需要搜索的字符串，和可选的搜索起始位置索引。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let string = &amp;quot;apple,banana,orange&amp;quot;;
string.includes(&amp;quot;banana&amp;quot;);     // true
string.startsWith(&amp;quot;apple&amp;quot;);    // true
string.endsWith(&amp;quot;apple&amp;quot;);      // false
string.startsWith(&amp;quot;banana&amp;quot;,6)  // true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这三个方法只返回布尔值，如果需要知道子串的位置，还是得用 indexOf 和 lastIndexOf 。&lt;/li&gt;
&lt;li&gt;这三个方法如果传入了正则表达式而不是字符串，会抛出错误。而 indexOf 和 lastIndexOf 这两个方法，它们会将正则表达式转换为字符串并搜索它。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;字符串重复&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#字符串重复&#34;&gt;#&lt;/a&gt; 字符串重复&lt;/h3&gt;
&lt;p&gt;repeat ()：返回新的字符串，表示将字符串重复指定次数返回。&lt;/p&gt;
&lt;h3 id=&#34;字符串重复-2&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#字符串重复-2&#34;&gt;#&lt;/a&gt; 字符串重复&lt;/h3&gt;
&lt;p&gt;repeat ()：返回新的字符串，表示将字符串重复指定次数返回。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;Hello,&amp;quot;.repeat(2));  // &amp;quot;Hello,Hello,&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果参数是小数，向下取整&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;Hello,&amp;quot;.repeat(3.2));  // &amp;quot;Hello,Hello,Hello,&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果参数是 0 至 -1 之间的小数，会进行取整运算，0 至 -1 之间的小数取整得到 -0 ，等同于 repeat 零次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;Hello,&amp;quot;.repeat(-0.5));  // &amp;quot;&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果参数是 NaN，等同于 repeat 零次&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;Hello,&amp;quot;.repeat(NaN));  // &amp;quot;&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果参数是负数或者 Infinity ，会报错:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;Hello,&amp;quot;.repeat(-1));  
// RangeError: Invalid count value

console.log(&amp;quot;Hello,&amp;quot;.repeat(Infinity));  
// RangeError: Invalid count value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果传入的参数是字符串，则会先将字符串转化为数字&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;Hello,&amp;quot;.repeat(&amp;quot;hh&amp;quot;)); // &amp;quot;&amp;quot;
console.log(&amp;quot;Hello,&amp;quot;.repeat(&amp;quot;2&amp;quot;));  // &amp;quot;Hello,Hello,&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;字符串补全&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#字符串补全&#34;&gt;#&lt;/a&gt; 字符串补全&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;padStart&lt;/strong&gt;：返回新的字符串，表示用参数字符串从头部（左侧）补全原字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;padEnd&lt;/strong&gt;：返回新的字符串，表示用参数字符串从尾部（右侧）补全原字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上两个方法接受两个参数，第一个参数是指定生成的字符串的最小长度，第二个参数是用来补全的字符串。如果没有指定第二个参数，默认用空格填充。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;h&amp;quot;.padStart(5,&amp;quot;o&amp;quot;));  // &amp;quot;ooooh&amp;quot;
console.log(&amp;quot;h&amp;quot;.padEnd(5,&amp;quot;o&amp;quot;));    // &amp;quot;hoooo&amp;quot;
console.log(&amp;quot;h&amp;quot;.padStart(5));      // &amp;quot;    h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果指定的长度小于或者等于原字符串的长度，则返回原字符串:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;hello&amp;quot;.padStart(5,&amp;quot;A&amp;quot;));  // &amp;quot;hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果原字符串加上补全字符串长度大于指定长度，则截去超出位数的补全字符串:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;hello&amp;quot;.padEnd(10,&amp;quot;,world!&amp;quot;));  // &amp;quot;hello,worl&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常用于补全位数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;console.log(&amp;quot;123&amp;quot;.padStart(10,&amp;quot;0&amp;quot;));  // &amp;quot;0000000123&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模板字符串&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#模板字符串&#34;&gt;#&lt;/a&gt; 模板字符串&lt;/h3&gt;
&lt;p&gt;模板字符串相当于加强版的字符串，用反引号 &lt;strong&gt;`&lt;/strong&gt;, 除了作为普通字符串，还可以用来定义多行字符串，还可以在字符串中加入变量和表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本用法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;普通字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let string = `Hello&#39;\n&#39;world`;
console.log(string); 
// &amp;quot;Hello&#39;
// &#39;world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行字符串:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let string1 =  `Hey,
can you stop angry now?`;
console.log(string1);
// Hey,
// can you stop angry now?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串插入变量和表达式。&lt;/p&gt;
&lt;p&gt;变量名写在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math xmlns=&#34;http://www.w3.org/1998/Math/MathML&#34;&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mtext&gt;中，&lt;/mtext&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;{} 中，&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;{} 中可以放入 JavaScript 表达式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let name = &amp;quot;Mike&amp;quot;;
let age = 27;
let info = `My Name is $&amp;#123;name&amp;#125;,I am $&amp;#123;age+1&amp;#125; years old next year.`
console.log(info);
// My Name is Mike,I am 28 years old next year.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串中调用函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f()&amp;#123;
  return &amp;quot;have fun!&amp;quot;;
&amp;#125;
let string2= `Game start,$&amp;#123;f()&amp;#125;`;
console.log(string2);  // Game start,have fun!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意要点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模板字符串中的换行和空格都是会被保留的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;innerHtml = `&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;menu&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;mine&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
`;
console.log(innerHtml);
// 输出
&amp;lt;ul&amp;gt;
 &amp;lt;li&amp;gt;menu&amp;lt;/li&amp;gt;
 &amp;lt;li&amp;gt;mine&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;标签模板&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#标签模板&#34;&gt;#&lt;/a&gt; 标签模板&lt;/h3&gt;
&lt;p&gt;标签模板，是一个函数的调用，其中调用的参数是模板字符串&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alert`Hello world!`;
// 等价于
alert(&#39;Hello world!&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当模板字符串中带有变量，会将模板字符串参数处理成多个参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(stringArr,...values)&amp;#123;
 let result = &amp;quot;&amp;quot;;
 for(let i=0;i&amp;lt;stringArr.length;i++)&amp;#123;
  result += stringArr[i];
  if(values[i])&amp;#123;
   result += values[i];
        &amp;#125;
    &amp;#125;
 return result;
&amp;#125;
let name = &#39;Mike&#39;;
let age = 27;
f`My Name is $&amp;#123;name&amp;#125;,I am $&amp;#123;age+1&amp;#125; years old next year.`;
// &amp;quot;My Name is Mike,I am 28 years old next year.&amp;quot;
 
f`My Name is $&amp;#123;name&amp;#125;,I am $&amp;#123;age+1&amp;#125; years old next year.`;
// 等价于
f([&#39;My Name is&#39;,&#39;,I am &#39;,&#39; years old next year.&#39;],&#39;Mike&#39;,28);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;过滤 HTML 字符串，防止用户输入恶意内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function f(stringArr,...values)&amp;#123;
 let result = &amp;quot;&amp;quot;;
 for(let i=0;i&amp;lt;stringArr.length;i++)&amp;#123;
  result += stringArr[i];
   if(values[i])&amp;#123;
     result += String(values[i]).replace(/&amp;amp;/g, &amp;quot;&amp;amp;amp;&amp;quot;)
               .replace(/&amp;lt;/g, &amp;quot;&amp;amp;lt;&amp;quot;)
               .replace(/&amp;gt;/g, &amp;quot;&amp;amp;gt;&amp;quot;);
    &amp;#125;
 &amp;#125;
 return result;
&amp;#125;
name = &#39;&amp;lt;Amy&amp;amp;MIke&amp;gt;&#39;;
f`&amp;lt;p&amp;gt;Hi, $&amp;#123;name&amp;#125;.I would like send you some message.&amp;lt;/p&amp;gt;`;
// &amp;lt;p&amp;gt;Hi, &amp;amp;lt;Amy&amp;amp;amp;MIke&amp;amp;gt;.I would like send you some message.&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;国际化处理（转化多国语言）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;i18n`Hello $&amp;#123;name&amp;#125;, you are visitor number $&amp;#123;visitorNumber&amp;#125;.`;  
// 你好**，你是第**位访问者
&lt;/code&gt;&lt;/pre&gt;
</content>
        <updated>2022-05-26T02:42:57.822Z</updated>
    </entry>
</feed>
